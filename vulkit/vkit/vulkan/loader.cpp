// Generated by Convoy's code generation script: 'vkloader.py'
#include "vkit/core/pch.hpp"
#include "vkit/vulkan/loader.hpp"
#include "tkit/utils/debug.hpp"
namespace VKit::Vulkan
{

#if defined(VKIT_API_VERSION_1_0)
PFN_vkCreateInstance vkCreateInstance = VK_NULL_HANDLE;
VkResult CreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator,
                        VkInstance *pInstance)
{
    TKIT_ASSERT(Vulkan::vkCreateInstance,
                "[VULKIT][LOADER] The function 'vkCreateInstance' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return Vulkan::vkCreateInstance(pCreateInfo, pAllocator, pInstance);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
PFN_vkGetInstanceProcAddr vkGetInstanceProcAddr = VK_NULL_HANDLE;
PFN_vkVoidFunction GetInstanceProcAddr(VkInstance instance, const char *pName)
{
    TKIT_ASSERT(Vulkan::vkGetInstanceProcAddr,
                "[VULKIT][LOADER] The function 'vkGetInstanceProcAddr' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return Vulkan::vkGetInstanceProcAddr(instance, pName);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
PFN_vkEnumerateInstanceVersion vkEnumerateInstanceVersion = VK_NULL_HANDLE;
VkResult EnumerateInstanceVersion(uint32_t *pApiVersion)
{
    TKIT_ASSERT(Vulkan::vkEnumerateInstanceVersion,
                "[VULKIT][LOADER] The function 'vkEnumerateInstanceVersion' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return Vulkan::vkEnumerateInstanceVersion(pApiVersion);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
PFN_vkEnumerateInstanceLayerProperties vkEnumerateInstanceLayerProperties = VK_NULL_HANDLE;
VkResult EnumerateInstanceLayerProperties(uint32_t *pPropertyCount, VkLayerProperties *pProperties)
{
    TKIT_ASSERT(Vulkan::vkEnumerateInstanceLayerProperties,
                "[VULKIT][LOADER] The function 'vkEnumerateInstanceLayerProperties' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return Vulkan::vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
PFN_vkEnumerateInstanceExtensionProperties vkEnumerateInstanceExtensionProperties = VK_NULL_HANDLE;
VkResult EnumerateInstanceExtensionProperties(const char *pLayerName, uint32_t *pPropertyCount,
                                              VkExtensionProperties *pProperties)
{
    TKIT_ASSERT(Vulkan::vkEnumerateInstanceExtensionProperties,
                "[VULKIT][LOADER] The function 'vkEnumerateInstanceExtensionProperties' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return Vulkan::vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties);
}
#endif

InstanceTable InstanceTable::Create(const VkInstance instance)
{
    InstanceTable table{};
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyInstance =
        reinterpret_cast<PFN_vkDestroyInstance>(GetInstanceProcAddr(instance, "vkDestroyInstance"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkEnumeratePhysicalDevices =
        reinterpret_cast<PFN_vkEnumeratePhysicalDevices>(GetInstanceProcAddr(instance, "vkEnumeratePhysicalDevices"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetDeviceProcAddr =
        reinterpret_cast<PFN_vkGetDeviceProcAddr>(GetInstanceProcAddr(instance, "vkGetDeviceProcAddr"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetPhysicalDeviceProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceProperties>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetPhysicalDeviceQueueFamilyProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceQueueFamilyProperties>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetPhysicalDeviceMemoryProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceMemoryProperties>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetPhysicalDeviceFeatures =
        reinterpret_cast<PFN_vkGetPhysicalDeviceFeatures>(GetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetPhysicalDeviceFormatProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceFormatProperties>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetPhysicalDeviceImageFormatProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceImageFormatProperties>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateDevice = reinterpret_cast<PFN_vkCreateDevice>(GetInstanceProcAddr(instance, "vkCreateDevice"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkEnumerateDeviceLayerProperties = reinterpret_cast<PFN_vkEnumerateDeviceLayerProperties>(
        GetInstanceProcAddr(instance, "vkEnumerateDeviceLayerProperties"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkEnumerateDeviceExtensionProperties = reinterpret_cast<PFN_vkEnumerateDeviceExtensionProperties>(
        GetInstanceProcAddr(instance, "vkEnumerateDeviceExtensionProperties"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetPhysicalDeviceSparseImageFormatProperties =
        reinterpret_cast<PFN_vkGetPhysicalDeviceSparseImageFormatProperties>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties"));
#endif
#if defined(VK_KHR_android_surface)
    table.vkCreateAndroidSurfaceKHR =
        reinterpret_cast<PFN_vkCreateAndroidSurfaceKHR>(GetInstanceProcAddr(instance, "vkCreateAndroidSurfaceKHR"));
#endif
#if defined(VK_OHOS_surface)
    table.vkCreateSurfaceOHOS =
        reinterpret_cast<PFN_vkCreateSurfaceOHOS>(GetInstanceProcAddr(instance, "vkCreateSurfaceOHOS"));
#endif
#if defined(VK_KHR_display)
    table.vkGetPhysicalDeviceDisplayPropertiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayPropertiesKHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR"));
#endif
#if defined(VK_KHR_display)
    table.vkGetPhysicalDeviceDisplayPlanePropertiesKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR"));
#endif
#if defined(VK_KHR_display)
    table.vkGetDisplayPlaneSupportedDisplaysKHR = reinterpret_cast<PFN_vkGetDisplayPlaneSupportedDisplaysKHR>(
        GetInstanceProcAddr(instance, "vkGetDisplayPlaneSupportedDisplaysKHR"));
#endif
#if defined(VK_KHR_display)
    table.vkGetDisplayModePropertiesKHR = reinterpret_cast<PFN_vkGetDisplayModePropertiesKHR>(
        GetInstanceProcAddr(instance, "vkGetDisplayModePropertiesKHR"));
#endif
#if defined(VK_KHR_display)
    table.vkCreateDisplayModeKHR =
        reinterpret_cast<PFN_vkCreateDisplayModeKHR>(GetInstanceProcAddr(instance, "vkCreateDisplayModeKHR"));
#endif
#if defined(VK_KHR_display)
    table.vkGetDisplayPlaneCapabilitiesKHR = reinterpret_cast<PFN_vkGetDisplayPlaneCapabilitiesKHR>(
        GetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilitiesKHR"));
#endif
#if defined(VK_KHR_display)
    table.vkCreateDisplayPlaneSurfaceKHR = reinterpret_cast<PFN_vkCreateDisplayPlaneSurfaceKHR>(
        GetInstanceProcAddr(instance, "vkCreateDisplayPlaneSurfaceKHR"));
#endif
#if defined(VK_KHR_surface)
    table.vkDestroySurfaceKHR =
        reinterpret_cast<PFN_vkDestroySurfaceKHR>(GetInstanceProcAddr(instance, "vkDestroySurfaceKHR"));
#endif
#if defined(VK_KHR_surface)
    table.vkGetPhysicalDeviceSurfaceSupportKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfaceSupportKHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceSupportKHR"));
#endif
#if defined(VK_KHR_surface)
    table.vkGetPhysicalDeviceSurfaceCapabilitiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR"));
#endif
#if defined(VK_KHR_surface)
    table.vkGetPhysicalDeviceSurfaceFormatsKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfaceFormatsKHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceFormatsKHR"));
#endif
#if defined(VK_KHR_surface)
    table.vkGetPhysicalDeviceSurfacePresentModesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfacePresentModesKHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModesKHR"));
#endif
#if defined(VK_NN_vi_surface)
    table.vkCreateViSurfaceNN =
        reinterpret_cast<PFN_vkCreateViSurfaceNN>(GetInstanceProcAddr(instance, "vkCreateViSurfaceNN"));
#endif
#if defined(VK_KHR_wayland_surface)
    table.vkCreateWaylandSurfaceKHR =
        reinterpret_cast<PFN_vkCreateWaylandSurfaceKHR>(GetInstanceProcAddr(instance, "vkCreateWaylandSurfaceKHR"));
#endif
#if defined(VK_KHR_wayland_surface)
    table.vkGetPhysicalDeviceWaylandPresentationSupportKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceWaylandPresentationSupportKHR"));
#endif
#if defined(VK_KHR_win32_surface)
    table.vkCreateWin32SurfaceKHR =
        reinterpret_cast<PFN_vkCreateWin32SurfaceKHR>(GetInstanceProcAddr(instance, "vkCreateWin32SurfaceKHR"));
#endif
#if defined(VK_KHR_win32_surface)
    table.vkGetPhysicalDeviceWin32PresentationSupportKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceWin32PresentationSupportKHR"));
#endif
#if defined(VK_KHR_xlib_surface)
    table.vkCreateXlibSurfaceKHR =
        reinterpret_cast<PFN_vkCreateXlibSurfaceKHR>(GetInstanceProcAddr(instance, "vkCreateXlibSurfaceKHR"));
#endif
#if defined(VK_KHR_xlib_surface)
    table.vkGetPhysicalDeviceXlibPresentationSupportKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceXlibPresentationSupportKHR"));
#endif
#if defined(VK_KHR_xcb_surface)
    table.vkCreateXcbSurfaceKHR =
        reinterpret_cast<PFN_vkCreateXcbSurfaceKHR>(GetInstanceProcAddr(instance, "vkCreateXcbSurfaceKHR"));
#endif
#if defined(VK_KHR_xcb_surface)
    table.vkGetPhysicalDeviceXcbPresentationSupportKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceXcbPresentationSupportKHR"));
#endif
#if defined(VK_EXT_directfb_surface)
    table.vkCreateDirectFBSurfaceEXT =
        reinterpret_cast<PFN_vkCreateDirectFBSurfaceEXT>(GetInstanceProcAddr(instance, "vkCreateDirectFBSurfaceEXT"));
#endif
#if defined(VK_EXT_directfb_surface)
    table.vkGetPhysicalDeviceDirectFBPresentationSupportEXT =
        reinterpret_cast<PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT"));
#endif
#if defined(VK_FUCHSIA_imagepipe_surface)
    table.vkCreateImagePipeSurfaceFUCHSIA = reinterpret_cast<PFN_vkCreateImagePipeSurfaceFUCHSIA>(
        GetInstanceProcAddr(instance, "vkCreateImagePipeSurfaceFUCHSIA"));
#endif
#if defined(VK_GGP_stream_descriptor_surface)
    table.vkCreateStreamDescriptorSurfaceGGP = reinterpret_cast<PFN_vkCreateStreamDescriptorSurfaceGGP>(
        GetInstanceProcAddr(instance, "vkCreateStreamDescriptorSurfaceGGP"));
#endif
#if defined(VK_QNX_screen_surface)
    table.vkCreateScreenSurfaceQNX =
        reinterpret_cast<PFN_vkCreateScreenSurfaceQNX>(GetInstanceProcAddr(instance, "vkCreateScreenSurfaceQNX"));
#endif
#if defined(VK_QNX_screen_surface)
    table.vkGetPhysicalDeviceScreenPresentationSupportQNX =
        reinterpret_cast<PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceScreenPresentationSupportQNX"));
#endif
#if defined(VK_EXT_debug_report)
    table.vkCreateDebugReportCallbackEXT = reinterpret_cast<PFN_vkCreateDebugReportCallbackEXT>(
        GetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT"));
#endif
#if defined(VK_EXT_debug_report)
    table.vkDestroyDebugReportCallbackEXT = reinterpret_cast<PFN_vkDestroyDebugReportCallbackEXT>(
        GetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT"));
#endif
#if defined(VK_EXT_debug_report)
    table.vkDebugReportMessageEXT =
        reinterpret_cast<PFN_vkDebugReportMessageEXT>(GetInstanceProcAddr(instance, "vkDebugReportMessageEXT"));
#endif
#if defined(VK_NV_external_memory_capabilities)
    table.vkGetPhysicalDeviceExternalImageFormatPropertiesNV =
        reinterpret_cast<PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceFeatures2 = reinterpret_cast<PFN_vkGetPhysicalDeviceFeatures2>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceProperties2>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceFormatProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceFormatProperties2>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceImageFormatProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceImageFormatProperties2>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceQueueFamilyProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceQueueFamilyProperties2>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceMemoryProperties2 = reinterpret_cast<PFN_vkGetPhysicalDeviceMemoryProperties2>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceSparseImageFormatProperties2 =
        reinterpret_cast<PFN_vkGetPhysicalDeviceSparseImageFormatProperties2>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceExternalBufferProperties =
        reinterpret_cast<PFN_vkGetPhysicalDeviceExternalBufferProperties>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferProperties"));
#endif
#if defined(VK_NV_external_memory_sci_buf)
    table.vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV =
        reinterpret_cast<PFN_vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV"));
#endif
#if defined(VK_NV_external_memory_sci_buf)
    table.vkGetPhysicalDeviceSciBufAttributesNV = reinterpret_cast<PFN_vkGetPhysicalDeviceSciBufAttributesNV>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSciBufAttributesNV"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceExternalSemaphoreProperties =
        reinterpret_cast<PFN_vkGetPhysicalDeviceExternalSemaphoreProperties>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphoreProperties"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetPhysicalDeviceExternalFenceProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceExternalFenceProperties>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalFenceProperties"));
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
    table.vkGetPhysicalDeviceSciSyncAttributesNV = reinterpret_cast<PFN_vkGetPhysicalDeviceSciSyncAttributesNV>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSciSyncAttributesNV"));
#endif
#if defined(VK_EXT_direct_mode_display)
    table.vkReleaseDisplayEXT =
        reinterpret_cast<PFN_vkReleaseDisplayEXT>(GetInstanceProcAddr(instance, "vkReleaseDisplayEXT"));
#endif
#if defined(VK_EXT_acquire_xlib_display)
    table.vkAcquireXlibDisplayEXT =
        reinterpret_cast<PFN_vkAcquireXlibDisplayEXT>(GetInstanceProcAddr(instance, "vkAcquireXlibDisplayEXT"));
#endif
#if defined(VK_EXT_acquire_xlib_display)
    table.vkGetRandROutputDisplayEXT =
        reinterpret_cast<PFN_vkGetRandROutputDisplayEXT>(GetInstanceProcAddr(instance, "vkGetRandROutputDisplayEXT"));
#endif
#if defined(VK_NV_acquire_winrt_display)
    table.vkAcquireWinrtDisplayNV =
        reinterpret_cast<PFN_vkAcquireWinrtDisplayNV>(GetInstanceProcAddr(instance, "vkAcquireWinrtDisplayNV"));
#endif
#if defined(VK_NV_acquire_winrt_display)
    table.vkGetWinrtDisplayNV =
        reinterpret_cast<PFN_vkGetWinrtDisplayNV>(GetInstanceProcAddr(instance, "vkGetWinrtDisplayNV"));
#endif
#if defined(VK_EXT_display_surface_counter)
    table.vkGetPhysicalDeviceSurfaceCapabilities2EXT = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkEnumeratePhysicalDeviceGroups = reinterpret_cast<PFN_vkEnumeratePhysicalDeviceGroups>(
        GetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroups"));
#endif
#if (defined(VK_KHR_swapchain) && defined(VKIT_API_VERSION_1_1)) ||                                                    \
    (defined(VK_KHR_device_group) && defined(VK_KHR_surface))
    table.vkGetPhysicalDevicePresentRectanglesKHR = reinterpret_cast<PFN_vkGetPhysicalDevicePresentRectanglesKHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDevicePresentRectanglesKHR"));
#endif
#if defined(VK_MVK_ios_surface)
    table.vkCreateIOSSurfaceMVK =
        reinterpret_cast<PFN_vkCreateIOSSurfaceMVK>(GetInstanceProcAddr(instance, "vkCreateIOSSurfaceMVK"));
#endif
#if defined(VK_MVK_macos_surface)
    table.vkCreateMacOSSurfaceMVK =
        reinterpret_cast<PFN_vkCreateMacOSSurfaceMVK>(GetInstanceProcAddr(instance, "vkCreateMacOSSurfaceMVK"));
#endif
#if defined(VK_EXT_metal_surface)
    table.vkCreateMetalSurfaceEXT =
        reinterpret_cast<PFN_vkCreateMetalSurfaceEXT>(GetInstanceProcAddr(instance, "vkCreateMetalSurfaceEXT"));
#endif
#if defined(VK_EXT_sample_locations)
    table.vkGetPhysicalDeviceMultisamplePropertiesEXT =
        reinterpret_cast<PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceMultisamplePropertiesEXT"));
#endif
#if defined(VK_KHR_get_surface_capabilities2)
    table.vkGetPhysicalDeviceSurfaceCapabilities2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR"));
#endif
#if defined(VK_KHR_get_surface_capabilities2)
    table.vkGetPhysicalDeviceSurfaceFormats2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfaceFormats2KHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceFormats2KHR"));
#endif
#if defined(VK_KHR_get_display_properties2)
    table.vkGetPhysicalDeviceDisplayProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayProperties2KHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayProperties2KHR"));
#endif
#if defined(VK_KHR_get_display_properties2)
    table.vkGetPhysicalDeviceDisplayPlaneProperties2KHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR"));
#endif
#if defined(VK_KHR_get_display_properties2)
    table.vkGetDisplayModeProperties2KHR = reinterpret_cast<PFN_vkGetDisplayModeProperties2KHR>(
        GetInstanceProcAddr(instance, "vkGetDisplayModeProperties2KHR"));
#endif
#if defined(VK_KHR_get_display_properties2)
    table.vkGetDisplayPlaneCapabilities2KHR = reinterpret_cast<PFN_vkGetDisplayPlaneCapabilities2KHR>(
        GetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilities2KHR"));
#endif
#if defined(VK_KHR_calibrated_timestamps)
    table.vkGetPhysicalDeviceCalibrateableTimeDomainsKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkCreateDebugUtilsMessengerEXT = reinterpret_cast<PFN_vkCreateDebugUtilsMessengerEXT>(
        GetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkDestroyDebugUtilsMessengerEXT = reinterpret_cast<PFN_vkDestroyDebugUtilsMessengerEXT>(
        GetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkSubmitDebugUtilsMessageEXT = reinterpret_cast<PFN_vkSubmitDebugUtilsMessageEXT>(
        GetInstanceProcAddr(instance, "vkSubmitDebugUtilsMessageEXT"));
#endif
#if defined(VK_NV_cooperative_matrix)
    table.vkGetPhysicalDeviceCooperativeMatrixPropertiesNV =
        reinterpret_cast<PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV"));
#endif
#if defined(VK_EXT_full_screen_exclusive)
    table.vkGetPhysicalDeviceSurfacePresentModes2EXT = reinterpret_cast<PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModes2EXT"));
#endif
#if defined(VK_KHR_performance_query)
    table.vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR =
        reinterpret_cast<PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR>(
            GetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR"));
#endif
#if defined(VK_KHR_performance_query)
    table.vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR"));
#endif
#if defined(VK_EXT_headless_surface)
    table.vkCreateHeadlessSurfaceEXT =
        reinterpret_cast<PFN_vkCreateHeadlessSurfaceEXT>(GetInstanceProcAddr(instance, "vkCreateHeadlessSurfaceEXT"));
#endif
#if defined(VK_NV_coverage_reduction_mode)
    table.vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV =
        reinterpret_cast<PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkGetPhysicalDeviceToolProperties = reinterpret_cast<PFN_vkGetPhysicalDeviceToolProperties>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceToolProperties"));
#endif
#if defined(VK_KHR_object_refresh)
    table.vkGetPhysicalDeviceRefreshableObjectTypesKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceRefreshableObjectTypesKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceRefreshableObjectTypesKHR"));
#endif
#if defined(VK_KHR_fragment_shading_rate)
    table.vkGetPhysicalDeviceFragmentShadingRatesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceFragmentShadingRatesKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkGetPhysicalDeviceVideoCapabilitiesKHR = reinterpret_cast<PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceVideoCapabilitiesKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkGetPhysicalDeviceVideoFormatPropertiesKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceVideoFormatPropertiesKHR"));
#endif
#if defined(VK_KHR_video_encode_queue)
    table.vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR"));
#endif
#if defined(VK_EXT_acquire_drm_display)
    table.vkAcquireDrmDisplayEXT =
        reinterpret_cast<PFN_vkAcquireDrmDisplayEXT>(GetInstanceProcAddr(instance, "vkAcquireDrmDisplayEXT"));
#endif
#if defined(VK_EXT_acquire_drm_display)
    table.vkGetDrmDisplayEXT =
        reinterpret_cast<PFN_vkGetDrmDisplayEXT>(GetInstanceProcAddr(instance, "vkGetDrmDisplayEXT"));
#endif
#if defined(VK_NV_optical_flow)
    table.vkGetPhysicalDeviceOpticalFlowImageFormatsNV =
        reinterpret_cast<PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV"));
#endif
#if defined(VK_KHR_cooperative_matrix)
    table.vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR"));
#endif
#if defined(VK_NV_cooperative_matrix2)
    table.vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV =
        reinterpret_cast<PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV"));
#endif
#if defined(VK_NV_cooperative_vector)
    table.vkGetPhysicalDeviceCooperativeVectorPropertiesNV =
        reinterpret_cast<PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceCooperativeVectorPropertiesNV"));
#endif
#if defined(VK_ARM_tensors)
    table.vkGetPhysicalDeviceExternalTensorPropertiesARM =
        reinterpret_cast<PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalTensorPropertiesARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM =
        reinterpret_cast<PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM =
        reinterpret_cast<PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM"));
#endif
#if defined(VK_KHR_get_physical_device_properties2)
    table.vkGetPhysicalDeviceFeatures2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceFeatures2KHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures2KHR"));
#endif
#if defined(VK_KHR_get_physical_device_properties2)
    table.vkGetPhysicalDeviceProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceProperties2KHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2KHR"));
#endif
#if defined(VK_KHR_get_physical_device_properties2)
    table.vkGetPhysicalDeviceFormatProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceFormatProperties2KHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2KHR"));
#endif
#if defined(VK_KHR_get_physical_device_properties2)
    table.vkGetPhysicalDeviceImageFormatProperties2KHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceImageFormatProperties2KHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2KHR"));
#endif
#if defined(VK_KHR_get_physical_device_properties2)
    table.vkGetPhysicalDeviceQueueFamilyProperties2KHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2KHR"));
#endif
#if defined(VK_KHR_get_physical_device_properties2)
    table.vkGetPhysicalDeviceMemoryProperties2KHR = reinterpret_cast<PFN_vkGetPhysicalDeviceMemoryProperties2KHR>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2KHR"));
#endif
#if defined(VK_KHR_get_physical_device_properties2)
    table.vkGetPhysicalDeviceSparseImageFormatProperties2KHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR"));
#endif
#if defined(VK_KHR_external_memory_capabilities)
    table.vkGetPhysicalDeviceExternalBufferPropertiesKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR"));
#endif
#if defined(VK_KHR_external_semaphore_capabilities)
    table.vkGetPhysicalDeviceExternalSemaphorePropertiesKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR"));
#endif
#if defined(VK_KHR_external_fence_capabilities)
    table.vkGetPhysicalDeviceExternalFencePropertiesKHR =
        reinterpret_cast<PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalFencePropertiesKHR"));
#endif
#if defined(VK_KHR_device_group_creation)
    table.vkEnumeratePhysicalDeviceGroupsKHR = reinterpret_cast<PFN_vkEnumeratePhysicalDeviceGroupsKHR>(
        GetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroupsKHR"));
#endif
#if defined(VK_EXT_calibrated_timestamps)
    table.vkGetPhysicalDeviceCalibrateableTimeDomainsEXT =
        reinterpret_cast<PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT>(
            GetInstanceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT"));
#endif
#if defined(VK_EXT_tooling_info)
    table.vkGetPhysicalDeviceToolPropertiesEXT = reinterpret_cast<PFN_vkGetPhysicalDeviceToolPropertiesEXT>(
        GetInstanceProcAddr(instance, "vkGetPhysicalDeviceToolPropertiesEXT"));
#endif
    return table;
}

DeviceTable DeviceTable::Create(const VkDevice device, const InstanceTable &instanceFuncs)
{
    DeviceTable table{};
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyDevice =
        reinterpret_cast<PFN_vkDestroyDevice>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyDevice"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetDeviceQueue =
        reinterpret_cast<PFN_vkGetDeviceQueue>(instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceQueue"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkQueueSubmit = reinterpret_cast<PFN_vkQueueSubmit>(instanceFuncs.GetDeviceProcAddr(device, "vkQueueSubmit"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkQueueWaitIdle =
        reinterpret_cast<PFN_vkQueueWaitIdle>(instanceFuncs.GetDeviceProcAddr(device, "vkQueueWaitIdle"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDeviceWaitIdle =
        reinterpret_cast<PFN_vkDeviceWaitIdle>(instanceFuncs.GetDeviceProcAddr(device, "vkDeviceWaitIdle"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkAllocateMemory =
        reinterpret_cast<PFN_vkAllocateMemory>(instanceFuncs.GetDeviceProcAddr(device, "vkAllocateMemory"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkFreeMemory = reinterpret_cast<PFN_vkFreeMemory>(instanceFuncs.GetDeviceProcAddr(device, "vkFreeMemory"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkMapMemory = reinterpret_cast<PFN_vkMapMemory>(instanceFuncs.GetDeviceProcAddr(device, "vkMapMemory"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkUnmapMemory = reinterpret_cast<PFN_vkUnmapMemory>(instanceFuncs.GetDeviceProcAddr(device, "vkUnmapMemory"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkFlushMappedMemoryRanges = reinterpret_cast<PFN_vkFlushMappedMemoryRanges>(
        instanceFuncs.GetDeviceProcAddr(device, "vkFlushMappedMemoryRanges"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkInvalidateMappedMemoryRanges = reinterpret_cast<PFN_vkInvalidateMappedMemoryRanges>(
        instanceFuncs.GetDeviceProcAddr(device, "vkInvalidateMappedMemoryRanges"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetDeviceMemoryCommitment = reinterpret_cast<PFN_vkGetDeviceMemoryCommitment>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceMemoryCommitment"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetBufferMemoryRequirements = reinterpret_cast<PFN_vkGetBufferMemoryRequirements>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferMemoryRequirements"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkBindBufferMemory =
        reinterpret_cast<PFN_vkBindBufferMemory>(instanceFuncs.GetDeviceProcAddr(device, "vkBindBufferMemory"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetImageMemoryRequirements = reinterpret_cast<PFN_vkGetImageMemoryRequirements>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageMemoryRequirements"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkBindImageMemory =
        reinterpret_cast<PFN_vkBindImageMemory>(instanceFuncs.GetDeviceProcAddr(device, "vkBindImageMemory"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetImageSparseMemoryRequirements = reinterpret_cast<PFN_vkGetImageSparseMemoryRequirements>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkQueueBindSparse =
        reinterpret_cast<PFN_vkQueueBindSparse>(instanceFuncs.GetDeviceProcAddr(device, "vkQueueBindSparse"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateFence = reinterpret_cast<PFN_vkCreateFence>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateFence"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyFence =
        reinterpret_cast<PFN_vkDestroyFence>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyFence"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkResetFences = reinterpret_cast<PFN_vkResetFences>(instanceFuncs.GetDeviceProcAddr(device, "vkResetFences"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetFenceStatus =
        reinterpret_cast<PFN_vkGetFenceStatus>(instanceFuncs.GetDeviceProcAddr(device, "vkGetFenceStatus"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkWaitForFences =
        reinterpret_cast<PFN_vkWaitForFences>(instanceFuncs.GetDeviceProcAddr(device, "vkWaitForFences"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateSemaphore =
        reinterpret_cast<PFN_vkCreateSemaphore>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateSemaphore"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroySemaphore =
        reinterpret_cast<PFN_vkDestroySemaphore>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroySemaphore"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateEvent = reinterpret_cast<PFN_vkCreateEvent>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateEvent"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyEvent =
        reinterpret_cast<PFN_vkDestroyEvent>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyEvent"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetEventStatus =
        reinterpret_cast<PFN_vkGetEventStatus>(instanceFuncs.GetDeviceProcAddr(device, "vkGetEventStatus"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkSetEvent = reinterpret_cast<PFN_vkSetEvent>(instanceFuncs.GetDeviceProcAddr(device, "vkSetEvent"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkResetEvent = reinterpret_cast<PFN_vkResetEvent>(instanceFuncs.GetDeviceProcAddr(device, "vkResetEvent"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateQueryPool =
        reinterpret_cast<PFN_vkCreateQueryPool>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateQueryPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyQueryPool =
        reinterpret_cast<PFN_vkDestroyQueryPool>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyQueryPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetQueryPoolResults =
        reinterpret_cast<PFN_vkGetQueryPoolResults>(instanceFuncs.GetDeviceProcAddr(device, "vkGetQueryPoolResults"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkResetQueryPool =
        reinterpret_cast<PFN_vkResetQueryPool>(instanceFuncs.GetDeviceProcAddr(device, "vkResetQueryPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateBuffer =
        reinterpret_cast<PFN_vkCreateBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateBuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyBuffer =
        reinterpret_cast<PFN_vkDestroyBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyBuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateBufferView =
        reinterpret_cast<PFN_vkCreateBufferView>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateBufferView"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyBufferView =
        reinterpret_cast<PFN_vkDestroyBufferView>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyBufferView"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateImage = reinterpret_cast<PFN_vkCreateImage>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateImage"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyImage =
        reinterpret_cast<PFN_vkDestroyImage>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyImage"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetImageSubresourceLayout = reinterpret_cast<PFN_vkGetImageSubresourceLayout>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageSubresourceLayout"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateImageView =
        reinterpret_cast<PFN_vkCreateImageView>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateImageView"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyImageView =
        reinterpret_cast<PFN_vkDestroyImageView>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyImageView"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateShaderModule =
        reinterpret_cast<PFN_vkCreateShaderModule>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateShaderModule"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyShaderModule =
        reinterpret_cast<PFN_vkDestroyShaderModule>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyShaderModule"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreatePipelineCache =
        reinterpret_cast<PFN_vkCreatePipelineCache>(instanceFuncs.GetDeviceProcAddr(device, "vkCreatePipelineCache"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyPipelineCache =
        reinterpret_cast<PFN_vkDestroyPipelineCache>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyPipelineCache"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetPipelineCacheData =
        reinterpret_cast<PFN_vkGetPipelineCacheData>(instanceFuncs.GetDeviceProcAddr(device, "vkGetPipelineCacheData"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkMergePipelineCaches =
        reinterpret_cast<PFN_vkMergePipelineCaches>(instanceFuncs.GetDeviceProcAddr(device, "vkMergePipelineCaches"));
#endif
#if defined(VK_KHR_pipeline_binary)
    table.vkCreatePipelineBinariesKHR = reinterpret_cast<PFN_vkCreatePipelineBinariesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreatePipelineBinariesKHR"));
#endif
#if defined(VK_KHR_pipeline_binary)
    table.vkDestroyPipelineBinaryKHR = reinterpret_cast<PFN_vkDestroyPipelineBinaryKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyPipelineBinaryKHR"));
#endif
#if defined(VK_KHR_pipeline_binary)
    table.vkGetPipelineKeyKHR =
        reinterpret_cast<PFN_vkGetPipelineKeyKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkGetPipelineKeyKHR"));
#endif
#if defined(VK_KHR_pipeline_binary)
    table.vkGetPipelineBinaryDataKHR = reinterpret_cast<PFN_vkGetPipelineBinaryDataKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetPipelineBinaryDataKHR"));
#endif
#if defined(VK_KHR_pipeline_binary)
    table.vkReleaseCapturedPipelineDataKHR = reinterpret_cast<PFN_vkReleaseCapturedPipelineDataKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkReleaseCapturedPipelineDataKHR"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateGraphicsPipelines = reinterpret_cast<PFN_vkCreateGraphicsPipelines>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateGraphicsPipelines"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateComputePipelines = reinterpret_cast<PFN_vkCreateComputePipelines>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateComputePipelines"));
#endif
#if (defined(VK_HUAWEI_subpass_shading) && VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION >= 2)
    table.vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI =
        reinterpret_cast<PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyPipeline =
        reinterpret_cast<PFN_vkDestroyPipeline>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyPipeline"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreatePipelineLayout =
        reinterpret_cast<PFN_vkCreatePipelineLayout>(instanceFuncs.GetDeviceProcAddr(device, "vkCreatePipelineLayout"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyPipelineLayout = reinterpret_cast<PFN_vkDestroyPipelineLayout>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyPipelineLayout"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateSampler =
        reinterpret_cast<PFN_vkCreateSampler>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateSampler"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroySampler =
        reinterpret_cast<PFN_vkDestroySampler>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroySampler"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateDescriptorSetLayout = reinterpret_cast<PFN_vkCreateDescriptorSetLayout>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateDescriptorSetLayout"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyDescriptorSetLayout = reinterpret_cast<PFN_vkDestroyDescriptorSetLayout>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyDescriptorSetLayout"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateDescriptorPool =
        reinterpret_cast<PFN_vkCreateDescriptorPool>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateDescriptorPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyDescriptorPool = reinterpret_cast<PFN_vkDestroyDescriptorPool>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyDescriptorPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkResetDescriptorPool =
        reinterpret_cast<PFN_vkResetDescriptorPool>(instanceFuncs.GetDeviceProcAddr(device, "vkResetDescriptorPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkAllocateDescriptorSets = reinterpret_cast<PFN_vkAllocateDescriptorSets>(
        instanceFuncs.GetDeviceProcAddr(device, "vkAllocateDescriptorSets"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkFreeDescriptorSets =
        reinterpret_cast<PFN_vkFreeDescriptorSets>(instanceFuncs.GetDeviceProcAddr(device, "vkFreeDescriptorSets"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkUpdateDescriptorSets =
        reinterpret_cast<PFN_vkUpdateDescriptorSets>(instanceFuncs.GetDeviceProcAddr(device, "vkUpdateDescriptorSets"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateFramebuffer =
        reinterpret_cast<PFN_vkCreateFramebuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateFramebuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyFramebuffer =
        reinterpret_cast<PFN_vkDestroyFramebuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyFramebuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateRenderPass =
        reinterpret_cast<PFN_vkCreateRenderPass>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateRenderPass"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyRenderPass =
        reinterpret_cast<PFN_vkDestroyRenderPass>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyRenderPass"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkGetRenderAreaGranularity = reinterpret_cast<PFN_vkGetRenderAreaGranularity>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetRenderAreaGranularity"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkGetRenderingAreaGranularity = reinterpret_cast<PFN_vkGetRenderingAreaGranularity>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetRenderingAreaGranularity"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCreateCommandPool =
        reinterpret_cast<PFN_vkCreateCommandPool>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateCommandPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkDestroyCommandPool =
        reinterpret_cast<PFN_vkDestroyCommandPool>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyCommandPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkResetCommandPool =
        reinterpret_cast<PFN_vkResetCommandPool>(instanceFuncs.GetDeviceProcAddr(device, "vkResetCommandPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkAllocateCommandBuffers = reinterpret_cast<PFN_vkAllocateCommandBuffers>(
        instanceFuncs.GetDeviceProcAddr(device, "vkAllocateCommandBuffers"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkFreeCommandBuffers =
        reinterpret_cast<PFN_vkFreeCommandBuffers>(instanceFuncs.GetDeviceProcAddr(device, "vkFreeCommandBuffers"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkBeginCommandBuffer =
        reinterpret_cast<PFN_vkBeginCommandBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkBeginCommandBuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkEndCommandBuffer =
        reinterpret_cast<PFN_vkEndCommandBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkEndCommandBuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkResetCommandBuffer =
        reinterpret_cast<PFN_vkResetCommandBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkResetCommandBuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdBindPipeline =
        reinterpret_cast<PFN_vkCmdBindPipeline>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindPipeline"));
#endif
#if defined(VK_EXT_attachment_feedback_loop_dynamic_state)
    table.vkCmdSetAttachmentFeedbackLoopEnableEXT = reinterpret_cast<PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetAttachmentFeedbackLoopEnableEXT"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetViewport =
        reinterpret_cast<PFN_vkCmdSetViewport>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetViewport"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetScissor =
        reinterpret_cast<PFN_vkCmdSetScissor>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetScissor"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetLineWidth =
        reinterpret_cast<PFN_vkCmdSetLineWidth>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetLineWidth"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetDepthBias =
        reinterpret_cast<PFN_vkCmdSetDepthBias>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthBias"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetBlendConstants =
        reinterpret_cast<PFN_vkCmdSetBlendConstants>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetBlendConstants"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetDepthBounds =
        reinterpret_cast<PFN_vkCmdSetDepthBounds>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthBounds"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetStencilCompareMask = reinterpret_cast<PFN_vkCmdSetStencilCompareMask>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetStencilCompareMask"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetStencilWriteMask = reinterpret_cast<PFN_vkCmdSetStencilWriteMask>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetStencilWriteMask"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetStencilReference = reinterpret_cast<PFN_vkCmdSetStencilReference>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetStencilReference"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdBindDescriptorSets = reinterpret_cast<PFN_vkCmdBindDescriptorSets>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindDescriptorSets"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdBindIndexBuffer =
        reinterpret_cast<PFN_vkCmdBindIndexBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindIndexBuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdBindVertexBuffers =
        reinterpret_cast<PFN_vkCmdBindVertexBuffers>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindVertexBuffers"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdDraw = reinterpret_cast<PFN_vkCmdDraw>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDraw"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdDrawIndexed =
        reinterpret_cast<PFN_vkCmdDrawIndexed>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndexed"));
#endif
#if defined(VK_EXT_multi_draw)
    table.vkCmdDrawMultiEXT =
        reinterpret_cast<PFN_vkCmdDrawMultiEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawMultiEXT"));
#endif
#if defined(VK_EXT_multi_draw)
    table.vkCmdDrawMultiIndexedEXT = reinterpret_cast<PFN_vkCmdDrawMultiIndexedEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawMultiIndexedEXT"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdDrawIndirect =
        reinterpret_cast<PFN_vkCmdDrawIndirect>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndirect"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdDrawIndexedIndirect = reinterpret_cast<PFN_vkCmdDrawIndexedIndirect>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndexedIndirect"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdDispatch = reinterpret_cast<PFN_vkCmdDispatch>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDispatch"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdDispatchIndirect =
        reinterpret_cast<PFN_vkCmdDispatchIndirect>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDispatchIndirect"));
#endif
#if (defined(VK_HUAWEI_subpass_shading) && VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION >= 2)
    table.vkCmdSubpassShadingHUAWEI = reinterpret_cast<PFN_vkCmdSubpassShadingHUAWEI>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSubpassShadingHUAWEI"));
#endif
#if defined(VK_HUAWEI_cluster_culling_shader)
    table.vkCmdDrawClusterHUAWEI =
        reinterpret_cast<PFN_vkCmdDrawClusterHUAWEI>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawClusterHUAWEI"));
#endif
#if defined(VK_HUAWEI_cluster_culling_shader)
    table.vkCmdDrawClusterIndirectHUAWEI = reinterpret_cast<PFN_vkCmdDrawClusterIndirectHUAWEI>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawClusterIndirectHUAWEI"));
#endif
#if defined(VK_NV_device_generated_commands_compute)
    table.vkCmdUpdatePipelineIndirectBufferNV = reinterpret_cast<PFN_vkCmdUpdatePipelineIndirectBufferNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdUpdatePipelineIndirectBufferNV"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdCopyBuffer =
        reinterpret_cast<PFN_vkCmdCopyBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyBuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdCopyImage =
        reinterpret_cast<PFN_vkCmdCopyImage>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyImage"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdBlitImage =
        reinterpret_cast<PFN_vkCmdBlitImage>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBlitImage"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdCopyBufferToImage =
        reinterpret_cast<PFN_vkCmdCopyBufferToImage>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyBufferToImage"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdCopyImageToBuffer =
        reinterpret_cast<PFN_vkCmdCopyImageToBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyImageToBuffer"));
#endif
#if defined(VK_NV_copy_memory_indirect)
    table.vkCmdCopyMemoryIndirectNV = reinterpret_cast<PFN_vkCmdCopyMemoryIndirectNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyMemoryIndirectNV"));
#endif
#if defined(VK_KHR_copy_memory_indirect)
    table.vkCmdCopyMemoryIndirectKHR = reinterpret_cast<PFN_vkCmdCopyMemoryIndirectKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyMemoryIndirectKHR"));
#endif
#if defined(VK_NV_copy_memory_indirect)
    table.vkCmdCopyMemoryToImageIndirectNV = reinterpret_cast<PFN_vkCmdCopyMemoryToImageIndirectNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyMemoryToImageIndirectNV"));
#endif
#if defined(VK_KHR_copy_memory_indirect)
    table.vkCmdCopyMemoryToImageIndirectKHR = reinterpret_cast<PFN_vkCmdCopyMemoryToImageIndirectKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyMemoryToImageIndirectKHR"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdUpdateBuffer =
        reinterpret_cast<PFN_vkCmdUpdateBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdUpdateBuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdFillBuffer =
        reinterpret_cast<PFN_vkCmdFillBuffer>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdFillBuffer"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdClearColorImage =
        reinterpret_cast<PFN_vkCmdClearColorImage>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdClearColorImage"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdClearDepthStencilImage = reinterpret_cast<PFN_vkCmdClearDepthStencilImage>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdClearDepthStencilImage"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdClearAttachments =
        reinterpret_cast<PFN_vkCmdClearAttachments>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdClearAttachments"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdResolveImage =
        reinterpret_cast<PFN_vkCmdResolveImage>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdResolveImage"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdSetEvent = reinterpret_cast<PFN_vkCmdSetEvent>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetEvent"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdResetEvent =
        reinterpret_cast<PFN_vkCmdResetEvent>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdResetEvent"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdWaitEvents =
        reinterpret_cast<PFN_vkCmdWaitEvents>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdWaitEvents"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdPipelineBarrier =
        reinterpret_cast<PFN_vkCmdPipelineBarrier>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdPipelineBarrier"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdBeginQuery =
        reinterpret_cast<PFN_vkCmdBeginQuery>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginQuery"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdEndQuery = reinterpret_cast<PFN_vkCmdEndQuery>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndQuery"));
#endif
#if defined(VK_EXT_conditional_rendering)
    table.vkCmdBeginConditionalRenderingEXT = reinterpret_cast<PFN_vkCmdBeginConditionalRenderingEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginConditionalRenderingEXT"));
#endif
#if defined(VK_EXT_conditional_rendering)
    table.vkCmdEndConditionalRenderingEXT = reinterpret_cast<PFN_vkCmdEndConditionalRenderingEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndConditionalRenderingEXT"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdResetQueryPool =
        reinterpret_cast<PFN_vkCmdResetQueryPool>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdResetQueryPool"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdWriteTimestamp =
        reinterpret_cast<PFN_vkCmdWriteTimestamp>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdWriteTimestamp"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdCopyQueryPoolResults = reinterpret_cast<PFN_vkCmdCopyQueryPoolResults>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyQueryPoolResults"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdPushConstants =
        reinterpret_cast<PFN_vkCmdPushConstants>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushConstants"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdBeginRenderPass =
        reinterpret_cast<PFN_vkCmdBeginRenderPass>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginRenderPass"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdNextSubpass =
        reinterpret_cast<PFN_vkCmdNextSubpass>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdNextSubpass"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdEndRenderPass =
        reinterpret_cast<PFN_vkCmdEndRenderPass>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndRenderPass"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    table.vkCmdExecuteCommands =
        reinterpret_cast<PFN_vkCmdExecuteCommands>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdExecuteCommands"));
#endif
#if defined(VK_KHR_display_swapchain)
    table.vkCreateSharedSwapchainsKHR = reinterpret_cast<PFN_vkCreateSharedSwapchainsKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateSharedSwapchainsKHR"));
#endif
#if defined(VK_KHR_swapchain)
    table.vkCreateSwapchainKHR =
        reinterpret_cast<PFN_vkCreateSwapchainKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateSwapchainKHR"));
#endif
#if defined(VK_KHR_swapchain)
    table.vkDestroySwapchainKHR =
        reinterpret_cast<PFN_vkDestroySwapchainKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroySwapchainKHR"));
#endif
#if defined(VK_KHR_swapchain)
    table.vkGetSwapchainImagesKHR = reinterpret_cast<PFN_vkGetSwapchainImagesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSwapchainImagesKHR"));
#endif
#if defined(VK_KHR_swapchain)
    table.vkAcquireNextImageKHR =
        reinterpret_cast<PFN_vkAcquireNextImageKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkAcquireNextImageKHR"));
#endif
#if defined(VK_KHR_swapchain)
    table.vkQueuePresentKHR =
        reinterpret_cast<PFN_vkQueuePresentKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkQueuePresentKHR"));
#endif
#if defined(VK_EXT_debug_marker)
    table.vkDebugMarkerSetObjectNameEXT = reinterpret_cast<PFN_vkDebugMarkerSetObjectNameEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDebugMarkerSetObjectNameEXT"));
#endif
#if defined(VK_EXT_debug_marker)
    table.vkDebugMarkerSetObjectTagEXT = reinterpret_cast<PFN_vkDebugMarkerSetObjectTagEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDebugMarkerSetObjectTagEXT"));
#endif
#if defined(VK_EXT_debug_marker)
    table.vkCmdDebugMarkerBeginEXT = reinterpret_cast<PFN_vkCmdDebugMarkerBeginEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDebugMarkerBeginEXT"));
#endif
#if defined(VK_EXT_debug_marker)
    table.vkCmdDebugMarkerEndEXT =
        reinterpret_cast<PFN_vkCmdDebugMarkerEndEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDebugMarkerEndEXT"));
#endif
#if defined(VK_EXT_debug_marker)
    table.vkCmdDebugMarkerInsertEXT = reinterpret_cast<PFN_vkCmdDebugMarkerInsertEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDebugMarkerInsertEXT"));
#endif
#if defined(VK_NV_external_memory_win32)
    table.vkGetMemoryWin32HandleNV = reinterpret_cast<PFN_vkGetMemoryWin32HandleNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryWin32HandleNV"));
#endif
#if defined(VK_NV_device_generated_commands)
    table.vkCmdExecuteGeneratedCommandsNV = reinterpret_cast<PFN_vkCmdExecuteGeneratedCommandsNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdExecuteGeneratedCommandsNV"));
#endif
#if defined(VK_NV_device_generated_commands)
    table.vkCmdPreprocessGeneratedCommandsNV = reinterpret_cast<PFN_vkCmdPreprocessGeneratedCommandsNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPreprocessGeneratedCommandsNV"));
#endif
#if defined(VK_NV_device_generated_commands)
    table.vkCmdBindPipelineShaderGroupNV = reinterpret_cast<PFN_vkCmdBindPipelineShaderGroupNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindPipelineShaderGroupNV"));
#endif
#if defined(VK_NV_device_generated_commands)
    table.vkGetGeneratedCommandsMemoryRequirementsNV = reinterpret_cast<PFN_vkGetGeneratedCommandsMemoryRequirementsNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetGeneratedCommandsMemoryRequirementsNV"));
#endif
#if defined(VK_NV_device_generated_commands)
    table.vkCreateIndirectCommandsLayoutNV = reinterpret_cast<PFN_vkCreateIndirectCommandsLayoutNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateIndirectCommandsLayoutNV"));
#endif
#if defined(VK_NV_device_generated_commands)
    table.vkDestroyIndirectCommandsLayoutNV = reinterpret_cast<PFN_vkDestroyIndirectCommandsLayoutNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyIndirectCommandsLayoutNV"));
#endif
#if defined(VK_EXT_device_generated_commands)
    table.vkCmdExecuteGeneratedCommandsEXT = reinterpret_cast<PFN_vkCmdExecuteGeneratedCommandsEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdExecuteGeneratedCommandsEXT"));
#endif
#if defined(VK_EXT_device_generated_commands)
    table.vkCmdPreprocessGeneratedCommandsEXT = reinterpret_cast<PFN_vkCmdPreprocessGeneratedCommandsEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPreprocessGeneratedCommandsEXT"));
#endif
#if defined(VK_EXT_device_generated_commands)
    table.vkGetGeneratedCommandsMemoryRequirementsEXT =
        reinterpret_cast<PFN_vkGetGeneratedCommandsMemoryRequirementsEXT>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetGeneratedCommandsMemoryRequirementsEXT"));
#endif
#if defined(VK_EXT_device_generated_commands)
    table.vkCreateIndirectCommandsLayoutEXT = reinterpret_cast<PFN_vkCreateIndirectCommandsLayoutEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateIndirectCommandsLayoutEXT"));
#endif
#if defined(VK_EXT_device_generated_commands)
    table.vkDestroyIndirectCommandsLayoutEXT = reinterpret_cast<PFN_vkDestroyIndirectCommandsLayoutEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyIndirectCommandsLayoutEXT"));
#endif
#if defined(VK_EXT_device_generated_commands)
    table.vkCreateIndirectExecutionSetEXT = reinterpret_cast<PFN_vkCreateIndirectExecutionSetEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateIndirectExecutionSetEXT"));
#endif
#if defined(VK_EXT_device_generated_commands)
    table.vkDestroyIndirectExecutionSetEXT = reinterpret_cast<PFN_vkDestroyIndirectExecutionSetEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyIndirectExecutionSetEXT"));
#endif
#if defined(VK_EXT_device_generated_commands)
    table.vkUpdateIndirectExecutionSetPipelineEXT = reinterpret_cast<PFN_vkUpdateIndirectExecutionSetPipelineEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkUpdateIndirectExecutionSetPipelineEXT"));
#endif
#if defined(VK_EXT_device_generated_commands)
    table.vkUpdateIndirectExecutionSetShaderEXT = reinterpret_cast<PFN_vkUpdateIndirectExecutionSetShaderEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkUpdateIndirectExecutionSetShaderEXT"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdPushDescriptorSet =
        reinterpret_cast<PFN_vkCmdPushDescriptorSet>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushDescriptorSet"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkTrimCommandPool =
        reinterpret_cast<PFN_vkTrimCommandPool>(instanceFuncs.GetDeviceProcAddr(device, "vkTrimCommandPool"));
#endif
#if defined(VK_KHR_external_memory_win32)
    table.vkGetMemoryWin32HandleKHR = reinterpret_cast<PFN_vkGetMemoryWin32HandleKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryWin32HandleKHR"));
#endif
#if defined(VK_KHR_external_memory_win32)
    table.vkGetMemoryWin32HandlePropertiesKHR = reinterpret_cast<PFN_vkGetMemoryWin32HandlePropertiesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryWin32HandlePropertiesKHR"));
#endif
#if defined(VK_KHR_external_memory_fd)
    table.vkGetMemoryFdKHR =
        reinterpret_cast<PFN_vkGetMemoryFdKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryFdKHR"));
#endif
#if defined(VK_KHR_external_memory_fd)
    table.vkGetMemoryFdPropertiesKHR = reinterpret_cast<PFN_vkGetMemoryFdPropertiesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryFdPropertiesKHR"));
#endif
#if defined(VK_FUCHSIA_external_memory)
    table.vkGetMemoryZirconHandleFUCHSIA = reinterpret_cast<PFN_vkGetMemoryZirconHandleFUCHSIA>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryZirconHandleFUCHSIA"));
#endif
#if defined(VK_FUCHSIA_external_memory)
    table.vkGetMemoryZirconHandlePropertiesFUCHSIA = reinterpret_cast<PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryZirconHandlePropertiesFUCHSIA"));
#endif
#if defined(VK_NV_external_memory_rdma)
    table.vkGetMemoryRemoteAddressNV = reinterpret_cast<PFN_vkGetMemoryRemoteAddressNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryRemoteAddressNV"));
#endif
#if defined(VK_NV_external_memory_sci_buf)
    table.vkGetMemorySciBufNV =
        reinterpret_cast<PFN_vkGetMemorySciBufNV>(instanceFuncs.GetDeviceProcAddr(device, "vkGetMemorySciBufNV"));
#endif
#if defined(VK_KHR_external_semaphore_win32)
    table.vkGetSemaphoreWin32HandleKHR = reinterpret_cast<PFN_vkGetSemaphoreWin32HandleKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSemaphoreWin32HandleKHR"));
#endif
#if defined(VK_KHR_external_semaphore_win32)
    table.vkImportSemaphoreWin32HandleKHR = reinterpret_cast<PFN_vkImportSemaphoreWin32HandleKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkImportSemaphoreWin32HandleKHR"));
#endif
#if defined(VK_KHR_external_semaphore_fd)
    table.vkGetSemaphoreFdKHR =
        reinterpret_cast<PFN_vkGetSemaphoreFdKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkGetSemaphoreFdKHR"));
#endif
#if defined(VK_KHR_external_semaphore_fd)
    table.vkImportSemaphoreFdKHR =
        reinterpret_cast<PFN_vkImportSemaphoreFdKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkImportSemaphoreFdKHR"));
#endif
#if defined(VK_FUCHSIA_external_semaphore)
    table.vkGetSemaphoreZirconHandleFUCHSIA = reinterpret_cast<PFN_vkGetSemaphoreZirconHandleFUCHSIA>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSemaphoreZirconHandleFUCHSIA"));
#endif
#if defined(VK_FUCHSIA_external_semaphore)
    table.vkImportSemaphoreZirconHandleFUCHSIA = reinterpret_cast<PFN_vkImportSemaphoreZirconHandleFUCHSIA>(
        instanceFuncs.GetDeviceProcAddr(device, "vkImportSemaphoreZirconHandleFUCHSIA"));
#endif
#if defined(VK_KHR_external_fence_win32)
    table.vkGetFenceWin32HandleKHR = reinterpret_cast<PFN_vkGetFenceWin32HandleKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetFenceWin32HandleKHR"));
#endif
#if defined(VK_KHR_external_fence_win32)
    table.vkImportFenceWin32HandleKHR = reinterpret_cast<PFN_vkImportFenceWin32HandleKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkImportFenceWin32HandleKHR"));
#endif
#if defined(VK_KHR_external_fence_fd)
    table.vkGetFenceFdKHR =
        reinterpret_cast<PFN_vkGetFenceFdKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkGetFenceFdKHR"));
#endif
#if defined(VK_KHR_external_fence_fd)
    table.vkImportFenceFdKHR =
        reinterpret_cast<PFN_vkImportFenceFdKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkImportFenceFdKHR"));
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
    table.vkGetFenceSciSyncFenceNV = reinterpret_cast<PFN_vkGetFenceSciSyncFenceNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetFenceSciSyncFenceNV"));
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
    table.vkGetFenceSciSyncObjNV =
        reinterpret_cast<PFN_vkGetFenceSciSyncObjNV>(instanceFuncs.GetDeviceProcAddr(device, "vkGetFenceSciSyncObjNV"));
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
    table.vkImportFenceSciSyncFenceNV = reinterpret_cast<PFN_vkImportFenceSciSyncFenceNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkImportFenceSciSyncFenceNV"));
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
    table.vkImportFenceSciSyncObjNV = reinterpret_cast<PFN_vkImportFenceSciSyncObjNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkImportFenceSciSyncObjNV"));
#endif
#if defined(VK_NV_external_sci_sync)
    table.vkGetSemaphoreSciSyncObjNV = reinterpret_cast<PFN_vkGetSemaphoreSciSyncObjNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSemaphoreSciSyncObjNV"));
#endif
#if defined(VK_NV_external_sci_sync)
    table.vkImportSemaphoreSciSyncObjNV = reinterpret_cast<PFN_vkImportSemaphoreSciSyncObjNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkImportSemaphoreSciSyncObjNV"));
#endif
#if defined(VK_NV_external_sci_sync2)
    table.vkCreateSemaphoreSciSyncPoolNV = reinterpret_cast<PFN_vkCreateSemaphoreSciSyncPoolNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateSemaphoreSciSyncPoolNV"));
#endif
#if defined(VK_NV_external_sci_sync2)
    table.vkDestroySemaphoreSciSyncPoolNV = reinterpret_cast<PFN_vkDestroySemaphoreSciSyncPoolNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroySemaphoreSciSyncPoolNV"));
#endif
#if defined(VK_EXT_display_control)
    table.vkDisplayPowerControlEXT = reinterpret_cast<PFN_vkDisplayPowerControlEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDisplayPowerControlEXT"));
#endif
#if defined(VK_EXT_display_control)
    table.vkRegisterDeviceEventEXT = reinterpret_cast<PFN_vkRegisterDeviceEventEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkRegisterDeviceEventEXT"));
#endif
#if defined(VK_EXT_display_control)
    table.vkRegisterDisplayEventEXT = reinterpret_cast<PFN_vkRegisterDisplayEventEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkRegisterDisplayEventEXT"));
#endif
#if defined(VK_EXT_display_control)
    table.vkGetSwapchainCounterEXT = reinterpret_cast<PFN_vkGetSwapchainCounterEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSwapchainCounterEXT"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetDeviceGroupPeerMemoryFeatures = reinterpret_cast<PFN_vkGetDeviceGroupPeerMemoryFeatures>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceGroupPeerMemoryFeatures"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkBindBufferMemory2 =
        reinterpret_cast<PFN_vkBindBufferMemory2>(instanceFuncs.GetDeviceProcAddr(device, "vkBindBufferMemory2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkBindImageMemory2 =
        reinterpret_cast<PFN_vkBindImageMemory2>(instanceFuncs.GetDeviceProcAddr(device, "vkBindImageMemory2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkCmdSetDeviceMask =
        reinterpret_cast<PFN_vkCmdSetDeviceMask>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDeviceMask"));
#endif
#if (defined(VK_KHR_swapchain) && defined(VKIT_API_VERSION_1_1)) ||                                                    \
    (defined(VK_KHR_device_group) && defined(VK_KHR_surface))
    table.vkGetDeviceGroupPresentCapabilitiesKHR = reinterpret_cast<PFN_vkGetDeviceGroupPresentCapabilitiesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceGroupPresentCapabilitiesKHR"));
#endif
#if (defined(VK_KHR_swapchain) && defined(VKIT_API_VERSION_1_1)) ||                                                    \
    (defined(VK_KHR_device_group) && defined(VK_KHR_surface))
    table.vkGetDeviceGroupSurfacePresentModesKHR = reinterpret_cast<PFN_vkGetDeviceGroupSurfacePresentModesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceGroupSurfacePresentModesKHR"));
#endif
#if (defined(VK_KHR_swapchain) && defined(VKIT_API_VERSION_1_1)) ||                                                    \
    (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain))
    table.vkAcquireNextImage2KHR =
        reinterpret_cast<PFN_vkAcquireNextImage2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkAcquireNextImage2KHR"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkCmdDispatchBase =
        reinterpret_cast<PFN_vkCmdDispatchBase>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDispatchBase"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkCreateDescriptorUpdateTemplate = reinterpret_cast<PFN_vkCreateDescriptorUpdateTemplate>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateDescriptorUpdateTemplate"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkDestroyDescriptorUpdateTemplate = reinterpret_cast<PFN_vkDestroyDescriptorUpdateTemplate>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyDescriptorUpdateTemplate"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkUpdateDescriptorSetWithTemplate = reinterpret_cast<PFN_vkUpdateDescriptorSetWithTemplate>(
        instanceFuncs.GetDeviceProcAddr(device, "vkUpdateDescriptorSetWithTemplate"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdPushDescriptorSetWithTemplate = reinterpret_cast<PFN_vkCmdPushDescriptorSetWithTemplate>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplate"));
#endif
#if defined(VK_EXT_hdr_metadata)
    table.vkSetHdrMetadataEXT =
        reinterpret_cast<PFN_vkSetHdrMetadataEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkSetHdrMetadataEXT"));
#endif
#if defined(VK_KHR_shared_presentable_image)
    table.vkGetSwapchainStatusKHR = reinterpret_cast<PFN_vkGetSwapchainStatusKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSwapchainStatusKHR"));
#endif
#if defined(VK_GOOGLE_display_timing)
    table.vkGetRefreshCycleDurationGOOGLE = reinterpret_cast<PFN_vkGetRefreshCycleDurationGOOGLE>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetRefreshCycleDurationGOOGLE"));
#endif
#if defined(VK_GOOGLE_display_timing)
    table.vkGetPastPresentationTimingGOOGLE = reinterpret_cast<PFN_vkGetPastPresentationTimingGOOGLE>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetPastPresentationTimingGOOGLE"));
#endif
#if defined(VK_NV_clip_space_w_scaling)
    table.vkCmdSetViewportWScalingNV = reinterpret_cast<PFN_vkCmdSetViewportWScalingNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetViewportWScalingNV"));
#endif
#if defined(VK_EXT_discard_rectangles)
    table.vkCmdSetDiscardRectangleEXT = reinterpret_cast<PFN_vkCmdSetDiscardRectangleEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDiscardRectangleEXT"));
#endif
#if VK_HEADER_VERSION >= 241 && ((defined(VK_EXT_discard_rectangles) && VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2))
    table.vkCmdSetDiscardRectangleEnableEXT = reinterpret_cast<PFN_vkCmdSetDiscardRectangleEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDiscardRectangleEnableEXT"));
#endif
#if VK_HEADER_VERSION >= 241 && ((defined(VK_EXT_discard_rectangles) && VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2 && \
                                  VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2))
    table.vkCmdSetDiscardRectangleModeEXT = reinterpret_cast<PFN_vkCmdSetDiscardRectangleModeEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDiscardRectangleModeEXT"));
#endif
#if defined(VK_EXT_sample_locations)
    table.vkCmdSetSampleLocationsEXT = reinterpret_cast<PFN_vkCmdSetSampleLocationsEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetSampleLocationsEXT"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetBufferMemoryRequirements2 = reinterpret_cast<PFN_vkGetBufferMemoryRequirements2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferMemoryRequirements2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetImageMemoryRequirements2 = reinterpret_cast<PFN_vkGetImageMemoryRequirements2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageMemoryRequirements2"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetImageSparseMemoryRequirements2 = reinterpret_cast<PFN_vkGetImageSparseMemoryRequirements2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkGetDeviceBufferMemoryRequirements = reinterpret_cast<PFN_vkGetDeviceBufferMemoryRequirements>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceBufferMemoryRequirements"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkGetDeviceImageMemoryRequirements = reinterpret_cast<PFN_vkGetDeviceImageMemoryRequirements>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceImageMemoryRequirements"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkGetDeviceImageSparseMemoryRequirements = reinterpret_cast<PFN_vkGetDeviceImageSparseMemoryRequirements>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceImageSparseMemoryRequirements"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkCreateSamplerYcbcrConversion = reinterpret_cast<PFN_vkCreateSamplerYcbcrConversion>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateSamplerYcbcrConversion"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkDestroySamplerYcbcrConversion = reinterpret_cast<PFN_vkDestroySamplerYcbcrConversion>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroySamplerYcbcrConversion"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetDeviceQueue2 =
        reinterpret_cast<PFN_vkGetDeviceQueue2>(instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceQueue2"));
#endif
#if defined(VK_EXT_validation_cache)
    table.vkCreateValidationCacheEXT = reinterpret_cast<PFN_vkCreateValidationCacheEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateValidationCacheEXT"));
#endif
#if defined(VK_EXT_validation_cache)
    table.vkDestroyValidationCacheEXT = reinterpret_cast<PFN_vkDestroyValidationCacheEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyValidationCacheEXT"));
#endif
#if defined(VK_EXT_validation_cache)
    table.vkGetValidationCacheDataEXT = reinterpret_cast<PFN_vkGetValidationCacheDataEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetValidationCacheDataEXT"));
#endif
#if defined(VK_EXT_validation_cache)
    table.vkMergeValidationCachesEXT = reinterpret_cast<PFN_vkMergeValidationCachesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkMergeValidationCachesEXT"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    table.vkGetDescriptorSetLayoutSupport = reinterpret_cast<PFN_vkGetDescriptorSetLayoutSupport>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSupport"));
#endif
#if defined(VK_ANDROID_native_buffer)
    table.vkGetSwapchainGrallocUsageANDROID = reinterpret_cast<PFN_vkGetSwapchainGrallocUsageANDROID>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSwapchainGrallocUsageANDROID"));
#endif
#if defined(VK_ANDROID_native_buffer)
    table.vkGetSwapchainGrallocUsage2ANDROID = reinterpret_cast<PFN_vkGetSwapchainGrallocUsage2ANDROID>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSwapchainGrallocUsage2ANDROID"));
#endif
#if defined(VK_ANDROID_native_buffer)
    table.vkAcquireImageANDROID =
        reinterpret_cast<PFN_vkAcquireImageANDROID>(instanceFuncs.GetDeviceProcAddr(device, "vkAcquireImageANDROID"));
#endif
#if defined(VK_ANDROID_native_buffer)
    table.vkQueueSignalReleaseImageANDROID = reinterpret_cast<PFN_vkQueueSignalReleaseImageANDROID>(
        instanceFuncs.GetDeviceProcAddr(device, "vkQueueSignalReleaseImageANDROID"));
#endif
#if defined(VK_AMD_shader_info)
    table.vkGetShaderInfoAMD =
        reinterpret_cast<PFN_vkGetShaderInfoAMD>(instanceFuncs.GetDeviceProcAddr(device, "vkGetShaderInfoAMD"));
#endif
#if defined(VK_AMD_display_native_hdr)
    table.vkSetLocalDimmingAMD =
        reinterpret_cast<PFN_vkSetLocalDimmingAMD>(instanceFuncs.GetDeviceProcAddr(device, "vkSetLocalDimmingAMD"));
#endif
#if defined(VK_KHR_calibrated_timestamps)
    table.vkGetCalibratedTimestampsKHR = reinterpret_cast<PFN_vkGetCalibratedTimestampsKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetCalibratedTimestampsKHR"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkSetDebugUtilsObjectNameEXT = reinterpret_cast<PFN_vkSetDebugUtilsObjectNameEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkSetDebugUtilsObjectNameEXT"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkSetDebugUtilsObjectTagEXT = reinterpret_cast<PFN_vkSetDebugUtilsObjectTagEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkSetDebugUtilsObjectTagEXT"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkQueueBeginDebugUtilsLabelEXT = reinterpret_cast<PFN_vkQueueBeginDebugUtilsLabelEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkQueueBeginDebugUtilsLabelEXT"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkQueueEndDebugUtilsLabelEXT = reinterpret_cast<PFN_vkQueueEndDebugUtilsLabelEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkQueueEndDebugUtilsLabelEXT"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkQueueInsertDebugUtilsLabelEXT = reinterpret_cast<PFN_vkQueueInsertDebugUtilsLabelEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkQueueInsertDebugUtilsLabelEXT"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkCmdBeginDebugUtilsLabelEXT = reinterpret_cast<PFN_vkCmdBeginDebugUtilsLabelEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginDebugUtilsLabelEXT"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkCmdEndDebugUtilsLabelEXT = reinterpret_cast<PFN_vkCmdEndDebugUtilsLabelEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndDebugUtilsLabelEXT"));
#endif
#if defined(VK_EXT_debug_utils)
    table.vkCmdInsertDebugUtilsLabelEXT = reinterpret_cast<PFN_vkCmdInsertDebugUtilsLabelEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdInsertDebugUtilsLabelEXT"));
#endif
#if defined(VK_EXT_external_memory_host)
    table.vkGetMemoryHostPointerPropertiesEXT = reinterpret_cast<PFN_vkGetMemoryHostPointerPropertiesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryHostPointerPropertiesEXT"));
#endif
#if defined(VK_AMD_buffer_marker)
    table.vkCmdWriteBufferMarkerAMD = reinterpret_cast<PFN_vkCmdWriteBufferMarkerAMD>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdWriteBufferMarkerAMD"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkCreateRenderPass2 =
        reinterpret_cast<PFN_vkCreateRenderPass2>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateRenderPass2"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkCmdBeginRenderPass2 =
        reinterpret_cast<PFN_vkCmdBeginRenderPass2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginRenderPass2"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkCmdNextSubpass2 =
        reinterpret_cast<PFN_vkCmdNextSubpass2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdNextSubpass2"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkCmdEndRenderPass2 =
        reinterpret_cast<PFN_vkCmdEndRenderPass2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndRenderPass2"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkGetSemaphoreCounterValue = reinterpret_cast<PFN_vkGetSemaphoreCounterValue>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSemaphoreCounterValue"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkWaitSemaphores =
        reinterpret_cast<PFN_vkWaitSemaphores>(instanceFuncs.GetDeviceProcAddr(device, "vkWaitSemaphores"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkSignalSemaphore =
        reinterpret_cast<PFN_vkSignalSemaphore>(instanceFuncs.GetDeviceProcAddr(device, "vkSignalSemaphore"));
#endif
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
    table.vkGetAndroidHardwareBufferPropertiesANDROID =
        reinterpret_cast<PFN_vkGetAndroidHardwareBufferPropertiesANDROID>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetAndroidHardwareBufferPropertiesANDROID"));
#endif
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
    table.vkGetMemoryAndroidHardwareBufferANDROID = reinterpret_cast<PFN_vkGetMemoryAndroidHardwareBufferANDROID>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryAndroidHardwareBufferANDROID"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkCmdDrawIndirectCount =
        reinterpret_cast<PFN_vkCmdDrawIndirectCount>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndirectCount"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkCmdDrawIndexedIndirectCount = reinterpret_cast<PFN_vkCmdDrawIndexedIndirectCount>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCount"));
#endif
#if defined(VK_NV_device_diagnostic_checkpoints)
    table.vkCmdSetCheckpointNV =
        reinterpret_cast<PFN_vkCmdSetCheckpointNV>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCheckpointNV"));
#endif
#if defined(VK_NV_device_diagnostic_checkpoints)
    table.vkGetQueueCheckpointDataNV = reinterpret_cast<PFN_vkGetQueueCheckpointDataNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetQueueCheckpointDataNV"));
#endif
#if defined(VK_EXT_transform_feedback)
    table.vkCmdBindTransformFeedbackBuffersEXT = reinterpret_cast<PFN_vkCmdBindTransformFeedbackBuffersEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindTransformFeedbackBuffersEXT"));
#endif
#if defined(VK_EXT_transform_feedback)
    table.vkCmdBeginTransformFeedbackEXT = reinterpret_cast<PFN_vkCmdBeginTransformFeedbackEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginTransformFeedbackEXT"));
#endif
#if defined(VK_EXT_transform_feedback)
    table.vkCmdEndTransformFeedbackEXT = reinterpret_cast<PFN_vkCmdEndTransformFeedbackEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndTransformFeedbackEXT"));
#endif
#if defined(VK_EXT_transform_feedback)
    table.vkCmdBeginQueryIndexedEXT = reinterpret_cast<PFN_vkCmdBeginQueryIndexedEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginQueryIndexedEXT"));
#endif
#if defined(VK_EXT_transform_feedback)
    table.vkCmdEndQueryIndexedEXT = reinterpret_cast<PFN_vkCmdEndQueryIndexedEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndQueryIndexedEXT"));
#endif
#if defined(VK_EXT_transform_feedback)
    table.vkCmdDrawIndirectByteCountEXT = reinterpret_cast<PFN_vkCmdDrawIndirectByteCountEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndirectByteCountEXT"));
#endif
#if (defined(VK_NV_scissor_exclusive) && VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION >= 2)
    table.vkCmdSetExclusiveScissorNV = reinterpret_cast<PFN_vkCmdSetExclusiveScissorNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetExclusiveScissorNV"));
#endif
#if VK_HEADER_VERSION >= 241 && ((defined(VK_NV_scissor_exclusive) && VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION >= 2))
    table.vkCmdSetExclusiveScissorEnableNV = reinterpret_cast<PFN_vkCmdSetExclusiveScissorEnableNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetExclusiveScissorEnableNV"));
#endif
#if defined(VK_NV_shading_rate_image)
    table.vkCmdBindShadingRateImageNV = reinterpret_cast<PFN_vkCmdBindShadingRateImageNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindShadingRateImageNV"));
#endif
#if defined(VK_NV_shading_rate_image)
    table.vkCmdSetViewportShadingRatePaletteNV = reinterpret_cast<PFN_vkCmdSetViewportShadingRatePaletteNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetViewportShadingRatePaletteNV"));
#endif
#if defined(VK_NV_shading_rate_image)
    table.vkCmdSetCoarseSampleOrderNV = reinterpret_cast<PFN_vkCmdSetCoarseSampleOrderNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCoarseSampleOrderNV"));
#endif
#if defined(VK_NV_mesh_shader)
    table.vkCmdDrawMeshTasksNV =
        reinterpret_cast<PFN_vkCmdDrawMeshTasksNV>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawMeshTasksNV"));
#endif
#if defined(VK_NV_mesh_shader)
    table.vkCmdDrawMeshTasksIndirectNV = reinterpret_cast<PFN_vkCmdDrawMeshTasksIndirectNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectNV"));
#endif
#if (defined(VK_NV_mesh_shader) &&                                                                                     \
     (defined(VKIT_API_VERSION_1_2) || defined(VK_KHR_draw_indirect_count) || defined(VK_AMD_draw_indirect_count)))
    table.vkCmdDrawMeshTasksIndirectCountNV = reinterpret_cast<PFN_vkCmdDrawMeshTasksIndirectCountNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectCountNV"));
#endif
#if defined(VK_EXT_mesh_shader)
    table.vkCmdDrawMeshTasksEXT =
        reinterpret_cast<PFN_vkCmdDrawMeshTasksEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawMeshTasksEXT"));
#endif
#if defined(VK_EXT_mesh_shader)
    table.vkCmdDrawMeshTasksIndirectEXT = reinterpret_cast<PFN_vkCmdDrawMeshTasksIndirectEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectEXT"));
#endif
#if (defined(VK_EXT_mesh_shader) &&                                                                                    \
     (defined(VKIT_API_VERSION_1_2) || defined(VK_KHR_draw_indirect_count) || defined(VK_AMD_draw_indirect_count)))
    table.vkCmdDrawMeshTasksIndirectCountEXT = reinterpret_cast<PFN_vkCmdDrawMeshTasksIndirectCountEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectCountEXT"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkCompileDeferredNV =
        reinterpret_cast<PFN_vkCompileDeferredNV>(instanceFuncs.GetDeviceProcAddr(device, "vkCompileDeferredNV"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkCreateAccelerationStructureNV = reinterpret_cast<PFN_vkCreateAccelerationStructureNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateAccelerationStructureNV"));
#endif
#if defined(VK_HUAWEI_invocation_mask)
    table.vkCmdBindInvocationMaskHUAWEI = reinterpret_cast<PFN_vkCmdBindInvocationMaskHUAWEI>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindInvocationMaskHUAWEI"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkDestroyAccelerationStructureKHR = reinterpret_cast<PFN_vkDestroyAccelerationStructureKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyAccelerationStructureKHR"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkDestroyAccelerationStructureNV = reinterpret_cast<PFN_vkDestroyAccelerationStructureNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyAccelerationStructureNV"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkGetAccelerationStructureMemoryRequirementsNV =
        reinterpret_cast<PFN_vkGetAccelerationStructureMemoryRequirementsNV>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetAccelerationStructureMemoryRequirementsNV"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkBindAccelerationStructureMemoryNV = reinterpret_cast<PFN_vkBindAccelerationStructureMemoryNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkBindAccelerationStructureMemoryNV"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkCmdCopyAccelerationStructureNV = reinterpret_cast<PFN_vkCmdCopyAccelerationStructureNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureNV"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCmdCopyAccelerationStructureKHR = reinterpret_cast<PFN_vkCmdCopyAccelerationStructureKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCopyAccelerationStructureKHR = reinterpret_cast<PFN_vkCopyAccelerationStructureKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCopyAccelerationStructureKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCmdCopyAccelerationStructureToMemoryKHR = reinterpret_cast<PFN_vkCmdCopyAccelerationStructureToMemoryKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureToMemoryKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCopyAccelerationStructureToMemoryKHR = reinterpret_cast<PFN_vkCopyAccelerationStructureToMemoryKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCopyAccelerationStructureToMemoryKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCmdCopyMemoryToAccelerationStructureKHR = reinterpret_cast<PFN_vkCmdCopyMemoryToAccelerationStructureKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyMemoryToAccelerationStructureKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCopyMemoryToAccelerationStructureKHR = reinterpret_cast<PFN_vkCopyMemoryToAccelerationStructureKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCopyMemoryToAccelerationStructureKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCmdWriteAccelerationStructuresPropertiesKHR =
        reinterpret_cast<PFN_vkCmdWriteAccelerationStructuresPropertiesKHR>(
            instanceFuncs.GetDeviceProcAddr(device, "vkCmdWriteAccelerationStructuresPropertiesKHR"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkCmdWriteAccelerationStructuresPropertiesNV =
        reinterpret_cast<PFN_vkCmdWriteAccelerationStructuresPropertiesNV>(
            instanceFuncs.GetDeviceProcAddr(device, "vkCmdWriteAccelerationStructuresPropertiesNV"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkCmdBuildAccelerationStructureNV = reinterpret_cast<PFN_vkCmdBuildAccelerationStructureNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBuildAccelerationStructureNV"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkWriteAccelerationStructuresPropertiesKHR = reinterpret_cast<PFN_vkWriteAccelerationStructuresPropertiesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkWriteAccelerationStructuresPropertiesKHR"));
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
    table.vkCmdTraceRaysKHR =
        reinterpret_cast<PFN_vkCmdTraceRaysKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdTraceRaysKHR"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkCmdTraceRaysNV =
        reinterpret_cast<PFN_vkCmdTraceRaysNV>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdTraceRaysNV"));
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
    table.vkGetRayTracingShaderGroupHandlesKHR = reinterpret_cast<PFN_vkGetRayTracingShaderGroupHandlesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetRayTracingShaderGroupHandlesKHR"));
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
    table.vkGetRayTracingCaptureReplayShaderGroupHandlesKHR =
        reinterpret_cast<PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkGetAccelerationStructureHandleNV = reinterpret_cast<PFN_vkGetAccelerationStructureHandleNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetAccelerationStructureHandleNV"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkCreateRayTracingPipelinesNV = reinterpret_cast<PFN_vkCreateRayTracingPipelinesNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateRayTracingPipelinesNV"));
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
    table.vkCreateRayTracingPipelinesKHR = reinterpret_cast<PFN_vkCreateRayTracingPipelinesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateRayTracingPipelinesKHR"));
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
    table.vkCmdTraceRaysIndirectKHR = reinterpret_cast<PFN_vkCmdTraceRaysIndirectKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdTraceRaysIndirectKHR"));
#endif
#if (defined(VK_KHR_ray_tracing_maintenance1) && defined(VK_KHR_ray_tracing_pipeline))
    table.vkCmdTraceRaysIndirect2KHR = reinterpret_cast<PFN_vkCmdTraceRaysIndirect2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdTraceRaysIndirect2KHR"));
#endif
#if defined(VK_NV_cluster_acceleration_structure)
    table.vkGetClusterAccelerationStructureBuildSizesNV =
        reinterpret_cast<PFN_vkGetClusterAccelerationStructureBuildSizesNV>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetClusterAccelerationStructureBuildSizesNV"));
#endif
#if defined(VK_NV_cluster_acceleration_structure)
    table.vkCmdBuildClusterAccelerationStructureIndirectNV =
        reinterpret_cast<PFN_vkCmdBuildClusterAccelerationStructureIndirectNV>(
            instanceFuncs.GetDeviceProcAddr(device, "vkCmdBuildClusterAccelerationStructureIndirectNV"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkGetDeviceAccelerationStructureCompatibilityKHR =
        reinterpret_cast<PFN_vkGetDeviceAccelerationStructureCompatibilityKHR>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceAccelerationStructureCompatibilityKHR"));
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
    table.vkGetRayTracingShaderGroupStackSizeKHR = reinterpret_cast<PFN_vkGetRayTracingShaderGroupStackSizeKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetRayTracingShaderGroupStackSizeKHR"));
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
    table.vkCmdSetRayTracingPipelineStackSizeKHR = reinterpret_cast<PFN_vkCmdSetRayTracingPipelineStackSizeKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRayTracingPipelineStackSizeKHR"));
#endif
#if defined(VK_NVX_image_view_handle)
    table.vkGetImageViewHandleNVX = reinterpret_cast<PFN_vkGetImageViewHandleNVX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageViewHandleNVX"));
#endif
#if (defined(VK_NVX_image_view_handle) && VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION >= 3)
    table.vkGetImageViewHandle64NVX = reinterpret_cast<PFN_vkGetImageViewHandle64NVX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageViewHandle64NVX"));
#endif
#if (defined(VK_NVX_image_view_handle) && VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION >= 3 &&                                \
     VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION >= 2)
    table.vkGetImageViewAddressNVX = reinterpret_cast<PFN_vkGetImageViewAddressNVX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageViewAddressNVX"));
#endif
#if (defined(VK_EXT_full_screen_exclusive) && (defined(VK_KHR_device_group) || defined(VKIT_API_VERSION_1_1)))
    table.vkGetDeviceGroupSurfacePresentModes2EXT = reinterpret_cast<PFN_vkGetDeviceGroupSurfacePresentModes2EXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceGroupSurfacePresentModes2EXT"));
#endif
#if defined(VK_EXT_full_screen_exclusive)
    table.vkAcquireFullScreenExclusiveModeEXT = reinterpret_cast<PFN_vkAcquireFullScreenExclusiveModeEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkAcquireFullScreenExclusiveModeEXT"));
#endif
#if defined(VK_EXT_full_screen_exclusive)
    table.vkReleaseFullScreenExclusiveModeEXT = reinterpret_cast<PFN_vkReleaseFullScreenExclusiveModeEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkReleaseFullScreenExclusiveModeEXT"));
#endif
#if defined(VK_KHR_performance_query)
    table.vkAcquireProfilingLockKHR = reinterpret_cast<PFN_vkAcquireProfilingLockKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkAcquireProfilingLockKHR"));
#endif
#if defined(VK_KHR_performance_query)
    table.vkReleaseProfilingLockKHR = reinterpret_cast<PFN_vkReleaseProfilingLockKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkReleaseProfilingLockKHR"));
#endif
#if defined(VK_EXT_image_drm_format_modifier)
    table.vkGetImageDrmFormatModifierPropertiesEXT = reinterpret_cast<PFN_vkGetImageDrmFormatModifierPropertiesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageDrmFormatModifierPropertiesEXT"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkGetBufferOpaqueCaptureAddress = reinterpret_cast<PFN_vkGetBufferOpaqueCaptureAddress>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureAddress"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkGetBufferDeviceAddress = reinterpret_cast<PFN_vkGetBufferDeviceAddress>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferDeviceAddress"));
#endif
#if defined(VK_INTEL_performance_query)
    table.vkInitializePerformanceApiINTEL = reinterpret_cast<PFN_vkInitializePerformanceApiINTEL>(
        instanceFuncs.GetDeviceProcAddr(device, "vkInitializePerformanceApiINTEL"));
#endif
#if defined(VK_INTEL_performance_query)
    table.vkUninitializePerformanceApiINTEL = reinterpret_cast<PFN_vkUninitializePerformanceApiINTEL>(
        instanceFuncs.GetDeviceProcAddr(device, "vkUninitializePerformanceApiINTEL"));
#endif
#if defined(VK_INTEL_performance_query)
    table.vkCmdSetPerformanceMarkerINTEL = reinterpret_cast<PFN_vkCmdSetPerformanceMarkerINTEL>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetPerformanceMarkerINTEL"));
#endif
#if defined(VK_INTEL_performance_query)
    table.vkCmdSetPerformanceStreamMarkerINTEL = reinterpret_cast<PFN_vkCmdSetPerformanceStreamMarkerINTEL>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetPerformanceStreamMarkerINTEL"));
#endif
#if defined(VK_INTEL_performance_query)
    table.vkCmdSetPerformanceOverrideINTEL = reinterpret_cast<PFN_vkCmdSetPerformanceOverrideINTEL>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetPerformanceOverrideINTEL"));
#endif
#if defined(VK_INTEL_performance_query)
    table.vkAcquirePerformanceConfigurationINTEL = reinterpret_cast<PFN_vkAcquirePerformanceConfigurationINTEL>(
        instanceFuncs.GetDeviceProcAddr(device, "vkAcquirePerformanceConfigurationINTEL"));
#endif
#if defined(VK_INTEL_performance_query)
    table.vkReleasePerformanceConfigurationINTEL = reinterpret_cast<PFN_vkReleasePerformanceConfigurationINTEL>(
        instanceFuncs.GetDeviceProcAddr(device, "vkReleasePerformanceConfigurationINTEL"));
#endif
#if defined(VK_INTEL_performance_query)
    table.vkQueueSetPerformanceConfigurationINTEL = reinterpret_cast<PFN_vkQueueSetPerformanceConfigurationINTEL>(
        instanceFuncs.GetDeviceProcAddr(device, "vkQueueSetPerformanceConfigurationINTEL"));
#endif
#if defined(VK_INTEL_performance_query)
    table.vkGetPerformanceParameterINTEL = reinterpret_cast<PFN_vkGetPerformanceParameterINTEL>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetPerformanceParameterINTEL"));
#endif
#if defined(VKIT_API_VERSION_1_2)
    table.vkGetDeviceMemoryOpaqueCaptureAddress = reinterpret_cast<PFN_vkGetDeviceMemoryOpaqueCaptureAddress>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceMemoryOpaqueCaptureAddress"));
#endif
#if defined(VK_KHR_pipeline_executable_properties)
    table.vkGetPipelineExecutablePropertiesKHR = reinterpret_cast<PFN_vkGetPipelineExecutablePropertiesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetPipelineExecutablePropertiesKHR"));
#endif
#if defined(VK_KHR_pipeline_executable_properties)
    table.vkGetPipelineExecutableStatisticsKHR = reinterpret_cast<PFN_vkGetPipelineExecutableStatisticsKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetPipelineExecutableStatisticsKHR"));
#endif
#if defined(VK_KHR_pipeline_executable_properties)
    table.vkGetPipelineExecutableInternalRepresentationsKHR =
        reinterpret_cast<PFN_vkGetPipelineExecutableInternalRepresentationsKHR>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetPipelineExecutableInternalRepresentationsKHR"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdSetLineStipple =
        reinterpret_cast<PFN_vkCmdSetLineStipple>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetLineStipple"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCreateAccelerationStructureKHR = reinterpret_cast<PFN_vkCreateAccelerationStructureKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateAccelerationStructureKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCmdBuildAccelerationStructuresKHR = reinterpret_cast<PFN_vkCmdBuildAccelerationStructuresKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBuildAccelerationStructuresKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkCmdBuildAccelerationStructuresIndirectKHR =
        reinterpret_cast<PFN_vkCmdBuildAccelerationStructuresIndirectKHR>(
            instanceFuncs.GetDeviceProcAddr(device, "vkCmdBuildAccelerationStructuresIndirectKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkBuildAccelerationStructuresKHR = reinterpret_cast<PFN_vkBuildAccelerationStructuresKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkBuildAccelerationStructuresKHR"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkGetAccelerationStructureDeviceAddressKHR = reinterpret_cast<PFN_vkGetAccelerationStructureDeviceAddressKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetAccelerationStructureDeviceAddressKHR"));
#endif
#if defined(VK_KHR_deferred_host_operations)
    table.vkCreateDeferredOperationKHR = reinterpret_cast<PFN_vkCreateDeferredOperationKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateDeferredOperationKHR"));
#endif
#if defined(VK_KHR_deferred_host_operations)
    table.vkDestroyDeferredOperationKHR = reinterpret_cast<PFN_vkDestroyDeferredOperationKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyDeferredOperationKHR"));
#endif
#if defined(VK_KHR_deferred_host_operations)
    table.vkGetDeferredOperationMaxConcurrencyKHR = reinterpret_cast<PFN_vkGetDeferredOperationMaxConcurrencyKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeferredOperationMaxConcurrencyKHR"));
#endif
#if defined(VK_KHR_deferred_host_operations)
    table.vkGetDeferredOperationResultKHR = reinterpret_cast<PFN_vkGetDeferredOperationResultKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeferredOperationResultKHR"));
#endif
#if defined(VK_KHR_deferred_host_operations)
    table.vkDeferredOperationJoinKHR = reinterpret_cast<PFN_vkDeferredOperationJoinKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDeferredOperationJoinKHR"));
#endif
#if defined(VK_NV_device_generated_commands_compute)
    table.vkGetPipelineIndirectMemoryRequirementsNV = reinterpret_cast<PFN_vkGetPipelineIndirectMemoryRequirementsNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetPipelineIndirectMemoryRequirementsNV"));
#endif
#if defined(VK_NV_device_generated_commands_compute)
    table.vkGetPipelineIndirectDeviceAddressNV = reinterpret_cast<PFN_vkGetPipelineIndirectDeviceAddressNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetPipelineIndirectDeviceAddressNV"));
#endif
#if defined(VK_AMD_anti_lag)
    table.vkAntiLagUpdateAMD =
        reinterpret_cast<PFN_vkAntiLagUpdateAMD>(instanceFuncs.GetDeviceProcAddr(device, "vkAntiLagUpdateAMD"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetCullMode =
        reinterpret_cast<PFN_vkCmdSetCullMode>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCullMode"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetFrontFace =
        reinterpret_cast<PFN_vkCmdSetFrontFace>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetFrontFace"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetPrimitiveTopology = reinterpret_cast<PFN_vkCmdSetPrimitiveTopology>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetPrimitiveTopology"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetViewportWithCount = reinterpret_cast<PFN_vkCmdSetViewportWithCount>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetViewportWithCount"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetScissorWithCount = reinterpret_cast<PFN_vkCmdSetScissorWithCount>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetScissorWithCount"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdBindIndexBuffer2 =
        reinterpret_cast<PFN_vkCmdBindIndexBuffer2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindIndexBuffer2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdBindVertexBuffers2 = reinterpret_cast<PFN_vkCmdBindVertexBuffers2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindVertexBuffers2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetDepthTestEnable = reinterpret_cast<PFN_vkCmdSetDepthTestEnable>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthTestEnable"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetDepthWriteEnable = reinterpret_cast<PFN_vkCmdSetDepthWriteEnable>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthWriteEnable"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetDepthCompareOp =
        reinterpret_cast<PFN_vkCmdSetDepthCompareOp>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthCompareOp"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetDepthBoundsTestEnable = reinterpret_cast<PFN_vkCmdSetDepthBoundsTestEnable>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthBoundsTestEnable"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetStencilTestEnable = reinterpret_cast<PFN_vkCmdSetStencilTestEnable>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetStencilTestEnable"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetStencilOp =
        reinterpret_cast<PFN_vkCmdSetStencilOp>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetStencilOp"));
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
    table.vkCmdSetPatchControlPointsEXT = reinterpret_cast<PFN_vkCmdSetPatchControlPointsEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetPatchControlPointsEXT"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetRasterizerDiscardEnable = reinterpret_cast<PFN_vkCmdSetRasterizerDiscardEnable>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRasterizerDiscardEnable"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetDepthBiasEnable = reinterpret_cast<PFN_vkCmdSetDepthBiasEnable>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthBiasEnable"));
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
    table.vkCmdSetLogicOpEXT =
        reinterpret_cast<PFN_vkCmdSetLogicOpEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetLogicOpEXT"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetPrimitiveRestartEnable = reinterpret_cast<PFN_vkCmdSetPrimitiveRestartEnable>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetPrimitiveRestartEnable"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && (defined(VK_KHR_maintenance2) || defined(VKIT_API_VERSION_1_1))) ||    \
    defined(VK_EXT_shader_object)
    table.vkCmdSetTessellationDomainOriginEXT = reinterpret_cast<PFN_vkCmdSetTessellationDomainOriginEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetTessellationDomainOriginEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetDepthClampEnableEXT = reinterpret_cast<PFN_vkCmdSetDepthClampEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthClampEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetPolygonModeEXT =
        reinterpret_cast<PFN_vkCmdSetPolygonModeEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetPolygonModeEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetRasterizationSamplesEXT = reinterpret_cast<PFN_vkCmdSetRasterizationSamplesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRasterizationSamplesEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetSampleMaskEXT =
        reinterpret_cast<PFN_vkCmdSetSampleMaskEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetSampleMaskEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetAlphaToCoverageEnableEXT = reinterpret_cast<PFN_vkCmdSetAlphaToCoverageEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetAlphaToCoverageEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetAlphaToOneEnableEXT = reinterpret_cast<PFN_vkCmdSetAlphaToOneEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetAlphaToOneEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetLogicOpEnableEXT = reinterpret_cast<PFN_vkCmdSetLogicOpEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetLogicOpEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetColorBlendEnableEXT = reinterpret_cast<PFN_vkCmdSetColorBlendEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetColorBlendEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetColorBlendEquationEXT = reinterpret_cast<PFN_vkCmdSetColorBlendEquationEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetColorBlendEquationEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
    table.vkCmdSetColorWriteMaskEXT = reinterpret_cast<PFN_vkCmdSetColorWriteMaskEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetColorWriteMaskEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_transform_feedback)) ||                                 \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_transform_feedback))
    table.vkCmdSetRasterizationStreamEXT = reinterpret_cast<PFN_vkCmdSetRasterizationStreamEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRasterizationStreamEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_conservative_rasterization)) ||                         \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_conservative_rasterization))
    table.vkCmdSetConservativeRasterizationModeEXT = reinterpret_cast<PFN_vkCmdSetConservativeRasterizationModeEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetConservativeRasterizationModeEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_conservative_rasterization)) ||                         \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_conservative_rasterization))
    table.vkCmdSetExtraPrimitiveOverestimationSizeEXT =
        reinterpret_cast<PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT>(
            instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetExtraPrimitiveOverestimationSizeEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_enable)) ||                                  \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_enable))
    table.vkCmdSetDepthClipEnableEXT = reinterpret_cast<PFN_vkCmdSetDepthClipEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthClipEnableEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_sample_locations)) ||                                   \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_sample_locations))
    table.vkCmdSetSampleLocationsEnableEXT = reinterpret_cast<PFN_vkCmdSetSampleLocationsEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetSampleLocationsEnableEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_blend_operation_advanced)) ||                           \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_blend_operation_advanced))
    table.vkCmdSetColorBlendAdvancedEXT = reinterpret_cast<PFN_vkCmdSetColorBlendAdvancedEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetColorBlendAdvancedEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_provoking_vertex)) ||                                   \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_provoking_vertex))
    table.vkCmdSetProvokingVertexModeEXT = reinterpret_cast<PFN_vkCmdSetProvokingVertexModeEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetProvokingVertexModeEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_line_rasterization)) ||                                 \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_line_rasterization))
    table.vkCmdSetLineRasterizationModeEXT = reinterpret_cast<PFN_vkCmdSetLineRasterizationModeEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetLineRasterizationModeEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_line_rasterization)) ||                                 \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_line_rasterization))
    table.vkCmdSetLineStippleEnableEXT = reinterpret_cast<PFN_vkCmdSetLineStippleEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetLineStippleEnableEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_control)) ||                                 \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_control))
    table.vkCmdSetDepthClipNegativeOneToOneEXT = reinterpret_cast<PFN_vkCmdSetDepthClipNegativeOneToOneEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthClipNegativeOneToOneEXT"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_clip_space_w_scaling)) ||                                \
    (defined(VK_EXT_shader_object) && defined(VK_NV_clip_space_w_scaling))
    table.vkCmdSetViewportWScalingEnableNV = reinterpret_cast<PFN_vkCmdSetViewportWScalingEnableNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetViewportWScalingEnableNV"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_viewport_swizzle)) ||                                    \
    (defined(VK_EXT_shader_object) && defined(VK_NV_viewport_swizzle))
    table.vkCmdSetViewportSwizzleNV = reinterpret_cast<PFN_vkCmdSetViewportSwizzleNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetViewportSwizzleNV"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_fragment_coverage_to_color)) ||                          \
    (defined(VK_EXT_shader_object) && defined(VK_NV_fragment_coverage_to_color))
    table.vkCmdSetCoverageToColorEnableNV = reinterpret_cast<PFN_vkCmdSetCoverageToColorEnableNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCoverageToColorEnableNV"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_fragment_coverage_to_color)) ||                          \
    (defined(VK_EXT_shader_object) && defined(VK_NV_fragment_coverage_to_color))
    table.vkCmdSetCoverageToColorLocationNV = reinterpret_cast<PFN_vkCmdSetCoverageToColorLocationNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCoverageToColorLocationNV"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) ||                           \
    (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples))
    table.vkCmdSetCoverageModulationModeNV = reinterpret_cast<PFN_vkCmdSetCoverageModulationModeNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCoverageModulationModeNV"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) ||                           \
    (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples))
    table.vkCmdSetCoverageModulationTableEnableNV = reinterpret_cast<PFN_vkCmdSetCoverageModulationTableEnableNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCoverageModulationTableEnableNV"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) ||                           \
    (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples))
    table.vkCmdSetCoverageModulationTableNV = reinterpret_cast<PFN_vkCmdSetCoverageModulationTableNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCoverageModulationTableNV"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_shading_rate_image)) ||                                  \
    (defined(VK_EXT_shader_object) && defined(VK_NV_shading_rate_image))
    table.vkCmdSetShadingRateImageEnableNV = reinterpret_cast<PFN_vkCmdSetShadingRateImageEnableNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetShadingRateImageEnableNV"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_coverage_reduction_mode)) ||                             \
    (defined(VK_EXT_shader_object) && defined(VK_NV_coverage_reduction_mode))
    table.vkCmdSetCoverageReductionModeNV = reinterpret_cast<PFN_vkCmdSetCoverageReductionModeNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCoverageReductionModeNV"));
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_representative_fragment_test)) ||                        \
    (defined(VK_EXT_shader_object) && defined(VK_NV_representative_fragment_test))
    table.vkCmdSetRepresentativeFragmentTestEnableNV = reinterpret_cast<PFN_vkCmdSetRepresentativeFragmentTestEnableNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRepresentativeFragmentTestEnableNV"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCreatePrivateDataSlot = reinterpret_cast<PFN_vkCreatePrivateDataSlot>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreatePrivateDataSlot"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkDestroyPrivateDataSlot = reinterpret_cast<PFN_vkDestroyPrivateDataSlot>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyPrivateDataSlot"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkSetPrivateData =
        reinterpret_cast<PFN_vkSetPrivateData>(instanceFuncs.GetDeviceProcAddr(device, "vkSetPrivateData"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkGetPrivateData =
        reinterpret_cast<PFN_vkGetPrivateData>(instanceFuncs.GetDeviceProcAddr(device, "vkGetPrivateData"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdCopyBuffer2 =
        reinterpret_cast<PFN_vkCmdCopyBuffer2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyBuffer2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdCopyImage2 =
        reinterpret_cast<PFN_vkCmdCopyImage2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyImage2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdBlitImage2 =
        reinterpret_cast<PFN_vkCmdBlitImage2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBlitImage2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdCopyBufferToImage2 = reinterpret_cast<PFN_vkCmdCopyBufferToImage2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyBufferToImage2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdCopyImageToBuffer2 = reinterpret_cast<PFN_vkCmdCopyImageToBuffer2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyImageToBuffer2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdResolveImage2 =
        reinterpret_cast<PFN_vkCmdResolveImage2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdResolveImage2"));
#endif
#if defined(VK_KHR_object_refresh)
    table.vkCmdRefreshObjectsKHR =
        reinterpret_cast<PFN_vkCmdRefreshObjectsKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdRefreshObjectsKHR"));
#endif
#if defined(VK_KHR_fragment_shading_rate)
    table.vkCmdSetFragmentShadingRateKHR = reinterpret_cast<PFN_vkCmdSetFragmentShadingRateKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetFragmentShadingRateKHR"));
#endif
#if defined(VK_NV_fragment_shading_rate_enums)
    table.vkCmdSetFragmentShadingRateEnumNV = reinterpret_cast<PFN_vkCmdSetFragmentShadingRateEnumNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetFragmentShadingRateEnumNV"));
#endif
#if defined(VK_KHR_acceleration_structure)
    table.vkGetAccelerationStructureBuildSizesKHR = reinterpret_cast<PFN_vkGetAccelerationStructureBuildSizesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetAccelerationStructureBuildSizesKHR"));
#endif
#if defined(VK_EXT_vertex_input_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetVertexInputEXT =
        reinterpret_cast<PFN_vkCmdSetVertexInputEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetVertexInputEXT"));
#endif
#if defined(VK_EXT_color_write_enable)
    table.vkCmdSetColorWriteEnableEXT = reinterpret_cast<PFN_vkCmdSetColorWriteEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetColorWriteEnableEXT"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdSetEvent2 =
        reinterpret_cast<PFN_vkCmdSetEvent2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetEvent2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdResetEvent2 =
        reinterpret_cast<PFN_vkCmdResetEvent2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdResetEvent2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdWaitEvents2 =
        reinterpret_cast<PFN_vkCmdWaitEvents2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdWaitEvents2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdPipelineBarrier2 =
        reinterpret_cast<PFN_vkCmdPipelineBarrier2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdPipelineBarrier2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkQueueSubmit2 =
        reinterpret_cast<PFN_vkQueueSubmit2>(instanceFuncs.GetDeviceProcAddr(device, "vkQueueSubmit2"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdWriteTimestamp2 =
        reinterpret_cast<PFN_vkCmdWriteTimestamp2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdWriteTimestamp2"));
#endif
#if (defined(VK_AMD_buffer_marker) && (defined(VKIT_API_VERSION_1_3) || defined(VK_KHR_synchronization2)))
    table.vkCmdWriteBufferMarker2AMD = reinterpret_cast<PFN_vkCmdWriteBufferMarker2AMD>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdWriteBufferMarker2AMD"));
#endif
#if (defined(VK_NV_device_diagnostic_checkpoints) &&                                                                   \
     (defined(VKIT_API_VERSION_1_3) || defined(VK_KHR_synchronization2)))
    table.vkGetQueueCheckpointData2NV = reinterpret_cast<PFN_vkGetQueueCheckpointData2NV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetQueueCheckpointData2NV"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCopyMemoryToImage =
        reinterpret_cast<PFN_vkCopyMemoryToImage>(instanceFuncs.GetDeviceProcAddr(device, "vkCopyMemoryToImage"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCopyImageToMemory =
        reinterpret_cast<PFN_vkCopyImageToMemory>(instanceFuncs.GetDeviceProcAddr(device, "vkCopyImageToMemory"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCopyImageToImage =
        reinterpret_cast<PFN_vkCopyImageToImage>(instanceFuncs.GetDeviceProcAddr(device, "vkCopyImageToImage"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkTransitionImageLayout = reinterpret_cast<PFN_vkTransitionImageLayout>(
        instanceFuncs.GetDeviceProcAddr(device, "vkTransitionImageLayout"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkCreateVideoSessionKHR = reinterpret_cast<PFN_vkCreateVideoSessionKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateVideoSessionKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkDestroyVideoSessionKHR = reinterpret_cast<PFN_vkDestroyVideoSessionKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyVideoSessionKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkCreateVideoSessionParametersKHR = reinterpret_cast<PFN_vkCreateVideoSessionParametersKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateVideoSessionParametersKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkUpdateVideoSessionParametersKHR = reinterpret_cast<PFN_vkUpdateVideoSessionParametersKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkUpdateVideoSessionParametersKHR"));
#endif
#if defined(VK_KHR_video_encode_queue)
    table.vkGetEncodedVideoSessionParametersKHR = reinterpret_cast<PFN_vkGetEncodedVideoSessionParametersKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetEncodedVideoSessionParametersKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkDestroyVideoSessionParametersKHR = reinterpret_cast<PFN_vkDestroyVideoSessionParametersKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyVideoSessionParametersKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkGetVideoSessionMemoryRequirementsKHR = reinterpret_cast<PFN_vkGetVideoSessionMemoryRequirementsKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetVideoSessionMemoryRequirementsKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkBindVideoSessionMemoryKHR = reinterpret_cast<PFN_vkBindVideoSessionMemoryKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkBindVideoSessionMemoryKHR"));
#endif
#if defined(VK_KHR_video_decode_queue)
    table.vkCmdDecodeVideoKHR =
        reinterpret_cast<PFN_vkCmdDecodeVideoKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDecodeVideoKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkCmdBeginVideoCodingKHR = reinterpret_cast<PFN_vkCmdBeginVideoCodingKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginVideoCodingKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkCmdControlVideoCodingKHR = reinterpret_cast<PFN_vkCmdControlVideoCodingKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdControlVideoCodingKHR"));
#endif
#if defined(VK_KHR_video_queue)
    table.vkCmdEndVideoCodingKHR =
        reinterpret_cast<PFN_vkCmdEndVideoCodingKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndVideoCodingKHR"));
#endif
#if defined(VK_KHR_video_encode_queue)
    table.vkCmdEncodeVideoKHR =
        reinterpret_cast<PFN_vkCmdEncodeVideoKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdEncodeVideoKHR"));
#endif
#if defined(VK_NV_memory_decompression)
    table.vkCmdDecompressMemoryNV = reinterpret_cast<PFN_vkCmdDecompressMemoryNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDecompressMemoryNV"));
#endif
#if defined(VK_NV_memory_decompression)
    table.vkCmdDecompressMemoryIndirectCountNV = reinterpret_cast<PFN_vkCmdDecompressMemoryIndirectCountNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDecompressMemoryIndirectCountNV"));
#endif
#if defined(VK_NV_partitioned_acceleration_structure)
    table.vkGetPartitionedAccelerationStructuresBuildSizesNV =
        reinterpret_cast<PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetPartitionedAccelerationStructuresBuildSizesNV"));
#endif
#if defined(VK_NV_partitioned_acceleration_structure)
    table.vkCmdBuildPartitionedAccelerationStructuresNV =
        reinterpret_cast<PFN_vkCmdBuildPartitionedAccelerationStructuresNV>(
            instanceFuncs.GetDeviceProcAddr(device, "vkCmdBuildPartitionedAccelerationStructuresNV"));
#endif
#if defined(VK_NVX_binary_import)
    table.vkCreateCuModuleNVX =
        reinterpret_cast<PFN_vkCreateCuModuleNVX>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateCuModuleNVX"));
#endif
#if defined(VK_NVX_binary_import)
    table.vkCreateCuFunctionNVX =
        reinterpret_cast<PFN_vkCreateCuFunctionNVX>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateCuFunctionNVX"));
#endif
#if defined(VK_NVX_binary_import)
    table.vkDestroyCuModuleNVX =
        reinterpret_cast<PFN_vkDestroyCuModuleNVX>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyCuModuleNVX"));
#endif
#if defined(VK_NVX_binary_import)
    table.vkDestroyCuFunctionNVX =
        reinterpret_cast<PFN_vkDestroyCuFunctionNVX>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyCuFunctionNVX"));
#endif
#if defined(VK_NVX_binary_import)
    table.vkCmdCuLaunchKernelNVX =
        reinterpret_cast<PFN_vkCmdCuLaunchKernelNVX>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCuLaunchKernelNVX"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkGetDescriptorSetLayoutSizeEXT = reinterpret_cast<PFN_vkGetDescriptorSetLayoutSizeEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSizeEXT"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkGetDescriptorSetLayoutBindingOffsetEXT = reinterpret_cast<PFN_vkGetDescriptorSetLayoutBindingOffsetEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDescriptorSetLayoutBindingOffsetEXT"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkGetDescriptorEXT =
        reinterpret_cast<PFN_vkGetDescriptorEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkGetDescriptorEXT"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkCmdBindDescriptorBuffersEXT = reinterpret_cast<PFN_vkCmdBindDescriptorBuffersEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindDescriptorBuffersEXT"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkCmdSetDescriptorBufferOffsetsEXT = reinterpret_cast<PFN_vkCmdSetDescriptorBufferOffsetsEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDescriptorBufferOffsetsEXT"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkCmdBindDescriptorBufferEmbeddedSamplersEXT =
        reinterpret_cast<PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT>(
            instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkGetBufferOpaqueCaptureDescriptorDataEXT = reinterpret_cast<PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureDescriptorDataEXT"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkGetImageOpaqueCaptureDescriptorDataEXT = reinterpret_cast<PFN_vkGetImageOpaqueCaptureDescriptorDataEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageOpaqueCaptureDescriptorDataEXT"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkGetImageViewOpaqueCaptureDescriptorDataEXT =
        reinterpret_cast<PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetImageViewOpaqueCaptureDescriptorDataEXT"));
#endif
#if defined(VK_EXT_descriptor_buffer)
    table.vkGetSamplerOpaqueCaptureDescriptorDataEXT = reinterpret_cast<PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSamplerOpaqueCaptureDescriptorDataEXT"));
#endif
#if (defined(VK_EXT_descriptor_buffer) && (defined(VK_KHR_acceleration_structure) || defined(VK_NV_ray_tracing)))
    table.vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT =
        reinterpret_cast<PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT"));
#endif
#if defined(VK_EXT_pageable_device_local_memory)
    table.vkSetDeviceMemoryPriorityEXT = reinterpret_cast<PFN_vkSetDeviceMemoryPriorityEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkSetDeviceMemoryPriorityEXT"));
#endif
#if defined(VK_KHR_present_wait2)
    table.vkWaitForPresent2KHR =
        reinterpret_cast<PFN_vkWaitForPresent2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkWaitForPresent2KHR"));
#endif
#if defined(VK_KHR_present_wait)
    table.vkWaitForPresentKHR =
        reinterpret_cast<PFN_vkWaitForPresentKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkWaitForPresentKHR"));
#endif
#if defined(VK_FUCHSIA_buffer_collection)
    table.vkCreateBufferCollectionFUCHSIA = reinterpret_cast<PFN_vkCreateBufferCollectionFUCHSIA>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateBufferCollectionFUCHSIA"));
#endif
#if defined(VK_FUCHSIA_buffer_collection)
    table.vkSetBufferCollectionBufferConstraintsFUCHSIA =
        reinterpret_cast<PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA>(
            instanceFuncs.GetDeviceProcAddr(device, "vkSetBufferCollectionBufferConstraintsFUCHSIA"));
#endif
#if defined(VK_FUCHSIA_buffer_collection)
    table.vkSetBufferCollectionImageConstraintsFUCHSIA =
        reinterpret_cast<PFN_vkSetBufferCollectionImageConstraintsFUCHSIA>(
            instanceFuncs.GetDeviceProcAddr(device, "vkSetBufferCollectionImageConstraintsFUCHSIA"));
#endif
#if defined(VK_FUCHSIA_buffer_collection)
    table.vkDestroyBufferCollectionFUCHSIA = reinterpret_cast<PFN_vkDestroyBufferCollectionFUCHSIA>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyBufferCollectionFUCHSIA"));
#endif
#if defined(VK_FUCHSIA_buffer_collection)
    table.vkGetBufferCollectionPropertiesFUCHSIA = reinterpret_cast<PFN_vkGetBufferCollectionPropertiesFUCHSIA>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferCollectionPropertiesFUCHSIA"));
#endif
#if defined(VK_NV_cuda_kernel_launch)
    table.vkCreateCudaModuleNV =
        reinterpret_cast<PFN_vkCreateCudaModuleNV>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateCudaModuleNV"));
#endif
#if defined(VK_NV_cuda_kernel_launch)
    table.vkGetCudaModuleCacheNV =
        reinterpret_cast<PFN_vkGetCudaModuleCacheNV>(instanceFuncs.GetDeviceProcAddr(device, "vkGetCudaModuleCacheNV"));
#endif
#if defined(VK_NV_cuda_kernel_launch)
    table.vkCreateCudaFunctionNV =
        reinterpret_cast<PFN_vkCreateCudaFunctionNV>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateCudaFunctionNV"));
#endif
#if defined(VK_NV_cuda_kernel_launch)
    table.vkDestroyCudaModuleNV =
        reinterpret_cast<PFN_vkDestroyCudaModuleNV>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyCudaModuleNV"));
#endif
#if defined(VK_NV_cuda_kernel_launch)
    table.vkDestroyCudaFunctionNV = reinterpret_cast<PFN_vkDestroyCudaFunctionNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyCudaFunctionNV"));
#endif
#if defined(VK_NV_cuda_kernel_launch)
    table.vkCmdCudaLaunchKernelNV = reinterpret_cast<PFN_vkCmdCudaLaunchKernelNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCudaLaunchKernelNV"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdBeginRendering =
        reinterpret_cast<PFN_vkCmdBeginRendering>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginRendering"));
#endif
#if defined(VKIT_API_VERSION_1_3)
    table.vkCmdEndRendering =
        reinterpret_cast<PFN_vkCmdEndRendering>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndRendering"));
#endif
#if defined(VK_EXT_fragment_density_map_offset)
    table.vkCmdEndRendering2EXT =
        reinterpret_cast<PFN_vkCmdEndRendering2EXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndRendering2EXT"));
#endif
#if defined(VK_VALVE_descriptor_set_host_mapping)
    table.vkGetDescriptorSetLayoutHostMappingInfoVALVE =
        reinterpret_cast<PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetDescriptorSetLayoutHostMappingInfoVALVE"));
#endif
#if defined(VK_VALVE_descriptor_set_host_mapping)
    table.vkGetDescriptorSetHostMappingVALVE = reinterpret_cast<PFN_vkGetDescriptorSetHostMappingVALVE>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDescriptorSetHostMappingVALVE"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkCreateMicromapEXT =
        reinterpret_cast<PFN_vkCreateMicromapEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateMicromapEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkCmdBuildMicromapsEXT =
        reinterpret_cast<PFN_vkCmdBuildMicromapsEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBuildMicromapsEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkBuildMicromapsEXT =
        reinterpret_cast<PFN_vkBuildMicromapsEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkBuildMicromapsEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkDestroyMicromapEXT =
        reinterpret_cast<PFN_vkDestroyMicromapEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyMicromapEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkCmdCopyMicromapEXT =
        reinterpret_cast<PFN_vkCmdCopyMicromapEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyMicromapEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkCopyMicromapEXT =
        reinterpret_cast<PFN_vkCopyMicromapEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCopyMicromapEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkCmdCopyMicromapToMemoryEXT = reinterpret_cast<PFN_vkCmdCopyMicromapToMemoryEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyMicromapToMemoryEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkCopyMicromapToMemoryEXT = reinterpret_cast<PFN_vkCopyMicromapToMemoryEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCopyMicromapToMemoryEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkCmdCopyMemoryToMicromapEXT = reinterpret_cast<PFN_vkCmdCopyMemoryToMicromapEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyMemoryToMicromapEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkCopyMemoryToMicromapEXT = reinterpret_cast<PFN_vkCopyMemoryToMicromapEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCopyMemoryToMicromapEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkCmdWriteMicromapsPropertiesEXT = reinterpret_cast<PFN_vkCmdWriteMicromapsPropertiesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdWriteMicromapsPropertiesEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkWriteMicromapsPropertiesEXT = reinterpret_cast<PFN_vkWriteMicromapsPropertiesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkWriteMicromapsPropertiesEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkGetDeviceMicromapCompatibilityEXT = reinterpret_cast<PFN_vkGetDeviceMicromapCompatibilityEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceMicromapCompatibilityEXT"));
#endif
#if defined(VK_EXT_opacity_micromap)
    table.vkGetMicromapBuildSizesEXT = reinterpret_cast<PFN_vkGetMicromapBuildSizesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMicromapBuildSizesEXT"));
#endif
#if defined(VK_EXT_shader_module_identifier)
    table.vkGetShaderModuleIdentifierEXT = reinterpret_cast<PFN_vkGetShaderModuleIdentifierEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetShaderModuleIdentifierEXT"));
#endif
#if defined(VK_EXT_shader_module_identifier)
    table.vkGetShaderModuleCreateInfoIdentifierEXT = reinterpret_cast<PFN_vkGetShaderModuleCreateInfoIdentifierEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetShaderModuleCreateInfoIdentifierEXT"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkGetImageSubresourceLayout2 = reinterpret_cast<PFN_vkGetImageSubresourceLayout2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageSubresourceLayout2"));
#endif
#if defined(VK_EXT_pipeline_properties)
    table.vkGetPipelinePropertiesEXT = reinterpret_cast<PFN_vkGetPipelinePropertiesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetPipelinePropertiesEXT"));
#endif
#if defined(VK_EXT_metal_objects)
    table.vkExportMetalObjectsEXT = reinterpret_cast<PFN_vkExportMetalObjectsEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkExportMetalObjectsEXT"));
#endif
#if defined(VK_QCOM_tile_memory_heap)
    table.vkCmdBindTileMemoryQCOM = reinterpret_cast<PFN_vkCmdBindTileMemoryQCOM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindTileMemoryQCOM"));
#endif
#if defined(VK_QCOM_tile_properties)
    table.vkGetFramebufferTilePropertiesQCOM = reinterpret_cast<PFN_vkGetFramebufferTilePropertiesQCOM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetFramebufferTilePropertiesQCOM"));
#endif
#if defined(VK_QCOM_tile_properties)
    table.vkGetDynamicRenderingTilePropertiesQCOM = reinterpret_cast<PFN_vkGetDynamicRenderingTilePropertiesQCOM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDynamicRenderingTilePropertiesQCOM"));
#endif
#if defined(VK_NV_optical_flow)
    table.vkCreateOpticalFlowSessionNV = reinterpret_cast<PFN_vkCreateOpticalFlowSessionNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateOpticalFlowSessionNV"));
#endif
#if defined(VK_NV_optical_flow)
    table.vkDestroyOpticalFlowSessionNV = reinterpret_cast<PFN_vkDestroyOpticalFlowSessionNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyOpticalFlowSessionNV"));
#endif
#if defined(VK_NV_optical_flow)
    table.vkBindOpticalFlowSessionImageNV = reinterpret_cast<PFN_vkBindOpticalFlowSessionImageNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkBindOpticalFlowSessionImageNV"));
#endif
#if defined(VK_NV_optical_flow)
    table.vkCmdOpticalFlowExecuteNV = reinterpret_cast<PFN_vkCmdOpticalFlowExecuteNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdOpticalFlowExecuteNV"));
#endif
#if defined(VK_EXT_device_fault)
    table.vkGetDeviceFaultInfoEXT = reinterpret_cast<PFN_vkGetDeviceFaultInfoEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceFaultInfoEXT"));
#endif
#if defined(VK_EXT_depth_bias_control)
    table.vkCmdSetDepthBias2EXT =
        reinterpret_cast<PFN_vkCmdSetDepthBias2EXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthBias2EXT"));
#endif
#if defined(VK_KHR_swapchain_maintenance1)
    table.vkReleaseSwapchainImagesKHR = reinterpret_cast<PFN_vkReleaseSwapchainImagesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkReleaseSwapchainImagesKHR"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkGetDeviceImageSubresourceLayout = reinterpret_cast<PFN_vkGetDeviceImageSubresourceLayout>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceImageSubresourceLayout"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkMapMemory2 = reinterpret_cast<PFN_vkMapMemory2>(instanceFuncs.GetDeviceProcAddr(device, "vkMapMemory2"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkUnmapMemory2 =
        reinterpret_cast<PFN_vkUnmapMemory2>(instanceFuncs.GetDeviceProcAddr(device, "vkUnmapMemory2"));
#endif
#if defined(VK_EXT_shader_object)
    table.vkCreateShadersEXT =
        reinterpret_cast<PFN_vkCreateShadersEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateShadersEXT"));
#endif
#if defined(VK_EXT_shader_object)
    table.vkDestroyShaderEXT =
        reinterpret_cast<PFN_vkDestroyShaderEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyShaderEXT"));
#endif
#if defined(VK_EXT_shader_object)
    table.vkGetShaderBinaryDataEXT = reinterpret_cast<PFN_vkGetShaderBinaryDataEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetShaderBinaryDataEXT"));
#endif
#if defined(VK_EXT_shader_object)
    table.vkCmdBindShadersEXT =
        reinterpret_cast<PFN_vkCmdBindShadersEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindShadersEXT"));
#endif
#if defined(VK_QNX_external_memory_screen_buffer)
    table.vkGetScreenBufferPropertiesQNX = reinterpret_cast<PFN_vkGetScreenBufferPropertiesQNX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetScreenBufferPropertiesQNX"));
#endif
#if defined(VK_AMDX_shader_enqueue)
    table.vkGetExecutionGraphPipelineScratchSizeAMDX = reinterpret_cast<PFN_vkGetExecutionGraphPipelineScratchSizeAMDX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetExecutionGraphPipelineScratchSizeAMDX"));
#endif
#if defined(VK_AMDX_shader_enqueue)
    table.vkGetExecutionGraphPipelineNodeIndexAMDX = reinterpret_cast<PFN_vkGetExecutionGraphPipelineNodeIndexAMDX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetExecutionGraphPipelineNodeIndexAMDX"));
#endif
#if defined(VK_AMDX_shader_enqueue)
    table.vkCreateExecutionGraphPipelinesAMDX = reinterpret_cast<PFN_vkCreateExecutionGraphPipelinesAMDX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateExecutionGraphPipelinesAMDX"));
#endif
#if VK_HEADER_VERSION >= 298 && (defined(VK_AMDX_shader_enqueue))
    table.vkCmdInitializeGraphScratchMemoryAMDX = reinterpret_cast<PFN_vkCmdInitializeGraphScratchMemoryAMDX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdInitializeGraphScratchMemoryAMDX"));
#endif
#if VK_HEADER_VERSION >= 298 && (defined(VK_AMDX_shader_enqueue))
    table.vkCmdDispatchGraphAMDX =
        reinterpret_cast<PFN_vkCmdDispatchGraphAMDX>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDispatchGraphAMDX"));
#endif
#if VK_HEADER_VERSION >= 298 && (defined(VK_AMDX_shader_enqueue))
    table.vkCmdDispatchGraphIndirectAMDX = reinterpret_cast<PFN_vkCmdDispatchGraphIndirectAMDX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDispatchGraphIndirectAMDX"));
#endif
#if VK_HEADER_VERSION >= 298 && (defined(VK_AMDX_shader_enqueue))
    table.vkCmdDispatchGraphIndirectCountAMDX = reinterpret_cast<PFN_vkCmdDispatchGraphIndirectCountAMDX>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDispatchGraphIndirectCountAMDX"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdBindDescriptorSets2 = reinterpret_cast<PFN_vkCmdBindDescriptorSets2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindDescriptorSets2"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdPushConstants2 =
        reinterpret_cast<PFN_vkCmdPushConstants2>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushConstants2"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdPushDescriptorSet2 = reinterpret_cast<PFN_vkCmdPushDescriptorSet2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushDescriptorSet2"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdPushDescriptorSetWithTemplate2 = reinterpret_cast<PFN_vkCmdPushDescriptorSetWithTemplate2>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplate2"));
#endif
#if (defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer))
    table.vkCmdSetDescriptorBufferOffsets2EXT = reinterpret_cast<PFN_vkCmdSetDescriptorBufferOffsets2EXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDescriptorBufferOffsets2EXT"));
#endif
#if (defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer))
    table.vkCmdBindDescriptorBufferEmbeddedSamplers2EXT =
        reinterpret_cast<PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT>(
            instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT"));
#endif
#if defined(VK_NV_low_latency2)
    table.vkSetLatencySleepModeNV = reinterpret_cast<PFN_vkSetLatencySleepModeNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkSetLatencySleepModeNV"));
#endif
#if defined(VK_NV_low_latency2)
    table.vkLatencySleepNV =
        reinterpret_cast<PFN_vkLatencySleepNV>(instanceFuncs.GetDeviceProcAddr(device, "vkLatencySleepNV"));
#endif
#if defined(VK_NV_low_latency2)
    table.vkSetLatencyMarkerNV =
        reinterpret_cast<PFN_vkSetLatencyMarkerNV>(instanceFuncs.GetDeviceProcAddr(device, "vkSetLatencyMarkerNV"));
#endif
#if VK_HEADER_VERSION >= 271 && (defined(VK_NV_low_latency2))
    table.vkGetLatencyTimingsNV =
        reinterpret_cast<PFN_vkGetLatencyTimingsNV>(instanceFuncs.GetDeviceProcAddr(device, "vkGetLatencyTimingsNV"));
#endif
#if defined(VK_NV_low_latency2)
    table.vkQueueNotifyOutOfBandNV = reinterpret_cast<PFN_vkQueueNotifyOutOfBandNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkQueueNotifyOutOfBandNV"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdSetRenderingAttachmentLocations = reinterpret_cast<PFN_vkCmdSetRenderingAttachmentLocations>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRenderingAttachmentLocations"));
#endif
#if defined(VKIT_API_VERSION_1_4)
    table.vkCmdSetRenderingInputAttachmentIndices = reinterpret_cast<PFN_vkCmdSetRenderingInputAttachmentIndices>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRenderingInputAttachmentIndices"));
#endif
#if (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clamp_control)) || defined(VK_EXT_depth_clamp_control)
    table.vkCmdSetDepthClampRangeEXT = reinterpret_cast<PFN_vkCmdSetDepthClampRangeEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthClampRangeEXT"));
#endif
#if defined(VK_EXT_external_memory_metal)
    table.vkGetMemoryMetalHandleEXT = reinterpret_cast<PFN_vkGetMemoryMetalHandleEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryMetalHandleEXT"));
#endif
#if defined(VK_EXT_external_memory_metal)
    table.vkGetMemoryMetalHandlePropertiesEXT = reinterpret_cast<PFN_vkGetMemoryMetalHandlePropertiesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetMemoryMetalHandlePropertiesEXT"));
#endif
#if defined(VK_NV_cooperative_vector)
    table.vkConvertCooperativeVectorMatrixNV = reinterpret_cast<PFN_vkConvertCooperativeVectorMatrixNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkConvertCooperativeVectorMatrixNV"));
#endif
#if defined(VK_NV_cooperative_vector)
    table.vkCmdConvertCooperativeVectorMatrixNV = reinterpret_cast<PFN_vkCmdConvertCooperativeVectorMatrixNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdConvertCooperativeVectorMatrixNV"));
#endif
#if defined(VK_QCOM_tile_shading)
    table.vkCmdDispatchTileQCOM =
        reinterpret_cast<PFN_vkCmdDispatchTileQCOM>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDispatchTileQCOM"));
#endif
#if defined(VK_QCOM_tile_shading)
    table.vkCmdBeginPerTileExecutionQCOM = reinterpret_cast<PFN_vkCmdBeginPerTileExecutionQCOM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginPerTileExecutionQCOM"));
#endif
#if defined(VK_QCOM_tile_shading)
    table.vkCmdEndPerTileExecutionQCOM = reinterpret_cast<PFN_vkCmdEndPerTileExecutionQCOM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndPerTileExecutionQCOM"));
#endif
#if defined(VK_NV_external_compute_queue)
    table.vkCreateExternalComputeQueueNV = reinterpret_cast<PFN_vkCreateExternalComputeQueueNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateExternalComputeQueueNV"));
#endif
#if defined(VK_NV_external_compute_queue)
    table.vkDestroyExternalComputeQueueNV = reinterpret_cast<PFN_vkDestroyExternalComputeQueueNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyExternalComputeQueueNV"));
#endif
#if defined(VK_NV_external_compute_queue)
    table.vkGetExternalComputeQueueDataNV = reinterpret_cast<PFN_vkGetExternalComputeQueueDataNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetExternalComputeQueueDataNV"));
#endif
#if defined(VK_ARM_tensors)
    table.vkCreateTensorARM =
        reinterpret_cast<PFN_vkCreateTensorARM>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateTensorARM"));
#endif
#if defined(VK_ARM_tensors)
    table.vkDestroyTensorARM =
        reinterpret_cast<PFN_vkDestroyTensorARM>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyTensorARM"));
#endif
#if defined(VK_ARM_tensors)
    table.vkCreateTensorViewARM =
        reinterpret_cast<PFN_vkCreateTensorViewARM>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateTensorViewARM"));
#endif
#if defined(VK_ARM_tensors)
    table.vkDestroyTensorViewARM =
        reinterpret_cast<PFN_vkDestroyTensorViewARM>(instanceFuncs.GetDeviceProcAddr(device, "vkDestroyTensorViewARM"));
#endif
#if defined(VK_ARM_tensors)
    table.vkGetTensorMemoryRequirementsARM = reinterpret_cast<PFN_vkGetTensorMemoryRequirementsARM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetTensorMemoryRequirementsARM"));
#endif
#if defined(VK_ARM_tensors)
    table.vkBindTensorMemoryARM =
        reinterpret_cast<PFN_vkBindTensorMemoryARM>(instanceFuncs.GetDeviceProcAddr(device, "vkBindTensorMemoryARM"));
#endif
#if defined(VK_ARM_tensors)
    table.vkGetDeviceTensorMemoryRequirementsARM = reinterpret_cast<PFN_vkGetDeviceTensorMemoryRequirementsARM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceTensorMemoryRequirementsARM"));
#endif
#if defined(VK_ARM_tensors)
    table.vkCmdCopyTensorARM =
        reinterpret_cast<PFN_vkCmdCopyTensorARM>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyTensorARM"));
#endif
#if (defined(VK_ARM_tensors) && defined(VK_EXT_descriptor_buffer))
    table.vkGetTensorOpaqueCaptureDescriptorDataARM = reinterpret_cast<PFN_vkGetTensorOpaqueCaptureDescriptorDataARM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetTensorOpaqueCaptureDescriptorDataARM"));
#endif
#if (defined(VK_ARM_tensors) && defined(VK_EXT_descriptor_buffer))
    table.vkGetTensorViewOpaqueCaptureDescriptorDataARM =
        reinterpret_cast<PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetTensorViewOpaqueCaptureDescriptorDataARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkCreateDataGraphPipelinesARM = reinterpret_cast<PFN_vkCreateDataGraphPipelinesARM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateDataGraphPipelinesARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkCreateDataGraphPipelineSessionARM = reinterpret_cast<PFN_vkCreateDataGraphPipelineSessionARM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateDataGraphPipelineSessionARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkGetDataGraphPipelineSessionBindPointRequirementsARM =
        reinterpret_cast<PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetDataGraphPipelineSessionBindPointRequirementsARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkGetDataGraphPipelineSessionMemoryRequirementsARM =
        reinterpret_cast<PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetDataGraphPipelineSessionMemoryRequirementsARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkBindDataGraphPipelineSessionMemoryARM = reinterpret_cast<PFN_vkBindDataGraphPipelineSessionMemoryARM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkBindDataGraphPipelineSessionMemoryARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkDestroyDataGraphPipelineSessionARM = reinterpret_cast<PFN_vkDestroyDataGraphPipelineSessionARM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyDataGraphPipelineSessionARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkCmdDispatchDataGraphARM = reinterpret_cast<PFN_vkCmdDispatchDataGraphARM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDispatchDataGraphARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkGetDataGraphPipelineAvailablePropertiesARM =
        reinterpret_cast<PFN_vkGetDataGraphPipelineAvailablePropertiesARM>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetDataGraphPipelineAvailablePropertiesARM"));
#endif
#if defined(VK_ARM_data_graph)
    table.vkGetDataGraphPipelinePropertiesARM = reinterpret_cast<PFN_vkGetDataGraphPipelinePropertiesARM>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDataGraphPipelinePropertiesARM"));
#endif
#if defined(VK_EXT_host_query_reset)
    table.vkResetQueryPoolEXT =
        reinterpret_cast<PFN_vkResetQueryPoolEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkResetQueryPoolEXT"));
#endif
#if defined(VK_KHR_maintenance5)
    table.vkGetRenderingAreaGranularityKHR = reinterpret_cast<PFN_vkGetRenderingAreaGranularityKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetRenderingAreaGranularityKHR"));
#endif
#if defined(VK_KHR_push_descriptor)
    table.vkCmdPushDescriptorSetKHR = reinterpret_cast<PFN_vkCmdPushDescriptorSetKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushDescriptorSetKHR"));
#endif
#if defined(VK_KHR_maintenance1)
    table.vkTrimCommandPoolKHR =
        reinterpret_cast<PFN_vkTrimCommandPoolKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkTrimCommandPoolKHR"));
#endif
#if defined(VK_KHR_device_group)
    table.vkGetDeviceGroupPeerMemoryFeaturesKHR = reinterpret_cast<PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceGroupPeerMemoryFeaturesKHR"));
#endif
#if defined(VK_KHR_bind_memory2)
    table.vkBindBufferMemory2KHR =
        reinterpret_cast<PFN_vkBindBufferMemory2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkBindBufferMemory2KHR"));
#endif
#if defined(VK_KHR_bind_memory2)
    table.vkBindImageMemory2KHR =
        reinterpret_cast<PFN_vkBindImageMemory2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkBindImageMemory2KHR"));
#endif
#if defined(VK_KHR_device_group)
    table.vkCmdSetDeviceMaskKHR =
        reinterpret_cast<PFN_vkCmdSetDeviceMaskKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDeviceMaskKHR"));
#endif
#if defined(VK_KHR_device_group)
    table.vkCmdDispatchBaseKHR =
        reinterpret_cast<PFN_vkCmdDispatchBaseKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdDispatchBaseKHR"));
#endif
#if defined(VK_KHR_descriptor_update_template)
    table.vkCreateDescriptorUpdateTemplateKHR = reinterpret_cast<PFN_vkCreateDescriptorUpdateTemplateKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateDescriptorUpdateTemplateKHR"));
#endif
#if defined(VK_KHR_descriptor_update_template)
    table.vkDestroyDescriptorUpdateTemplateKHR = reinterpret_cast<PFN_vkDestroyDescriptorUpdateTemplateKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyDescriptorUpdateTemplateKHR"));
#endif
#if defined(VK_KHR_descriptor_update_template)
    table.vkUpdateDescriptorSetWithTemplateKHR = reinterpret_cast<PFN_vkUpdateDescriptorSetWithTemplateKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkUpdateDescriptorSetWithTemplateKHR"));
#endif
#if (defined(VK_KHR_push_descriptor) &&                                                                                \
     (defined(VKIT_API_VERSION_1_1) || defined(VK_KHR_descriptor_update_template))) ||                                 \
    (defined(VK_KHR_descriptor_update_template) && defined(VK_KHR_push_descriptor))
    table.vkCmdPushDescriptorSetWithTemplateKHR = reinterpret_cast<PFN_vkCmdPushDescriptorSetWithTemplateKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplateKHR"));
#endif
#if defined(VK_KHR_get_memory_requirements2)
    table.vkGetBufferMemoryRequirements2KHR = reinterpret_cast<PFN_vkGetBufferMemoryRequirements2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferMemoryRequirements2KHR"));
#endif
#if defined(VK_KHR_get_memory_requirements2)
    table.vkGetImageMemoryRequirements2KHR = reinterpret_cast<PFN_vkGetImageMemoryRequirements2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageMemoryRequirements2KHR"));
#endif
#if defined(VK_KHR_get_memory_requirements2)
    table.vkGetImageSparseMemoryRequirements2KHR = reinterpret_cast<PFN_vkGetImageSparseMemoryRequirements2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements2KHR"));
#endif
#if defined(VK_KHR_maintenance4)
    table.vkGetDeviceBufferMemoryRequirementsKHR = reinterpret_cast<PFN_vkGetDeviceBufferMemoryRequirementsKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceBufferMemoryRequirementsKHR"));
#endif
#if defined(VK_KHR_maintenance4)
    table.vkGetDeviceImageMemoryRequirementsKHR = reinterpret_cast<PFN_vkGetDeviceImageMemoryRequirementsKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceImageMemoryRequirementsKHR"));
#endif
#if defined(VK_KHR_maintenance4)
    table.vkGetDeviceImageSparseMemoryRequirementsKHR =
        reinterpret_cast<PFN_vkGetDeviceImageSparseMemoryRequirementsKHR>(
            instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceImageSparseMemoryRequirementsKHR"));
#endif
#if defined(VK_KHR_sampler_ycbcr_conversion)
    table.vkCreateSamplerYcbcrConversionKHR = reinterpret_cast<PFN_vkCreateSamplerYcbcrConversionKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreateSamplerYcbcrConversionKHR"));
#endif
#if defined(VK_KHR_sampler_ycbcr_conversion)
    table.vkDestroySamplerYcbcrConversionKHR = reinterpret_cast<PFN_vkDestroySamplerYcbcrConversionKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroySamplerYcbcrConversionKHR"));
#endif
#if defined(VK_KHR_maintenance3)
    table.vkGetDescriptorSetLayoutSupportKHR = reinterpret_cast<PFN_vkGetDescriptorSetLayoutSupportKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSupportKHR"));
#endif
#if defined(VK_EXT_calibrated_timestamps)
    table.vkGetCalibratedTimestampsEXT = reinterpret_cast<PFN_vkGetCalibratedTimestampsEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetCalibratedTimestampsEXT"));
#endif
#if defined(VK_KHR_create_renderpass2)
    table.vkCreateRenderPass2KHR =
        reinterpret_cast<PFN_vkCreateRenderPass2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCreateRenderPass2KHR"));
#endif
#if defined(VK_KHR_create_renderpass2)
    table.vkCmdBeginRenderPass2KHR = reinterpret_cast<PFN_vkCmdBeginRenderPass2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginRenderPass2KHR"));
#endif
#if defined(VK_KHR_create_renderpass2)
    table.vkCmdNextSubpass2KHR =
        reinterpret_cast<PFN_vkCmdNextSubpass2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdNextSubpass2KHR"));
#endif
#if defined(VK_KHR_create_renderpass2)
    table.vkCmdEndRenderPass2KHR =
        reinterpret_cast<PFN_vkCmdEndRenderPass2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndRenderPass2KHR"));
#endif
#if defined(VK_KHR_timeline_semaphore)
    table.vkGetSemaphoreCounterValueKHR = reinterpret_cast<PFN_vkGetSemaphoreCounterValueKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetSemaphoreCounterValueKHR"));
#endif
#if defined(VK_KHR_timeline_semaphore)
    table.vkWaitSemaphoresKHR =
        reinterpret_cast<PFN_vkWaitSemaphoresKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkWaitSemaphoresKHR"));
#endif
#if defined(VK_KHR_timeline_semaphore)
    table.vkSignalSemaphoreKHR =
        reinterpret_cast<PFN_vkSignalSemaphoreKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkSignalSemaphoreKHR"));
#endif
#if defined(VK_KHR_draw_indirect_count)
    table.vkCmdDrawIndirectCountKHR = reinterpret_cast<PFN_vkCmdDrawIndirectCountKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndirectCountKHR"));
#endif
#if defined(VK_AMD_draw_indirect_count)
    table.vkCmdDrawIndirectCountAMD = reinterpret_cast<PFN_vkCmdDrawIndirectCountAMD>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndirectCountAMD"));
#endif
#if defined(VK_KHR_draw_indirect_count)
    table.vkCmdDrawIndexedIndirectCountKHR = reinterpret_cast<PFN_vkCmdDrawIndexedIndirectCountKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCountKHR"));
#endif
#if defined(VK_AMD_draw_indirect_count)
    table.vkCmdDrawIndexedIndirectCountAMD = reinterpret_cast<PFN_vkCmdDrawIndexedIndirectCountAMD>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCountAMD"));
#endif
#if defined(VK_NV_ray_tracing)
    table.vkGetRayTracingShaderGroupHandlesNV = reinterpret_cast<PFN_vkGetRayTracingShaderGroupHandlesNV>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetRayTracingShaderGroupHandlesNV"));
#endif
#if defined(VK_KHR_buffer_device_address)
    table.vkGetBufferOpaqueCaptureAddressKHR = reinterpret_cast<PFN_vkGetBufferOpaqueCaptureAddressKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureAddressKHR"));
#endif
#if defined(VK_KHR_buffer_device_address)
    table.vkGetBufferDeviceAddressKHR = reinterpret_cast<PFN_vkGetBufferDeviceAddressKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferDeviceAddressKHR"));
#endif
#if defined(VK_EXT_buffer_device_address)
    table.vkGetBufferDeviceAddressEXT = reinterpret_cast<PFN_vkGetBufferDeviceAddressEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetBufferDeviceAddressEXT"));
#endif
#if defined(VK_KHR_buffer_device_address)
    table.vkGetDeviceMemoryOpaqueCaptureAddressKHR = reinterpret_cast<PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceMemoryOpaqueCaptureAddressKHR"));
#endif
#if defined(VK_KHR_line_rasterization)
    table.vkCmdSetLineStippleKHR =
        reinterpret_cast<PFN_vkCmdSetLineStippleKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetLineStippleKHR"));
#endif
#if defined(VK_EXT_line_rasterization)
    table.vkCmdSetLineStippleEXT =
        reinterpret_cast<PFN_vkCmdSetLineStippleEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetLineStippleEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetCullModeEXT =
        reinterpret_cast<PFN_vkCmdSetCullModeEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetCullModeEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetFrontFaceEXT =
        reinterpret_cast<PFN_vkCmdSetFrontFaceEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetFrontFaceEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetPrimitiveTopologyEXT = reinterpret_cast<PFN_vkCmdSetPrimitiveTopologyEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetPrimitiveTopologyEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetViewportWithCountEXT = reinterpret_cast<PFN_vkCmdSetViewportWithCountEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetViewportWithCountEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetScissorWithCountEXT = reinterpret_cast<PFN_vkCmdSetScissorWithCountEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetScissorWithCountEXT"));
#endif
#if defined(VK_KHR_maintenance5)
    table.vkCmdBindIndexBuffer2KHR = reinterpret_cast<PFN_vkCmdBindIndexBuffer2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindIndexBuffer2KHR"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdBindVertexBuffers2EXT = reinterpret_cast<PFN_vkCmdBindVertexBuffers2EXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindVertexBuffers2EXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetDepthTestEnableEXT = reinterpret_cast<PFN_vkCmdSetDepthTestEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthTestEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetDepthWriteEnableEXT = reinterpret_cast<PFN_vkCmdSetDepthWriteEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthWriteEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetDepthCompareOpEXT = reinterpret_cast<PFN_vkCmdSetDepthCompareOpEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthCompareOpEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetDepthBoundsTestEnableEXT = reinterpret_cast<PFN_vkCmdSetDepthBoundsTestEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthBoundsTestEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetStencilTestEnableEXT = reinterpret_cast<PFN_vkCmdSetStencilTestEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetStencilTestEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
    table.vkCmdSetStencilOpEXT =
        reinterpret_cast<PFN_vkCmdSetStencilOpEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetStencilOpEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
    table.vkCmdSetRasterizerDiscardEnableEXT = reinterpret_cast<PFN_vkCmdSetRasterizerDiscardEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRasterizerDiscardEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
    table.vkCmdSetDepthBiasEnableEXT = reinterpret_cast<PFN_vkCmdSetDepthBiasEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetDepthBiasEnableEXT"));
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
    table.vkCmdSetPrimitiveRestartEnableEXT = reinterpret_cast<PFN_vkCmdSetPrimitiveRestartEnableEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetPrimitiveRestartEnableEXT"));
#endif
#if defined(VK_EXT_private_data)
    table.vkCreatePrivateDataSlotEXT = reinterpret_cast<PFN_vkCreatePrivateDataSlotEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCreatePrivateDataSlotEXT"));
#endif
#if defined(VK_EXT_private_data)
    table.vkDestroyPrivateDataSlotEXT = reinterpret_cast<PFN_vkDestroyPrivateDataSlotEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkDestroyPrivateDataSlotEXT"));
#endif
#if defined(VK_EXT_private_data)
    table.vkSetPrivateDataEXT =
        reinterpret_cast<PFN_vkSetPrivateDataEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkSetPrivateDataEXT"));
#endif
#if defined(VK_EXT_private_data)
    table.vkGetPrivateDataEXT =
        reinterpret_cast<PFN_vkGetPrivateDataEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkGetPrivateDataEXT"));
#endif
#if defined(VK_KHR_copy_commands2)
    table.vkCmdCopyBuffer2KHR =
        reinterpret_cast<PFN_vkCmdCopyBuffer2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyBuffer2KHR"));
#endif
#if defined(VK_KHR_copy_commands2)
    table.vkCmdCopyImage2KHR =
        reinterpret_cast<PFN_vkCmdCopyImage2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyImage2KHR"));
#endif
#if defined(VK_KHR_copy_commands2)
    table.vkCmdBlitImage2KHR =
        reinterpret_cast<PFN_vkCmdBlitImage2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBlitImage2KHR"));
#endif
#if defined(VK_KHR_copy_commands2)
    table.vkCmdCopyBufferToImage2KHR = reinterpret_cast<PFN_vkCmdCopyBufferToImage2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyBufferToImage2KHR"));
#endif
#if defined(VK_KHR_copy_commands2)
    table.vkCmdCopyImageToBuffer2KHR = reinterpret_cast<PFN_vkCmdCopyImageToBuffer2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdCopyImageToBuffer2KHR"));
#endif
#if defined(VK_KHR_copy_commands2)
    table.vkCmdResolveImage2KHR =
        reinterpret_cast<PFN_vkCmdResolveImage2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdResolveImage2KHR"));
#endif
#if defined(VK_KHR_synchronization2)
    table.vkCmdSetEvent2KHR =
        reinterpret_cast<PFN_vkCmdSetEvent2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetEvent2KHR"));
#endif
#if defined(VK_KHR_synchronization2)
    table.vkCmdResetEvent2KHR =
        reinterpret_cast<PFN_vkCmdResetEvent2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdResetEvent2KHR"));
#endif
#if defined(VK_KHR_synchronization2)
    table.vkCmdWaitEvents2KHR =
        reinterpret_cast<PFN_vkCmdWaitEvents2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdWaitEvents2KHR"));
#endif
#if defined(VK_KHR_synchronization2)
    table.vkCmdPipelineBarrier2KHR = reinterpret_cast<PFN_vkCmdPipelineBarrier2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPipelineBarrier2KHR"));
#endif
#if defined(VK_KHR_synchronization2)
    table.vkQueueSubmit2KHR =
        reinterpret_cast<PFN_vkQueueSubmit2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkQueueSubmit2KHR"));
#endif
#if defined(VK_KHR_synchronization2)
    table.vkCmdWriteTimestamp2KHR = reinterpret_cast<PFN_vkCmdWriteTimestamp2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdWriteTimestamp2KHR"));
#endif
#if defined(VK_EXT_host_image_copy)
    table.vkCopyMemoryToImageEXT =
        reinterpret_cast<PFN_vkCopyMemoryToImageEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCopyMemoryToImageEXT"));
#endif
#if defined(VK_EXT_host_image_copy)
    table.vkCopyImageToMemoryEXT =
        reinterpret_cast<PFN_vkCopyImageToMemoryEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCopyImageToMemoryEXT"));
#endif
#if defined(VK_EXT_host_image_copy)
    table.vkCopyImageToImageEXT =
        reinterpret_cast<PFN_vkCopyImageToImageEXT>(instanceFuncs.GetDeviceProcAddr(device, "vkCopyImageToImageEXT"));
#endif
#if defined(VK_EXT_host_image_copy)
    table.vkTransitionImageLayoutEXT = reinterpret_cast<PFN_vkTransitionImageLayoutEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkTransitionImageLayoutEXT"));
#endif
#if defined(VK_KHR_dynamic_rendering)
    table.vkCmdBeginRenderingKHR =
        reinterpret_cast<PFN_vkCmdBeginRenderingKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdBeginRenderingKHR"));
#endif
#if defined(VK_KHR_dynamic_rendering)
    table.vkCmdEndRenderingKHR =
        reinterpret_cast<PFN_vkCmdEndRenderingKHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdEndRenderingKHR"));
#endif
#if defined(VK_KHR_maintenance5)
    table.vkGetImageSubresourceLayout2KHR = reinterpret_cast<PFN_vkGetImageSubresourceLayout2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageSubresourceLayout2KHR"));
#endif
#if defined(VK_EXT_host_image_copy) || defined(VK_EXT_image_compression_control)
    table.vkGetImageSubresourceLayout2EXT = reinterpret_cast<PFN_vkGetImageSubresourceLayout2EXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetImageSubresourceLayout2EXT"));
#endif
#if defined(VK_EXT_swapchain_maintenance1)
    table.vkReleaseSwapchainImagesEXT = reinterpret_cast<PFN_vkReleaseSwapchainImagesEXT>(
        instanceFuncs.GetDeviceProcAddr(device, "vkReleaseSwapchainImagesEXT"));
#endif
#if defined(VK_KHR_maintenance5)
    table.vkGetDeviceImageSubresourceLayoutKHR = reinterpret_cast<PFN_vkGetDeviceImageSubresourceLayoutKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkGetDeviceImageSubresourceLayoutKHR"));
#endif
#if defined(VK_KHR_map_memory2)
    table.vkMapMemory2KHR =
        reinterpret_cast<PFN_vkMapMemory2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkMapMemory2KHR"));
#endif
#if defined(VK_KHR_map_memory2)
    table.vkUnmapMemory2KHR =
        reinterpret_cast<PFN_vkUnmapMemory2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkUnmapMemory2KHR"));
#endif
#if defined(VK_KHR_maintenance6)
    table.vkCmdBindDescriptorSets2KHR = reinterpret_cast<PFN_vkCmdBindDescriptorSets2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdBindDescriptorSets2KHR"));
#endif
#if defined(VK_KHR_maintenance6)
    table.vkCmdPushConstants2KHR =
        reinterpret_cast<PFN_vkCmdPushConstants2KHR>(instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushConstants2KHR"));
#endif
#if (defined(VK_KHR_maintenance6) && defined(VK_KHR_push_descriptor))
    table.vkCmdPushDescriptorSet2KHR = reinterpret_cast<PFN_vkCmdPushDescriptorSet2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushDescriptorSet2KHR"));
#endif
#if (defined(VK_KHR_maintenance6) && defined(VK_KHR_push_descriptor))
    table.vkCmdPushDescriptorSetWithTemplate2KHR = reinterpret_cast<PFN_vkCmdPushDescriptorSetWithTemplate2KHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplate2KHR"));
#endif
#if defined(VK_KHR_dynamic_rendering_local_read)
    table.vkCmdSetRenderingAttachmentLocationsKHR = reinterpret_cast<PFN_vkCmdSetRenderingAttachmentLocationsKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRenderingAttachmentLocationsKHR"));
#endif
#if defined(VK_KHR_dynamic_rendering_local_read)
    table.vkCmdSetRenderingInputAttachmentIndicesKHR = reinterpret_cast<PFN_vkCmdSetRenderingInputAttachmentIndicesKHR>(
        instanceFuncs.GetDeviceProcAddr(device, "vkCmdSetRenderingInputAttachmentIndicesKHR"));
#endif
    return table;
}

#if defined(VKIT_API_VERSION_1_0)
void InstanceTable::DestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyInstance,
                "[VULKIT][LOADER] The function 'vkDestroyInstance' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyInstance(instance, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult InstanceTable::EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount,
                                                 VkPhysicalDevice *pPhysicalDevices) const
{
    TKIT_ASSERT(this->vkEnumeratePhysicalDevices,
                "[VULKIT][LOADER] The function 'vkEnumeratePhysicalDevices' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
PFN_vkVoidFunction InstanceTable::GetDeviceProcAddr(VkDevice device, const char *pName) const
{
    TKIT_ASSERT(this->vkGetDeviceProcAddr,
                "[VULKIT][LOADER] The function 'vkGetDeviceProcAddr' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetDeviceProcAddr(device, pName);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void InstanceTable::GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice,
                                                VkPhysicalDeviceProperties *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceProperties' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceProperties(physicalDevice, pProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void InstanceTable::GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice,
                                                           uint32_t *pQueueFamilyPropertyCount,
                                                           VkQueueFamilyProperties *pQueueFamilyProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceQueueFamilyProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceQueueFamilyProperties' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void InstanceTable::GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice,
                                                      VkPhysicalDeviceMemoryProperties *pMemoryProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceMemoryProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceMemoryProperties' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void InstanceTable::GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice,
                                              VkPhysicalDeviceFeatures *pFeatures) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceFeatures,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceFeatures' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void InstanceTable::GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format,
                                                      VkFormatProperties *pFormatProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceFormatProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceFormatProperties' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult InstanceTable::GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format,
                                                               VkImageType type, VkImageTiling tiling,
                                                               VkImageUsageFlags usage, VkImageCreateFlags flags,
                                                               VkImageFormatProperties *pImageFormatProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceImageFormatProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceImageFormatProperties' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags,
                                                          pImageFormatProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult InstanceTable::CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo,
                                     const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) const
{
    TKIT_ASSERT(this->vkCreateDevice,
                "[VULKIT][LOADER] The function 'vkCreateDevice' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult InstanceTable::EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount,
                                                       VkLayerProperties *pProperties) const
{
    TKIT_ASSERT(this->vkEnumerateDeviceLayerProperties,
                "[VULKIT][LOADER] The function 'vkEnumerateDeviceLayerProperties' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkEnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult InstanceTable::EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName,
                                                           uint32_t *pPropertyCount,
                                                           VkExtensionProperties *pProperties) const
{
    TKIT_ASSERT(this->vkEnumerateDeviceExtensionProperties,
                "[VULKIT][LOADER] The function 'vkEnumerateDeviceExtensionProperties' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void InstanceTable::GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format,
                                                                 VkImageType type, VkSampleCountFlagBits samples,
                                                                 VkImageUsageFlags usage, VkImageTiling tiling,
                                                                 uint32_t *pPropertyCount,
                                                                 VkSparseImageFormatProperties *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSparseImageFormatProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSparseImageFormatProperties' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling,
                                                         pPropertyCount, pProperties);
}
#endif
#if defined(VK_KHR_android_surface)
VkResult InstanceTable::CreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR *pCreateInfo,
                                                const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateAndroidSurfaceKHR,
                "[VULKIT][LOADER] The function 'vkCreateAndroidSurfaceKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_OHOS_surface)
VkResult InstanceTable::CreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS *pCreateInfo,
                                          const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateSurfaceOHOS,
                "[VULKIT][LOADER] The function 'vkCreateSurfaceOHOS' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateSurfaceOHOS(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_KHR_display)
VkResult InstanceTable::GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount,
                                                              VkDisplayPropertiesKHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceDisplayPropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceDisplayPropertiesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
}
#endif
#if defined(VK_KHR_display)
VkResult InstanceTable::GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice,
                                                                   uint32_t *pPropertyCount,
                                                                   VkDisplayPlanePropertiesKHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceDisplayPlanePropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceDisplayPlanePropertiesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties);
}
#endif
#if defined(VK_KHR_display)
VkResult InstanceTable::GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex,
                                                            uint32_t *pDisplayCount, VkDisplayKHR *pDisplays) const
{
    TKIT_ASSERT(this->vkGetDisplayPlaneSupportedDisplaysKHR,
                "[VULKIT][LOADER] The function 'vkGetDisplayPlaneSupportedDisplaysKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays);
}
#endif
#if defined(VK_KHR_display)
VkResult InstanceTable::GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                    uint32_t *pPropertyCount,
                                                    VkDisplayModePropertiesKHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetDisplayModePropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetDisplayModePropertiesKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties);
}
#endif
#if defined(VK_KHR_display)
VkResult InstanceTable::CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                             const VkDisplayModeCreateInfoKHR *pCreateInfo,
                                             const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode) const
{
    TKIT_ASSERT(this->vkCreateDisplayModeKHR,
                "[VULKIT][LOADER] The function 'vkCreateDisplayModeKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode);
}
#endif
#if defined(VK_KHR_display)
VkResult InstanceTable::GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode,
                                                       uint32_t planeIndex,
                                                       VkDisplayPlaneCapabilitiesKHR *pCapabilities) const
{
    TKIT_ASSERT(this->vkGetDisplayPlaneCapabilitiesKHR,
                "[VULKIT][LOADER] The function 'vkGetDisplayPlaneCapabilitiesKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities);
}
#endif
#if defined(VK_KHR_display)
VkResult InstanceTable::CreateDisplayPlaneSurfaceKHR(VkInstance instance,
                                                     const VkDisplaySurfaceCreateInfoKHR *pCreateInfo,
                                                     const VkAllocationCallbacks *pAllocator,
                                                     VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateDisplayPlaneSurfaceKHR,
                "[VULKIT][LOADER] The function 'vkCreateDisplayPlaneSurfaceKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_KHR_surface)
void InstanceTable::DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface,
                                      const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroySurfaceKHR,
                "[VULKIT][LOADER] The function 'vkDestroySurfaceKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroySurfaceKHR(instance, surface, pAllocator);
}
#endif
#if defined(VK_KHR_surface)
VkResult InstanceTable::GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex,
                                                           VkSurfaceKHR surface, VkBool32 *pSupported) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSurfaceSupportKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSurfaceSupportKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported);
}
#endif
#if defined(VK_KHR_surface)
VkResult InstanceTable::GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                                VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSurfaceCapabilitiesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities);
}
#endif
#if defined(VK_KHR_surface)
VkResult InstanceTable::GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                           uint32_t *pSurfaceFormatCount,
                                                           VkSurfaceFormatKHR *pSurfaceFormats) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSurfaceFormatsKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSurfaceFormatsKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
}
#endif
#if defined(VK_KHR_surface)
VkResult InstanceTable::GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                                uint32_t *pPresentModeCount,
                                                                VkPresentModeKHR *pPresentModes) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSurfacePresentModesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSurfacePresentModesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes);
}
#endif
#if defined(VK_NN_vi_surface)
VkResult InstanceTable::CreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN *pCreateInfo,
                                          const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateViSurfaceNN,
                "[VULKIT][LOADER] The function 'vkCreateViSurfaceNN' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_KHR_wayland_surface)
VkResult InstanceTable::CreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR *pCreateInfo,
                                                const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateWaylandSurfaceKHR,
                "[VULKIT][LOADER] The function 'vkCreateWaylandSurfaceKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_KHR_wayland_surface)
VkBool32 InstanceTable::GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                       uint32_t queueFamilyIndex,
                                                                       struct wl_display *display) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceWaylandPresentationSupportKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceWaylandPresentationSupportKHR' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display);
}
#endif
#if defined(VK_KHR_win32_surface)
VkResult InstanceTable::CreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR *pCreateInfo,
                                              const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateWin32SurfaceKHR,
                "[VULKIT][LOADER] The function 'vkCreateWin32SurfaceKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_KHR_win32_surface)
VkBool32 InstanceTable::GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                     uint32_t queueFamilyIndex) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceWin32PresentationSupportKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceWin32PresentationSupportKHR' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex);
}
#endif
#if defined(VK_KHR_xlib_surface)
VkResult InstanceTable::CreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR *pCreateInfo,
                                             const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateXlibSurfaceKHR,
                "[VULKIT][LOADER] The function 'vkCreateXlibSurfaceKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_KHR_xlib_surface)
VkBool32 InstanceTable::GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                    uint32_t queueFamilyIndex, Display *dpy,
                                                                    VisualID visualID) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceXlibPresentationSupportKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceXlibPresentationSupportKHR' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID);
}
#endif
#if defined(VK_KHR_xcb_surface)
VkResult InstanceTable::CreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR *pCreateInfo,
                                            const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateXcbSurfaceKHR,
                "[VULKIT][LOADER] The function 'vkCreateXcbSurfaceKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_KHR_xcb_surface)
VkBool32 InstanceTable::GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice,
                                                                   uint32_t queueFamilyIndex,
                                                                   xcb_connection_t *connection,
                                                                   xcb_visualid_t visual_id) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceXcbPresentationSupportKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceXcbPresentationSupportKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id);
}
#endif
#if defined(VK_EXT_directfb_surface)
VkResult InstanceTable::CreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT *pCreateInfo,
                                                 const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateDirectFBSurfaceEXT,
                "[VULKIT][LOADER] The function 'vkCreateDirectFBSurfaceEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDirectFBSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_EXT_directfb_surface)
VkBool32 InstanceTable::GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice,
                                                                        uint32_t queueFamilyIndex, IDirectFB *dfb) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceDirectFBPresentationSupportEXT,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceDirectFBPresentationSupportEXT' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceDirectFBPresentationSupportEXT(physicalDevice, queueFamilyIndex, dfb);
}
#endif
#if defined(VK_FUCHSIA_imagepipe_surface)
VkResult InstanceTable::CreateImagePipeSurfaceFUCHSIA(VkInstance instance,
                                                      const VkImagePipeSurfaceCreateInfoFUCHSIA *pCreateInfo,
                                                      const VkAllocationCallbacks *pAllocator,
                                                      VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateImagePipeSurfaceFUCHSIA,
                "[VULKIT][LOADER] The function 'vkCreateImagePipeSurfaceFUCHSIA' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_GGP_stream_descriptor_surface)
VkResult InstanceTable::CreateStreamDescriptorSurfaceGGP(VkInstance instance,
                                                         const VkStreamDescriptorSurfaceCreateInfoGGP *pCreateInfo,
                                                         const VkAllocationCallbacks *pAllocator,
                                                         VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateStreamDescriptorSurfaceGGP,
                "[VULKIT][LOADER] The function 'vkCreateStreamDescriptorSurfaceGGP' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkCreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_QNX_screen_surface)
VkResult InstanceTable::CreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX *pCreateInfo,
                                               const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateScreenSurfaceQNX,
                "[VULKIT][LOADER] The function 'vkCreateScreenSurfaceQNX' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateScreenSurfaceQNX(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_QNX_screen_surface)
VkBool32 InstanceTable::GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice,
                                                                      uint32_t queueFamilyIndex,
                                                                      struct _screen_window *window) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceScreenPresentationSupportQNX,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceScreenPresentationSupportQNX' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceScreenPresentationSupportQNX(physicalDevice, queueFamilyIndex, window);
}
#endif
#if defined(VK_EXT_debug_report)
VkResult InstanceTable::CreateDebugReportCallbackEXT(VkInstance instance,
                                                     const VkDebugReportCallbackCreateInfoEXT *pCreateInfo,
                                                     const VkAllocationCallbacks *pAllocator,
                                                     VkDebugReportCallbackEXT *pCallback) const
{
    TKIT_ASSERT(this->vkCreateDebugReportCallbackEXT,
                "[VULKIT][LOADER] The function 'vkCreateDebugReportCallbackEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback);
}
#endif
#if defined(VK_EXT_debug_report)
void InstanceTable::DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback,
                                                  const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyDebugReportCallbackEXT,
                "[VULKIT][LOADER] The function 'vkDestroyDebugReportCallbackEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator);
}
#endif
#if defined(VK_EXT_debug_report)
void InstanceTable::DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags,
                                          VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location,
                                          int32_t messageCode, const char *pLayerPrefix, const char *pMessage) const
{
    TKIT_ASSERT(this->vkDebugReportMessageEXT,
                "[VULKIT][LOADER] The function 'vkDebugReportMessageEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
}
#endif
#if defined(VK_NV_external_memory_capabilities)
VkResult InstanceTable::GetPhysicalDeviceExternalImageFormatPropertiesNV(
    VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage,
    VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType,
    VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceExternalImageFormatPropertiesNV,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags,
                                                                    externalHandleType, pExternalImageFormatProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void InstanceTable::GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice,
                                               VkPhysicalDeviceFeatures2 *pFeatures) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceFeatures2,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceFeatures2' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void InstanceTable::GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice,
                                                 VkPhysicalDeviceProperties2 *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceProperties2,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceProperties2' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceProperties2(physicalDevice, pProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void InstanceTable::GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format,
                                                       VkFormatProperties2 *pFormatProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceFormatProperties2,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceFormatProperties2' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
VkResult InstanceTable::GetPhysicalDeviceImageFormatProperties2(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo,
    VkImageFormatProperties2 *pImageFormatProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceImageFormatProperties2,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceImageFormatProperties2' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void InstanceTable::GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice,
                                                            uint32_t *pQueueFamilyPropertyCount,
                                                            VkQueueFamilyProperties2 *pQueueFamilyProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceQueueFamilyProperties2,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceQueueFamilyProperties2' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void InstanceTable::GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice,
                                                       VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceMemoryProperties2,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceMemoryProperties2' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void InstanceTable::GetPhysicalDeviceSparseImageFormatProperties2(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo,
    uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSparseImageFormatProperties2,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSparseImageFormatProperties2' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void InstanceTable::GetPhysicalDeviceExternalBufferProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo,
    VkExternalBufferProperties *pExternalBufferProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceExternalBufferProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceExternalBufferProperties' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
}
#endif
#if defined(VK_NV_external_memory_sci_buf)
VkResult InstanceTable::GetPhysicalDeviceExternalMemorySciBufPropertiesNV(
    VkPhysicalDevice physicalDevice, VkExternalMemoryHandleTypeFlagBits handleType, NvSciBufObj handle,
    VkMemorySciBufPropertiesNV *pMemorySciBufProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceExternalMemorySciBufPropertiesNV(physicalDevice, handleType, handle,
                                                                     pMemorySciBufProperties);
}
#endif
#if defined(VK_NV_external_memory_sci_buf)
VkResult InstanceTable::GetPhysicalDeviceSciBufAttributesNV(VkPhysicalDevice physicalDevice,
                                                            NvSciBufAttrList pAttributes) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSciBufAttributesNV,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSciBufAttributesNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSciBufAttributesNV(physicalDevice, pAttributes);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void InstanceTable::GetPhysicalDeviceExternalSemaphoreProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo,
    VkExternalSemaphoreProperties *pExternalSemaphoreProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceExternalSemaphoreProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceExternalSemaphoreProperties' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo,
                                                         pExternalSemaphoreProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void InstanceTable::GetPhysicalDeviceExternalFenceProperties(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo,
    VkExternalFenceProperties *pExternalFenceProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceExternalFenceProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceExternalFenceProperties' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
VkResult InstanceTable::GetPhysicalDeviceSciSyncAttributesNV(VkPhysicalDevice physicalDevice,
                                                             const VkSciSyncAttributesInfoNV *pSciSyncAttributesInfo,
                                                             NvSciSyncAttrList pAttributes) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSciSyncAttributesNV,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSciSyncAttributesNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSciSyncAttributesNV(physicalDevice, pSciSyncAttributesInfo, pAttributes);
}
#endif
#if defined(VK_EXT_direct_mode_display)
VkResult InstanceTable::ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const
{
    TKIT_ASSERT(this->vkReleaseDisplayEXT,
                "[VULKIT][LOADER] The function 'vkReleaseDisplayEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkReleaseDisplayEXT(physicalDevice, display);
}
#endif
#if defined(VK_EXT_acquire_xlib_display)
VkResult InstanceTable::AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, VkDisplayKHR display) const
{
    TKIT_ASSERT(this->vkAcquireXlibDisplayEXT,
                "[VULKIT][LOADER] The function 'vkAcquireXlibDisplayEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkAcquireXlibDisplayEXT(physicalDevice, dpy, display);
}
#endif
#if defined(VK_EXT_acquire_xlib_display)
VkResult InstanceTable::GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, RROutput rrOutput,
                                                 VkDisplayKHR *pDisplay) const
{
    TKIT_ASSERT(this->vkGetRandROutputDisplayEXT,
                "[VULKIT][LOADER] The function 'vkGetRandROutputDisplayEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay);
}
#endif
#if defined(VK_NV_acquire_winrt_display)
VkResult InstanceTable::AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) const
{
    TKIT_ASSERT(this->vkAcquireWinrtDisplayNV,
                "[VULKIT][LOADER] The function 'vkAcquireWinrtDisplayNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkAcquireWinrtDisplayNV(physicalDevice, display);
}
#endif
#if defined(VK_NV_acquire_winrt_display)
VkResult InstanceTable::GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId,
                                          VkDisplayKHR *pDisplay) const
{
    TKIT_ASSERT(this->vkGetWinrtDisplayNV,
                "[VULKIT][LOADER] The function 'vkGetWinrtDisplayNV' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetWinrtDisplayNV(physicalDevice, deviceRelativeId, pDisplay);
}
#endif
#if defined(VK_EXT_display_surface_counter)
VkResult InstanceTable::GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                                 VkSurfaceCapabilities2EXT *pSurfaceCapabilities) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSurfaceCapabilities2EXT,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSurfaceCapabilities2EXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
VkResult InstanceTable::EnumeratePhysicalDeviceGroups(
    VkInstance instance, uint32_t *pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) const
{
    TKIT_ASSERT(this->vkEnumeratePhysicalDeviceGroups,
                "[VULKIT][LOADER] The function 'vkEnumeratePhysicalDeviceGroups' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
}
#endif
#if (defined(VK_KHR_swapchain) && defined(VKIT_API_VERSION_1_1)) ||                                                    \
    (defined(VK_KHR_device_group) && defined(VK_KHR_surface))
VkResult InstanceTable::GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface,
                                                              uint32_t *pRectCount, VkRect2D *pRects) const
{
    TKIT_ASSERT(this->vkGetPhysicalDevicePresentRectanglesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDevicePresentRectanglesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects);
}
#endif
#if defined(VK_MVK_ios_surface)
VkResult InstanceTable::CreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK *pCreateInfo,
                                            const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateIOSSurfaceMVK,
                "[VULKIT][LOADER] The function 'vkCreateIOSSurfaceMVK' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_MVK_macos_surface)
VkResult InstanceTable::CreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo,
                                              const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateMacOSSurfaceMVK,
                "[VULKIT][LOADER] The function 'vkCreateMacOSSurfaceMVK' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_EXT_metal_surface)
VkResult InstanceTable::CreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo,
                                              const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateMetalSurfaceEXT,
                "[VULKIT][LOADER] The function 'vkCreateMetalSurfaceEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_EXT_sample_locations)
void InstanceTable::GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice,
                                                              VkSampleCountFlagBits samples,
                                                              VkMultisamplePropertiesEXT *pMultisampleProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceMultisamplePropertiesEXT,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceMultisamplePropertiesEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties);
}
#endif
#if defined(VK_KHR_get_surface_capabilities2)
VkResult InstanceTable::GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice,
                                                                 const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo,
                                                                 VkSurfaceCapabilities2KHR *pSurfaceCapabilities) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSurfaceCapabilities2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSurfaceCapabilities2KHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
}
#endif
#if defined(VK_KHR_get_surface_capabilities2)
VkResult InstanceTable::GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice,
                                                            const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo,
                                                            uint32_t *pSurfaceFormatCount,
                                                            VkSurfaceFormat2KHR *pSurfaceFormats) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSurfaceFormats2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSurfaceFormats2KHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount,
                                                       pSurfaceFormats);
}
#endif
#if defined(VK_KHR_get_display_properties2)
VkResult InstanceTable::GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice,
                                                               uint32_t *pPropertyCount,
                                                               VkDisplayProperties2KHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceDisplayProperties2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceDisplayProperties2KHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties);
}
#endif
#if defined(VK_KHR_get_display_properties2)
VkResult InstanceTable::GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice,
                                                                    uint32_t *pPropertyCount,
                                                                    VkDisplayPlaneProperties2KHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceDisplayPlaneProperties2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceDisplayPlaneProperties2KHR' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties);
}
#endif
#if defined(VK_KHR_get_display_properties2)
VkResult InstanceTable::GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display,
                                                     uint32_t *pPropertyCount,
                                                     VkDisplayModeProperties2KHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetDisplayModeProperties2KHR,
                "[VULKIT][LOADER] The function 'vkGetDisplayModeProperties2KHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties);
}
#endif
#if defined(VK_KHR_get_display_properties2)
VkResult InstanceTable::GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice,
                                                        const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo,
                                                        VkDisplayPlaneCapabilities2KHR *pCapabilities) const
{
    TKIT_ASSERT(this->vkGetDisplayPlaneCapabilities2KHR,
                "[VULKIT][LOADER] The function 'vkGetDisplayPlaneCapabilities2KHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities);
}
#endif
#if defined(VK_KHR_calibrated_timestamps)
VkResult InstanceTable::GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice,
                                                                     uint32_t *pTimeDomainCount,
                                                                     VkTimeDomainKHR *pTimeDomains) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceCalibrateableTimeDomainsKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceCalibrateableTimeDomainsKHR' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(physicalDevice, pTimeDomainCount, pTimeDomains);
}
#endif
#if defined(VK_EXT_debug_utils)
VkResult InstanceTable::CreateDebugUtilsMessengerEXT(VkInstance instance,
                                                     const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo,
                                                     const VkAllocationCallbacks *pAllocator,
                                                     VkDebugUtilsMessengerEXT *pMessenger) const
{
    TKIT_ASSERT(this->vkCreateDebugUtilsMessengerEXT,
                "[VULKIT][LOADER] The function 'vkCreateDebugUtilsMessengerEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger);
}
#endif
#if defined(VK_EXT_debug_utils)
void InstanceTable::DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger,
                                                  const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyDebugUtilsMessengerEXT,
                "[VULKIT][LOADER] The function 'vkDestroyDebugUtilsMessengerEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator);
}
#endif
#if defined(VK_EXT_debug_utils)
void InstanceTable::SubmitDebugUtilsMessageEXT(VkInstance instance,
                                               VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
                                               VkDebugUtilsMessageTypeFlagsEXT messageTypes,
                                               const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) const
{
    TKIT_ASSERT(this->vkSubmitDebugUtilsMessageEXT,
                "[VULKIT][LOADER] The function 'vkSubmitDebugUtilsMessageEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData);
}
#endif
#if defined(VK_NV_cooperative_matrix)
VkResult InstanceTable::GetPhysicalDeviceCooperativeMatrixPropertiesNV(
    VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceCooperativeMatrixPropertiesNV,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceCooperativeMatrixPropertiesNV' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties);
}
#endif
#if defined(VK_EXT_full_screen_exclusive)
VkResult InstanceTable::GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice,
                                                                 const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo,
                                                                 uint32_t *pPresentModeCount,
                                                                 VkPresentModeKHR *pPresentModes) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSurfacePresentModes2EXT,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSurfacePresentModes2EXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount,
                                                            pPresentModes);
}
#endif
#if defined(VK_KHR_performance_query)
VkResult InstanceTable::EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount,
    VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions) const
{
    TKIT_ASSERT(this->vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR,
                "[VULKIT][LOADER] The function 'vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR' is "
                "not available for the instance or device being used, either because VKit::Initialize() was not "
                "called or because the feature or extension bound to the function has not been enabled");
    return this->vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
        physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
}
#endif
#if defined(VK_KHR_performance_query)
void InstanceTable::GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
    VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo,
    uint32_t *pNumPasses) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR' is not "
                "available for the instance or device being used, either because VKit::Initialize() was not "
                "called or because the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(physicalDevice, pPerformanceQueryCreateInfo,
                                                                  pNumPasses);
}
#endif
#if defined(VK_EXT_headless_surface)
VkResult InstanceTable::CreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo,
                                                 const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) const
{
    TKIT_ASSERT(this->vkCreateHeadlessSurfaceEXT,
                "[VULKIT][LOADER] The function 'vkCreateHeadlessSurfaceEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface);
}
#endif
#if defined(VK_NV_coverage_reduction_mode)
VkResult InstanceTable::GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount,
    VkFramebufferMixedSamplesCombinationNV *pCombinations) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV' is "
                "not available for the instance or device being used, either because VKit::Initialize() was not "
                "called or because the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount,
                                                                                   pCombinations);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
VkResult InstanceTable::GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t *pToolCount,
                                                        VkPhysicalDeviceToolProperties *pToolProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceToolProperties,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceToolProperties' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceToolProperties(physicalDevice, pToolCount, pToolProperties);
}
#endif
#if defined(VK_KHR_object_refresh)
VkResult InstanceTable::GetPhysicalDeviceRefreshableObjectTypesKHR(VkPhysicalDevice physicalDevice,
                                                                   uint32_t *pRefreshableObjectTypeCount,
                                                                   VkObjectType *pRefreshableObjectTypes) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceRefreshableObjectTypesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceRefreshableObjectTypesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceRefreshableObjectTypesKHR(physicalDevice, pRefreshableObjectTypeCount,
                                                              pRefreshableObjectTypes);
}
#endif
#if defined(VK_KHR_fragment_shading_rate)
VkResult InstanceTable::GetPhysicalDeviceFragmentShadingRatesKHR(
    VkPhysicalDevice physicalDevice, uint32_t *pFragmentShadingRateCount,
    VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceFragmentShadingRatesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceFragmentShadingRatesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceFragmentShadingRatesKHR(physicalDevice, pFragmentShadingRateCount,
                                                            pFragmentShadingRates);
}
#endif
#if defined(VK_KHR_video_queue)
VkResult InstanceTable::GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice,
                                                              const VkVideoProfileInfoKHR *pVideoProfile,
                                                              VkVideoCapabilitiesKHR *pCapabilities) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceVideoCapabilitiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceVideoCapabilitiesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceVideoCapabilitiesKHR(physicalDevice, pVideoProfile, pCapabilities);
}
#endif
#if defined(VK_KHR_video_queue)
VkResult InstanceTable::GetPhysicalDeviceVideoFormatPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo,
    uint32_t *pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR *pVideoFormatProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceVideoFormatPropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceVideoFormatPropertiesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceVideoFormatPropertiesKHR(physicalDevice, pVideoFormatInfo,
                                                             pVideoFormatPropertyCount, pVideoFormatProperties);
}
#endif
#if defined(VK_KHR_video_encode_queue)
VkResult InstanceTable::GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *pQualityLevelInfo,
    VkVideoEncodeQualityLevelPropertiesKHR *pQualityLevelProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR' is not "
                "available for the instance or device being used, either because VKit::Initialize() was not "
                "called or because the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(physicalDevice, pQualityLevelInfo,
                                                                         pQualityLevelProperties);
}
#endif
#if defined(VK_EXT_acquire_drm_display)
VkResult InstanceTable::AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) const
{
    TKIT_ASSERT(this->vkAcquireDrmDisplayEXT,
                "[VULKIT][LOADER] The function 'vkAcquireDrmDisplayEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkAcquireDrmDisplayEXT(physicalDevice, drmFd, display);
}
#endif
#if defined(VK_EXT_acquire_drm_display)
VkResult InstanceTable::GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId,
                                         VkDisplayKHR *display) const
{
    TKIT_ASSERT(this->vkGetDrmDisplayEXT,
                "[VULKIT][LOADER] The function 'vkGetDrmDisplayEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetDrmDisplayEXT(physicalDevice, drmFd, connectorId, display);
}
#endif
#if defined(VK_NV_optical_flow)
VkResult InstanceTable::GetPhysicalDeviceOpticalFlowImageFormatsNV(
    VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo,
    uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceOpticalFlowImageFormatsNV,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceOpticalFlowImageFormatsNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount,
                                                              pImageFormatProperties);
}
#endif
#if defined(VK_KHR_cooperative_matrix)
VkResult InstanceTable::GetPhysicalDeviceCooperativeMatrixPropertiesKHR(
    VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
}
#endif
#if defined(VK_NV_cooperative_matrix2)
VkResult InstanceTable::GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(
    VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount,
    VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV' is "
                "not available for the instance or device being used, either because VKit::Initialize() was not "
                "called or because the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(physicalDevice, pPropertyCount,
                                                                                    pProperties);
}
#endif
#if defined(VK_NV_cooperative_vector)
VkResult InstanceTable::GetPhysicalDeviceCooperativeVectorPropertiesNV(
    VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceCooperativeVectorPropertiesNV,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceCooperativeVectorPropertiesNV' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceCooperativeVectorPropertiesNV(physicalDevice, pPropertyCount, pProperties);
}
#endif
#if defined(VK_ARM_tensors)
void InstanceTable::GetPhysicalDeviceExternalTensorPropertiesARM(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM *pExternalTensorInfo,
    VkExternalTensorPropertiesARM *pExternalTensorProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceExternalTensorPropertiesARM,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceExternalTensorPropertiesARM' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceExternalTensorPropertiesARM(physicalDevice, pExternalTensorInfo,
                                                         pExternalTensorProperties);
}
#endif
#if defined(VK_ARM_data_graph)
VkResult InstanceTable::GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(
    VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pQueueFamilyDataGraphPropertyCount,
    VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(
        physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties);
}
#endif
#if defined(VK_ARM_data_graph)
void InstanceTable::GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(
    VkPhysicalDevice physicalDevice,
    const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *pQueueFamilyDataGraphProcessingEngineInfo,
    VkQueueFamilyDataGraphProcessingEnginePropertiesARM *pQueueFamilyDataGraphProcessingEngineProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM' "
                "is not available for the instance or device being used, either because VKit::Initialize() was "
                "not called or because the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(
        physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties);
}
#endif
#if defined(VK_KHR_get_physical_device_properties2)
void InstanceTable::GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice,
                                                  VkPhysicalDeviceFeatures2KHR *pFeatures) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceFeatures2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceFeatures2KHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures);
}
#endif
#if defined(VK_KHR_get_physical_device_properties2)
void InstanceTable::GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice,
                                                    VkPhysicalDeviceProperties2KHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceProperties2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceProperties2KHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceProperties2KHR(physicalDevice, pProperties);
}
#endif
#if defined(VK_KHR_get_physical_device_properties2)
void InstanceTable::GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format,
                                                          VkFormatProperties2KHR *pFormatProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceFormatProperties2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceFormatProperties2KHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties);
}
#endif
#if defined(VK_KHR_get_physical_device_properties2)
VkResult InstanceTable::GetPhysicalDeviceImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2KHR *pImageFormatInfo,
    VkImageFormatProperties2KHR *pImageFormatProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceImageFormatProperties2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceImageFormatProperties2KHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties);
}
#endif
#if defined(VK_KHR_get_physical_device_properties2)
void InstanceTable::GetPhysicalDeviceQueueFamilyProperties2KHR(
    VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount,
    VkQueueFamilyProperties2KHR *pQueueFamilyProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceQueueFamilyProperties2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceQueueFamilyProperties2KHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount,
                                                       pQueueFamilyProperties);
}
#endif
#if defined(VK_KHR_get_physical_device_properties2)
void InstanceTable::GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice,
                                                          VkPhysicalDeviceMemoryProperties2KHR *pMemoryProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceMemoryProperties2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceMemoryProperties2KHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties);
}
#endif
#if defined(VK_KHR_get_physical_device_properties2)
void InstanceTable::GetPhysicalDeviceSparseImageFormatProperties2KHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2KHR *pFormatInfo,
    uint32_t *pPropertyCount, VkSparseImageFormatProperties2KHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceSparseImageFormatProperties2KHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceSparseImageFormatProperties2KHR' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
}
#endif
#if defined(VK_KHR_external_memory_capabilities)
void InstanceTable::GetPhysicalDeviceExternalBufferPropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfoKHR *pExternalBufferInfo,
    VkExternalBufferPropertiesKHR *pExternalBufferProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceExternalBufferPropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceExternalBufferPropertiesKHR' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo,
                                                         pExternalBufferProperties);
}
#endif
#if defined(VK_KHR_external_semaphore_capabilities)
void InstanceTable::GetPhysicalDeviceExternalSemaphorePropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfoKHR *pExternalSemaphoreInfo,
    VkExternalSemaphorePropertiesKHR *pExternalSemaphoreProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceExternalSemaphorePropertiesKHR' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo,
                                                            pExternalSemaphoreProperties);
}
#endif
#if defined(VK_KHR_external_fence_capabilities)
void InstanceTable::GetPhysicalDeviceExternalFencePropertiesKHR(
    VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfoKHR *pExternalFenceInfo,
    VkExternalFencePropertiesKHR *pExternalFenceProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceExternalFencePropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceExternalFencePropertiesKHR' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
}
#endif
#if defined(VK_KHR_device_group_creation)
VkResult InstanceTable::EnumeratePhysicalDeviceGroupsKHR(
    VkInstance instance, uint32_t *pPhysicalDeviceGroupCount,
    VkPhysicalDeviceGroupPropertiesKHR *pPhysicalDeviceGroupProperties) const
{
    TKIT_ASSERT(this->vkEnumeratePhysicalDeviceGroupsKHR,
                "[VULKIT][LOADER] The function 'vkEnumeratePhysicalDeviceGroupsKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount,
                                                    pPhysicalDeviceGroupProperties);
}
#endif
#if defined(VK_EXT_calibrated_timestamps)
VkResult InstanceTable::GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice,
                                                                     uint32_t *pTimeDomainCount,
                                                                     VkTimeDomainEXT *pTimeDomains) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceCalibrateableTimeDomainsEXT' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains);
}
#endif
#if defined(VK_EXT_tooling_info)
VkResult InstanceTable::GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount,
                                                           VkPhysicalDeviceToolPropertiesEXT *pToolProperties) const
{
    TKIT_ASSERT(this->vkGetPhysicalDeviceToolPropertiesEXT,
                "[VULKIT][LOADER] The function 'vkGetPhysicalDeviceToolPropertiesEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, pToolCount, pToolProperties);
}
#endif

#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyDevice,
                "[VULKIT][LOADER] The function 'vkDestroyDevice' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyDevice(device, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue) const
{
    TKIT_ASSERT(this->vkGetDeviceQueue,
                "[VULKIT][LOADER] The function 'vkGetDeviceQueue' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::QueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits,
                                  VkFence fence) const
{
    TKIT_ASSERT(this->vkQueueSubmit, "[VULKIT][LOADER] The function 'vkQueueSubmit' is not available for the instance "
                                     "or device being used, either because VKit::Initialize() was not called or "
                                     "because the feature or extension bound to the function has not been enabled");
    return this->vkQueueSubmit(queue, submitCount, pSubmits, fence);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::QueueWaitIdle(VkQueue queue) const
{
    TKIT_ASSERT(this->vkQueueWaitIdle,
                "[VULKIT][LOADER] The function 'vkQueueWaitIdle' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkQueueWaitIdle(queue);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::DeviceWaitIdle(VkDevice device) const
{
    TKIT_ASSERT(this->vkDeviceWaitIdle,
                "[VULKIT][LOADER] The function 'vkDeviceWaitIdle' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkDeviceWaitIdle(device);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::AllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo,
                                     const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory) const
{
    TKIT_ASSERT(this->vkAllocateMemory,
                "[VULKIT][LOADER] The function 'vkAllocateMemory' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::FreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkFreeMemory, "[VULKIT][LOADER] The function 'vkFreeMemory' is not available for the instance or "
                                    "device being used, either because VKit::Initialize() was not called or "
                                    "because the feature or extension bound to the function has not been enabled");
    this->vkFreeMemory(device, memory, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::MapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size,
                                VkMemoryMapFlags flags, void **ppData) const
{
    TKIT_ASSERT(this->vkMapMemory, "[VULKIT][LOADER] The function 'vkMapMemory' is not available for the instance or "
                                   "device being used, either because VKit::Initialize() was not called or "
                                   "because the feature or extension bound to the function has not been enabled");
    return this->vkMapMemory(device, memory, offset, size, flags, ppData);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::UnmapMemory(VkDevice device, VkDeviceMemory memory) const
{
    TKIT_ASSERT(this->vkUnmapMemory, "[VULKIT][LOADER] The function 'vkUnmapMemory' is not available for the instance "
                                     "or device being used, either because VKit::Initialize() was not called or "
                                     "because the feature or extension bound to the function has not been enabled");
    this->vkUnmapMemory(device, memory);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::FlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                              const VkMappedMemoryRange *pMemoryRanges) const
{
    TKIT_ASSERT(this->vkFlushMappedMemoryRanges,
                "[VULKIT][LOADER] The function 'vkFlushMappedMemoryRanges' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::InvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount,
                                                   const VkMappedMemoryRange *pMemoryRanges) const
{
    TKIT_ASSERT(this->vkInvalidateMappedMemoryRanges,
                "[VULKIT][LOADER] The function 'vkInvalidateMappedMemoryRanges' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::GetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory,
                                            VkDeviceSize *pCommittedMemoryInBytes) const
{
    TKIT_ASSERT(this->vkGetDeviceMemoryCommitment,
                "[VULKIT][LOADER] The function 'vkGetDeviceMemoryCommitment' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::GetBufferMemoryRequirements(VkDevice device, VkBuffer buffer,
                                              VkMemoryRequirements *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetBufferMemoryRequirements,
                "[VULKIT][LOADER] The function 'vkGetBufferMemoryRequirements' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::BindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory,
                                       VkDeviceSize memoryOffset) const
{
    TKIT_ASSERT(this->vkBindBufferMemory,
                "[VULKIT][LOADER] The function 'vkBindBufferMemory' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkBindBufferMemory(device, buffer, memory, memoryOffset);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::GetImageMemoryRequirements(VkDevice device, VkImage image,
                                             VkMemoryRequirements *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetImageMemoryRequirements,
                "[VULKIT][LOADER] The function 'vkGetImageMemoryRequirements' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetImageMemoryRequirements(device, image, pMemoryRequirements);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::BindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory,
                                      VkDeviceSize memoryOffset) const
{
    TKIT_ASSERT(this->vkBindImageMemory,
                "[VULKIT][LOADER] The function 'vkBindImageMemory' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkBindImageMemory(device, image, memory, memoryOffset);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::GetImageSparseMemoryRequirements(VkDevice device, VkImage image,
                                                   uint32_t *pSparseMemoryRequirementCount,
                                                   VkSparseImageMemoryRequirements *pSparseMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetImageSparseMemoryRequirements,
                "[VULKIT][LOADER] The function 'vkGetImageSparseMemoryRequirements' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::QueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo,
                                      VkFence fence) const
{
    TKIT_ASSERT(this->vkQueueBindSparse,
                "[VULKIT][LOADER] The function 'vkQueueBindSparse' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo,
                                  const VkAllocationCallbacks *pAllocator, VkFence *pFence) const
{
    TKIT_ASSERT(this->vkCreateFence, "[VULKIT][LOADER] The function 'vkCreateFence' is not available for the instance "
                                     "or device being used, either because VKit::Initialize() was not called or "
                                     "because the feature or extension bound to the function has not been enabled");
    return this->vkCreateFence(device, pCreateInfo, pAllocator, pFence);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyFence,
                "[VULKIT][LOADER] The function 'vkDestroyFence' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyFence(device, fence, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::ResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences) const
{
    TKIT_ASSERT(this->vkResetFences, "[VULKIT][LOADER] The function 'vkResetFences' is not available for the instance "
                                     "or device being used, either because VKit::Initialize() was not called or "
                                     "because the feature or extension bound to the function has not been enabled");
    return this->vkResetFences(device, fenceCount, pFences);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::GetFenceStatus(VkDevice device, VkFence fence) const
{
    TKIT_ASSERT(this->vkGetFenceStatus,
                "[VULKIT][LOADER] The function 'vkGetFenceStatus' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetFenceStatus(device, fence);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::WaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll,
                                    uint64_t timeout) const
{
    TKIT_ASSERT(this->vkWaitForFences,
                "[VULKIT][LOADER] The function 'vkWaitForFences' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkWaitForFences(device, fenceCount, pFences, waitAll, timeout);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo,
                                      const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore) const
{
    TKIT_ASSERT(this->vkCreateSemaphore,
                "[VULKIT][LOADER] The function 'vkCreateSemaphore' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroySemaphore(VkDevice device, VkSemaphore semaphore,
                                   const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroySemaphore,
                "[VULKIT][LOADER] The function 'vkDestroySemaphore' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroySemaphore(device, semaphore, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo,
                                  const VkAllocationCallbacks *pAllocator, VkEvent *pEvent) const
{
    TKIT_ASSERT(this->vkCreateEvent, "[VULKIT][LOADER] The function 'vkCreateEvent' is not available for the instance "
                                     "or device being used, either because VKit::Initialize() was not called or "
                                     "because the feature or extension bound to the function has not been enabled");
    return this->vkCreateEvent(device, pCreateInfo, pAllocator, pEvent);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyEvent,
                "[VULKIT][LOADER] The function 'vkDestroyEvent' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyEvent(device, event, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::GetEventStatus(VkDevice device, VkEvent event) const
{
    TKIT_ASSERT(this->vkGetEventStatus,
                "[VULKIT][LOADER] The function 'vkGetEventStatus' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetEventStatus(device, event);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::SetEvent(VkDevice device, VkEvent event) const
{
    TKIT_ASSERT(this->vkSetEvent, "[VULKIT][LOADER] The function 'vkSetEvent' is not available for the instance or "
                                  "device being used, either because VKit::Initialize() was not called or "
                                  "because the feature or extension bound to the function has not been enabled");
    return this->vkSetEvent(device, event);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::ResetEvent(VkDevice device, VkEvent event) const
{
    TKIT_ASSERT(this->vkResetEvent, "[VULKIT][LOADER] The function 'vkResetEvent' is not available for the instance or "
                                    "device being used, either because VKit::Initialize() was not called or "
                                    "because the feature or extension bound to the function has not been enabled");
    return this->vkResetEvent(device, event);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo,
                                      const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool) const
{
    TKIT_ASSERT(this->vkCreateQueryPool,
                "[VULKIT][LOADER] The function 'vkCreateQueryPool' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyQueryPool(VkDevice device, VkQueryPool queryPool,
                                   const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyQueryPool,
                "[VULKIT][LOADER] The function 'vkDestroyQueryPool' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyQueryPool(device, queryPool, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::GetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery,
                                          uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride,
                                          VkQueryResultFlags flags) const
{
    TKIT_ASSERT(this->vkGetQueryPoolResults,
                "[VULKIT][LOADER] The function 'vkGetQueryPoolResults' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
void DeviceTable::ResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) const
{
    TKIT_ASSERT(this->vkResetQueryPool,
                "[VULKIT][LOADER] The function 'vkResetQueryPool' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkResetQueryPool(device, queryPool, firstQuery, queryCount);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo,
                                   const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer) const
{
    TKIT_ASSERT(this->vkCreateBuffer,
                "[VULKIT][LOADER] The function 'vkCreateBuffer' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyBuffer,
                "[VULKIT][LOADER] The function 'vkDestroyBuffer' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyBuffer(device, buffer, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo,
                                       const VkAllocationCallbacks *pAllocator, VkBufferView *pView) const
{
    TKIT_ASSERT(this->vkCreateBufferView,
                "[VULKIT][LOADER] The function 'vkCreateBufferView' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateBufferView(device, pCreateInfo, pAllocator, pView);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyBufferView(VkDevice device, VkBufferView bufferView,
                                    const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyBufferView,
                "[VULKIT][LOADER] The function 'vkDestroyBufferView' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyBufferView(device, bufferView, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo,
                                  const VkAllocationCallbacks *pAllocator, VkImage *pImage) const
{
    TKIT_ASSERT(this->vkCreateImage, "[VULKIT][LOADER] The function 'vkCreateImage' is not available for the instance "
                                     "or device being used, either because VKit::Initialize() was not called or "
                                     "because the feature or extension bound to the function has not been enabled");
    return this->vkCreateImage(device, pCreateInfo, pAllocator, pImage);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyImage,
                "[VULKIT][LOADER] The function 'vkDestroyImage' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyImage(device, image, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::GetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource,
                                            VkSubresourceLayout *pLayout) const
{
    TKIT_ASSERT(this->vkGetImageSubresourceLayout,
                "[VULKIT][LOADER] The function 'vkGetImageSubresourceLayout' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetImageSubresourceLayout(device, image, pSubresource, pLayout);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo,
                                      const VkAllocationCallbacks *pAllocator, VkImageView *pView) const
{
    TKIT_ASSERT(this->vkCreateImageView,
                "[VULKIT][LOADER] The function 'vkCreateImageView' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateImageView(device, pCreateInfo, pAllocator, pView);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyImageView(VkDevice device, VkImageView imageView,
                                   const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyImageView,
                "[VULKIT][LOADER] The function 'vkDestroyImageView' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyImageView(device, imageView, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo,
                                         const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule) const
{
    TKIT_ASSERT(this->vkCreateShaderModule,
                "[VULKIT][LOADER] The function 'vkCreateShaderModule' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyShaderModule(VkDevice device, VkShaderModule shaderModule,
                                      const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyShaderModule,
                "[VULKIT][LOADER] The function 'vkDestroyShaderModule' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyShaderModule(device, shaderModule, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo,
                                          const VkAllocationCallbacks *pAllocator,
                                          VkPipelineCache *pPipelineCache) const
{
    TKIT_ASSERT(this->vkCreatePipelineCache,
                "[VULKIT][LOADER] The function 'vkCreatePipelineCache' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache,
                                       const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyPipelineCache,
                "[VULKIT][LOADER] The function 'vkDestroyPipelineCache' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyPipelineCache(device, pipelineCache, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::GetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize,
                                           void *pData) const
{
    TKIT_ASSERT(this->vkGetPipelineCacheData,
                "[VULKIT][LOADER] The function 'vkGetPipelineCacheData' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::MergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount,
                                          const VkPipelineCache *pSrcCaches) const
{
    TKIT_ASSERT(this->vkMergePipelineCaches,
                "[VULKIT][LOADER] The function 'vkMergePipelineCaches' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches);
}
#endif
#if defined(VK_KHR_pipeline_binary)
VkResult DeviceTable::CreatePipelineBinariesKHR(VkDevice device, const VkPipelineBinaryCreateInfoKHR *pCreateInfo,
                                                const VkAllocationCallbacks *pAllocator,
                                                VkPipelineBinaryHandlesInfoKHR *pBinaries) const
{
    TKIT_ASSERT(this->vkCreatePipelineBinariesKHR,
                "[VULKIT][LOADER] The function 'vkCreatePipelineBinariesKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreatePipelineBinariesKHR(device, pCreateInfo, pAllocator, pBinaries);
}
#endif
#if defined(VK_KHR_pipeline_binary)
void DeviceTable::DestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary,
                                           const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyPipelineBinaryKHR,
                "[VULKIT][LOADER] The function 'vkDestroyPipelineBinaryKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyPipelineBinaryKHR(device, pipelineBinary, pAllocator);
}
#endif
#if defined(VK_KHR_pipeline_binary)
VkResult DeviceTable::GetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR *pPipelineCreateInfo,
                                        VkPipelineBinaryKeyKHR *pPipelineKey) const
{
    TKIT_ASSERT(this->vkGetPipelineKeyKHR,
                "[VULKIT][LOADER] The function 'vkGetPipelineKeyKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetPipelineKeyKHR(device, pPipelineCreateInfo, pPipelineKey);
}
#endif
#if defined(VK_KHR_pipeline_binary)
VkResult DeviceTable::GetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR *pInfo,
                                               VkPipelineBinaryKeyKHR *pPipelineBinaryKey,
                                               size_t *pPipelineBinaryDataSize, void *pPipelineBinaryData) const
{
    TKIT_ASSERT(this->vkGetPipelineBinaryDataKHR,
                "[VULKIT][LOADER] The function 'vkGetPipelineBinaryDataKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetPipelineBinaryDataKHR(device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize,
                                            pPipelineBinaryData);
}
#endif
#if defined(VK_KHR_pipeline_binary)
VkResult DeviceTable::ReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo,
                                                     const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkReleaseCapturedPipelineDataKHR,
                "[VULKIT][LOADER] The function 'vkReleaseCapturedPipelineDataKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkReleaseCapturedPipelineDataKHR(device, pInfo, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                              const VkGraphicsPipelineCreateInfo *pCreateInfos,
                                              const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const
{
    TKIT_ASSERT(this->vkCreateGraphicsPipelines,
                "[VULKIT][LOADER] The function 'vkCreateGraphicsPipelines' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
                                           pPipelines);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                             const VkComputePipelineCreateInfo *pCreateInfos,
                                             const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const
{
    TKIT_ASSERT(this->vkCreateComputePipelines,
                "[VULKIT][LOADER] The function 'vkCreateComputePipelines' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
}
#endif
#if (defined(VK_HUAWEI_subpass_shading) && VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION >= 2)
VkResult DeviceTable::GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass,
                                                                    VkExtent2D *pMaxWorkgroupSize) const
{
    TKIT_ASSERT(this->vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI,
                "[VULKIT][LOADER] The function 'vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderpass, pMaxWorkgroupSize);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyPipeline,
                "[VULKIT][LOADER] The function 'vkDestroyPipeline' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyPipeline(device, pipeline, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo,
                                           const VkAllocationCallbacks *pAllocator,
                                           VkPipelineLayout *pPipelineLayout) const
{
    TKIT_ASSERT(this->vkCreatePipelineLayout,
                "[VULKIT][LOADER] The function 'vkCreatePipelineLayout' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout,
                                        const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyPipelineLayout,
                "[VULKIT][LOADER] The function 'vkDestroyPipelineLayout' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyPipelineLayout(device, pipelineLayout, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo,
                                    const VkAllocationCallbacks *pAllocator, VkSampler *pSampler) const
{
    TKIT_ASSERT(this->vkCreateSampler,
                "[VULKIT][LOADER] The function 'vkCreateSampler' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateSampler(device, pCreateInfo, pAllocator, pSampler);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroySampler,
                "[VULKIT][LOADER] The function 'vkDestroySampler' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroySampler(device, sampler, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo,
                                                const VkAllocationCallbacks *pAllocator,
                                                VkDescriptorSetLayout *pSetLayout) const
{
    TKIT_ASSERT(this->vkCreateDescriptorSetLayout,
                "[VULKIT][LOADER] The function 'vkCreateDescriptorSetLayout' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout,
                                             const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyDescriptorSetLayout,
                "[VULKIT][LOADER] The function 'vkDestroyDescriptorSetLayout' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo,
                                           const VkAllocationCallbacks *pAllocator,
                                           VkDescriptorPool *pDescriptorPool) const
{
    TKIT_ASSERT(this->vkCreateDescriptorPool,
                "[VULKIT][LOADER] The function 'vkCreateDescriptorPool' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                        const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyDescriptorPool,
                "[VULKIT][LOADER] The function 'vkDestroyDescriptorPool' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyDescriptorPool(device, descriptorPool, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                          VkDescriptorPoolResetFlags flags) const
{
    TKIT_ASSERT(this->vkResetDescriptorPool,
                "[VULKIT][LOADER] The function 'vkResetDescriptorPool' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkResetDescriptorPool(device, descriptorPool, flags);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::AllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo,
                                             VkDescriptorSet *pDescriptorSets) const
{
    TKIT_ASSERT(this->vkAllocateDescriptorSets,
                "[VULKIT][LOADER] The function 'vkAllocateDescriptorSets' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::FreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount,
                                         const VkDescriptorSet *pDescriptorSets) const
{
    TKIT_ASSERT(this->vkFreeDescriptorSets,
                "[VULKIT][LOADER] The function 'vkFreeDescriptorSets' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::UpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount,
                                       const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount,
                                       const VkCopyDescriptorSet *pDescriptorCopies) const
{
    TKIT_ASSERT(this->vkUpdateDescriptorSets,
                "[VULKIT][LOADER] The function 'vkUpdateDescriptorSets' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount,
                                 pDescriptorCopies);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo,
                                        const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer) const
{
    TKIT_ASSERT(this->vkCreateFramebuffer,
                "[VULKIT][LOADER] The function 'vkCreateFramebuffer' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer,
                                     const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyFramebuffer,
                "[VULKIT][LOADER] The function 'vkDestroyFramebuffer' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyFramebuffer(device, framebuffer, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo,
                                       const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const
{
    TKIT_ASSERT(this->vkCreateRenderPass,
                "[VULKIT][LOADER] The function 'vkCreateRenderPass' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyRenderPass(VkDevice device, VkRenderPass renderPass,
                                    const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyRenderPass,
                "[VULKIT][LOADER] The function 'vkDestroyRenderPass' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyRenderPass(device, renderPass, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::GetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity) const
{
    TKIT_ASSERT(this->vkGetRenderAreaGranularity,
                "[VULKIT][LOADER] The function 'vkGetRenderAreaGranularity' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetRenderAreaGranularity(device, renderPass, pGranularity);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::GetRenderingAreaGranularity(VkDevice device, const VkRenderingAreaInfo *pRenderingAreaInfo,
                                              VkExtent2D *pGranularity) const
{
    TKIT_ASSERT(this->vkGetRenderingAreaGranularity,
                "[VULKIT][LOADER] The function 'vkGetRenderingAreaGranularity' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetRenderingAreaGranularity(device, pRenderingAreaInfo, pGranularity);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::CreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo,
                                        const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool) const
{
    TKIT_ASSERT(this->vkCreateCommandPool,
                "[VULKIT][LOADER] The function 'vkCreateCommandPool' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::DestroyCommandPool(VkDevice device, VkCommandPool commandPool,
                                     const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyCommandPool,
                "[VULKIT][LOADER] The function 'vkDestroyCommandPool' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyCommandPool(device, commandPool, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::ResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) const
{
    TKIT_ASSERT(this->vkResetCommandPool,
                "[VULKIT][LOADER] The function 'vkResetCommandPool' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkResetCommandPool(device, commandPool, flags);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo,
                                             VkCommandBuffer *pCommandBuffers) const
{
    TKIT_ASSERT(this->vkAllocateCommandBuffers,
                "[VULKIT][LOADER] The function 'vkAllocateCommandBuffers' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount,
                                     const VkCommandBuffer *pCommandBuffers) const
{
    TKIT_ASSERT(this->vkFreeCommandBuffers,
                "[VULKIT][LOADER] The function 'vkFreeCommandBuffers' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::BeginCommandBuffer(VkCommandBuffer commandBuffer,
                                         const VkCommandBufferBeginInfo *pBeginInfo) const
{
    TKIT_ASSERT(this->vkBeginCommandBuffer,
                "[VULKIT][LOADER] The function 'vkBeginCommandBuffer' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkBeginCommandBuffer(commandBuffer, pBeginInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::EndCommandBuffer(VkCommandBuffer commandBuffer) const
{
    TKIT_ASSERT(this->vkEndCommandBuffer,
                "[VULKIT][LOADER] The function 'vkEndCommandBuffer' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkEndCommandBuffer(commandBuffer);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
VkResult DeviceTable::ResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) const
{
    TKIT_ASSERT(this->vkResetCommandBuffer,
                "[VULKIT][LOADER] The function 'vkResetCommandBuffer' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkResetCommandBuffer(commandBuffer, flags);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                  VkPipeline pipeline) const
{
    TKIT_ASSERT(this->vkCmdBindPipeline,
                "[VULKIT][LOADER] The function 'vkCmdBindPipeline' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
}
#endif
#if defined(VK_EXT_attachment_feedback_loop_dynamic_state)
void DeviceTable::CmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer,
                                                        VkImageAspectFlags aspectMask) const
{
    TKIT_ASSERT(this->vkCmdSetAttachmentFeedbackLoopEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetAttachmentFeedbackLoopEnableEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetAttachmentFeedbackLoopEnableEXT(commandBuffer, aspectMask);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount,
                                 const VkViewport *pViewports) const
{
    TKIT_ASSERT(this->vkCmdSetViewport,
                "[VULKIT][LOADER] The function 'vkCmdSetViewport' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount,
                                const VkRect2D *pScissors) const
{
    TKIT_ASSERT(this->vkCmdSetScissor,
                "[VULKIT][LOADER] The function 'vkCmdSetScissor' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) const
{
    TKIT_ASSERT(this->vkCmdSetLineWidth,
                "[VULKIT][LOADER] The function 'vkCmdSetLineWidth' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetLineWidth(commandBuffer, lineWidth);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp,
                                  float depthBiasSlopeFactor) const
{
    TKIT_ASSERT(this->vkCmdSetDepthBias,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthBias' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) const
{
    TKIT_ASSERT(this->vkCmdSetBlendConstants,
                "[VULKIT][LOADER] The function 'vkCmdSetBlendConstants' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetBlendConstants(commandBuffer, blendConstants);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) const
{
    TKIT_ASSERT(this->vkCmdSetDepthBounds,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthBounds' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                           uint32_t compareMask) const
{
    TKIT_ASSERT(this->vkCmdSetStencilCompareMask,
                "[VULKIT][LOADER] The function 'vkCmdSetStencilCompareMask' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                         uint32_t writeMask) const
{
    TKIT_ASSERT(this->vkCmdSetStencilWriteMask,
                "[VULKIT][LOADER] The function 'vkCmdSetStencilWriteMask' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask,
                                         uint32_t reference) const
{
    TKIT_ASSERT(this->vkCmdSetStencilReference,
                "[VULKIT][LOADER] The function 'vkCmdSetStencilReference' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetStencilReference(commandBuffer, faceMask, reference);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                        VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount,
                                        const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount,
                                        const uint32_t *pDynamicOffsets) const
{
    TKIT_ASSERT(this->vkCmdBindDescriptorSets,
                "[VULKIT][LOADER] The function 'vkCmdBindDescriptorSets' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount,
                                  pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                     VkIndexType indexType) const
{
    TKIT_ASSERT(this->vkCmdBindIndexBuffer,
                "[VULKIT][LOADER] The function 'vkCmdBindIndexBuffer' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
                                       const VkBuffer *pBuffers, const VkDeviceSize *pOffsets) const
{
    TKIT_ASSERT(this->vkCmdBindVertexBuffers,
                "[VULKIT][LOADER] The function 'vkCmdBindVertexBuffers' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount,
                          uint32_t firstVertex, uint32_t firstInstance) const
{
    TKIT_ASSERT(this->vkCmdDraw, "[VULKIT][LOADER] The function 'vkCmdDraw' is not available for the instance or "
                                 "device being used, either because VKit::Initialize() was not called or because "
                                 "the feature or extension bound to the function has not been enabled");
    this->vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount,
                                 uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) const
{
    TKIT_ASSERT(this->vkCmdDrawIndexed,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndexed' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
}
#endif
#if defined(VK_EXT_multi_draw)
void DeviceTable::CmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount,
                                  const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance,
                                  uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawMultiEXT,
                "[VULKIT][LOADER] The function 'vkCmdDrawMultiEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdDrawMultiEXT(commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
}
#endif
#if defined(VK_EXT_multi_draw)
void DeviceTable::CmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount,
                                         const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount,
                                         uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset) const
{
    TKIT_ASSERT(this->vkCmdDrawMultiIndexedEXT,
                "[VULKIT][LOADER] The function 'vkCmdDrawMultiIndexedEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawMultiIndexedEXT(commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride,
                                   pVertexOffset);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                  uint32_t drawCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawIndirect,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndirect' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                         uint32_t drawCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawIndexedIndirect,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndexedIndirect' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
                              uint32_t groupCountZ) const
{
    TKIT_ASSERT(this->vkCmdDispatch, "[VULKIT][LOADER] The function 'vkCmdDispatch' is not available for the instance "
                                     "or device being used, either because VKit::Initialize() was not called or "
                                     "because the feature or extension bound to the function has not been enabled");
    this->vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) const
{
    TKIT_ASSERT(this->vkCmdDispatchIndirect,
                "[VULKIT][LOADER] The function 'vkCmdDispatchIndirect' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDispatchIndirect(commandBuffer, buffer, offset);
}
#endif
#if (defined(VK_HUAWEI_subpass_shading) && VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION >= 2)
void DeviceTable::CmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) const
{
    TKIT_ASSERT(this->vkCmdSubpassShadingHUAWEI,
                "[VULKIT][LOADER] The function 'vkCmdSubpassShadingHUAWEI' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSubpassShadingHUAWEI(commandBuffer);
}
#endif
#if defined(VK_HUAWEI_cluster_culling_shader)
void DeviceTable::CmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
                                       uint32_t groupCountZ) const
{
    TKIT_ASSERT(this->vkCmdDrawClusterHUAWEI,
                "[VULKIT][LOADER] The function 'vkCmdDrawClusterHUAWEI' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawClusterHUAWEI(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
#endif
#if defined(VK_HUAWEI_cluster_culling_shader)
void DeviceTable::CmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer,
                                               VkDeviceSize offset) const
{
    TKIT_ASSERT(this->vkCmdDrawClusterIndirectHUAWEI,
                "[VULKIT][LOADER] The function 'vkCmdDrawClusterIndirectHUAWEI' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawClusterIndirectHUAWEI(commandBuffer, buffer, offset);
}
#endif
#if defined(VK_NV_device_generated_commands_compute)
void DeviceTable::CmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer,
                                                    VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) const
{
    TKIT_ASSERT(this->vkCmdUpdatePipelineIndirectBufferNV,
                "[VULKIT][LOADER] The function 'vkCmdUpdatePipelineIndirectBufferNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdUpdatePipelineIndirectBufferNV(commandBuffer, pipelineBindPoint, pipeline);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer,
                                uint32_t regionCount, const VkBufferCopy *pRegions) const
{
    TKIT_ASSERT(this->vkCmdCopyBuffer,
                "[VULKIT][LOADER] The function 'vkCmdCopyBuffer' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                               VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount,
                               const VkImageCopy *pRegions) const
{
    TKIT_ASSERT(this->vkCmdCopyImage,
                "[VULKIT][LOADER] The function 'vkCmdCopyImage' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                               VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount,
                               const VkImageBlit *pRegions, VkFilter filter) const
{
    TKIT_ASSERT(this->vkCmdBlitImage,
                "[VULKIT][LOADER] The function 'vkCmdBlitImage' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions,
                         filter);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage,
                                       VkImageLayout dstImageLayout, uint32_t regionCount,
                                       const VkBufferImageCopy *pRegions) const
{
    TKIT_ASSERT(this->vkCmdCopyBufferToImage,
                "[VULKIT][LOADER] The function 'vkCmdCopyBufferToImage' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                                       VkBuffer dstBuffer, uint32_t regionCount,
                                       const VkBufferImageCopy *pRegions) const
{
    TKIT_ASSERT(this->vkCmdCopyImageToBuffer,
                "[VULKIT][LOADER] The function 'vkCmdCopyImageToBuffer' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
}
#endif
#if defined(VK_NV_copy_memory_indirect)
void DeviceTable::CmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress,
                                          uint32_t copyCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdCopyMemoryIndirectNV,
                "[VULKIT][LOADER] The function 'vkCmdCopyMemoryIndirectNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyMemoryIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride);
}
#endif
#if defined(VK_KHR_copy_memory_indirect)
void DeviceTable::CmdCopyMemoryIndirectKHR(VkCommandBuffer commandBuffer,
                                           const VkCopyMemoryIndirectInfoKHR *pCopyMemoryIndirectInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyMemoryIndirectKHR,
                "[VULKIT][LOADER] The function 'vkCmdCopyMemoryIndirectKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyMemoryIndirectKHR(commandBuffer, pCopyMemoryIndirectInfo);
}
#endif
#if defined(VK_NV_copy_memory_indirect)
void DeviceTable::CmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress,
                                                 uint32_t copyCount, uint32_t stride, VkImage dstImage,
                                                 VkImageLayout dstImageLayout,
                                                 const VkImageSubresourceLayers *pImageSubresources) const
{
    TKIT_ASSERT(this->vkCmdCopyMemoryToImageIndirectNV,
                "[VULKIT][LOADER] The function 'vkCmdCopyMemoryToImageIndirectNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyMemoryToImageIndirectNV(commandBuffer, copyBufferAddress, copyCount, stride, dstImage,
                                           dstImageLayout, pImageSubresources);
}
#endif
#if defined(VK_KHR_copy_memory_indirect)
void DeviceTable::CmdCopyMemoryToImageIndirectKHR(
    VkCommandBuffer commandBuffer, const VkCopyMemoryToImageIndirectInfoKHR *pCopyMemoryToImageIndirectInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyMemoryToImageIndirectKHR,
                "[VULKIT][LOADER] The function 'vkCmdCopyMemoryToImageIndirectKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdCopyMemoryToImageIndirectKHR(commandBuffer, pCopyMemoryToImageIndirectInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                  VkDeviceSize dataSize, const void *pData) const
{
    TKIT_ASSERT(this->vkCmdUpdateBuffer,
                "[VULKIT][LOADER] The function 'vkCmdUpdateBuffer' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                VkDeviceSize size, uint32_t data) const
{
    TKIT_ASSERT(this->vkCmdFillBuffer,
                "[VULKIT][LOADER] The function 'vkCmdFillBuffer' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout,
                                     const VkClearColorValue *pColor, uint32_t rangeCount,
                                     const VkImageSubresourceRange *pRanges) const
{
    TKIT_ASSERT(this->vkCmdClearColorImage,
                "[VULKIT][LOADER] The function 'vkCmdClearColorImage' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout,
                                            const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount,
                                            const VkImageSubresourceRange *pRanges) const
{
    TKIT_ASSERT(this->vkCmdClearDepthStencilImage,
                "[VULKIT][LOADER] The function 'vkCmdClearDepthStencilImage' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                                      const VkClearAttachment *pAttachments, uint32_t rectCount,
                                      const VkClearRect *pRects) const
{
    TKIT_ASSERT(this->vkCmdClearAttachments,
                "[VULKIT][LOADER] The function 'vkCmdClearAttachments' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout,
                                  VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount,
                                  const VkImageResolve *pRegions) const
{
    TKIT_ASSERT(this->vkCmdResolveImage,
                "[VULKIT][LOADER] The function 'vkCmdResolveImage' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const
{
    TKIT_ASSERT(this->vkCmdSetEvent, "[VULKIT][LOADER] The function 'vkCmdSetEvent' is not available for the instance "
                                     "or device being used, either because VKit::Initialize() was not called or "
                                     "because the feature or extension bound to the function has not been enabled");
    this->vkCmdSetEvent(commandBuffer, event, stageMask);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) const
{
    TKIT_ASSERT(this->vkCmdResetEvent,
                "[VULKIT][LOADER] The function 'vkCmdResetEvent' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdResetEvent(commandBuffer, event, stageMask);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents,
                                VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask,
                                uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers,
                                uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers,
                                uint32_t imageMemoryBarrierCount,
                                const VkImageMemoryBarrier *pImageMemoryBarriers) const
{
    TKIT_ASSERT(this->vkCmdWaitEvents,
                "[VULKIT][LOADER] The function 'vkCmdWaitEvents' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount,
                          pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount,
                          pImageMemoryBarriers);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
                                     VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags,
                                     uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers,
                                     uint32_t bufferMemoryBarrierCount,
                                     const VkBufferMemoryBarrier *pBufferMemoryBarriers,
                                     uint32_t imageMemoryBarrierCount,
                                     const VkImageMemoryBarrier *pImageMemoryBarriers) const
{
    TKIT_ASSERT(this->vkCmdPipelineBarrier,
                "[VULKIT][LOADER] The function 'vkCmdPipelineBarrier' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount,
                               pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers,
                               imageMemoryBarrierCount, pImageMemoryBarriers);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                VkQueryControlFlags flags) const
{
    TKIT_ASSERT(this->vkCmdBeginQuery,
                "[VULKIT][LOADER] The function 'vkCmdBeginQuery' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdBeginQuery(commandBuffer, queryPool, query, flags);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) const
{
    TKIT_ASSERT(this->vkCmdEndQuery, "[VULKIT][LOADER] The function 'vkCmdEndQuery' is not available for the instance "
                                     "or device being used, either because VKit::Initialize() was not called or "
                                     "because the feature or extension bound to the function has not been enabled");
    this->vkCmdEndQuery(commandBuffer, queryPool, query);
}
#endif
#if defined(VK_EXT_conditional_rendering)
void DeviceTable::CmdBeginConditionalRenderingEXT(
    VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin) const
{
    TKIT_ASSERT(this->vkCmdBeginConditionalRenderingEXT,
                "[VULKIT][LOADER] The function 'vkCmdBeginConditionalRenderingEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin);
}
#endif
#if defined(VK_EXT_conditional_rendering)
void DeviceTable::CmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) const
{
    TKIT_ASSERT(this->vkCmdEndConditionalRenderingEXT,
                "[VULKIT][LOADER] The function 'vkCmdEndConditionalRenderingEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdEndConditionalRenderingEXT(commandBuffer);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery,
                                    uint32_t queryCount) const
{
    TKIT_ASSERT(this->vkCmdResetQueryPool,
                "[VULKIT][LOADER] The function 'vkCmdResetQueryPool' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage,
                                    VkQueryPool queryPool, uint32_t query) const
{
    TKIT_ASSERT(this->vkCmdWriteTimestamp,
                "[VULKIT][LOADER] The function 'vkCmdWriteTimestamp' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery,
                                          uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset,
                                          VkDeviceSize stride, VkQueryResultFlags flags) const
{
    TKIT_ASSERT(this->vkCmdCopyQueryPoolResults,
                "[VULKIT][LOADER] The function 'vkCmdCopyQueryPoolResults' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride,
                                    flags);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout,
                                   VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size,
                                   const void *pValues) const
{
    TKIT_ASSERT(this->vkCmdPushConstants,
                "[VULKIT][LOADER] The function 'vkCmdPushConstants' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin,
                                     VkSubpassContents contents) const
{
    TKIT_ASSERT(this->vkCmdBeginRenderPass,
                "[VULKIT][LOADER] The function 'vkCmdBeginRenderPass' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) const
{
    TKIT_ASSERT(this->vkCmdNextSubpass,
                "[VULKIT][LOADER] The function 'vkCmdNextSubpass' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdNextSubpass(commandBuffer, contents);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdEndRenderPass(VkCommandBuffer commandBuffer) const
{
    TKIT_ASSERT(this->vkCmdEndRenderPass,
                "[VULKIT][LOADER] The function 'vkCmdEndRenderPass' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdEndRenderPass(commandBuffer);
}
#endif
#if defined(VKIT_API_VERSION_1_0)
void DeviceTable::CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                                     const VkCommandBuffer *pCommandBuffers) const
{
    TKIT_ASSERT(this->vkCmdExecuteCommands,
                "[VULKIT][LOADER] The function 'vkCmdExecuteCommands' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
}
#endif
#if defined(VK_KHR_display_swapchain)
VkResult DeviceTable::CreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount,
                                                const VkSwapchainCreateInfoKHR *pCreateInfos,
                                                const VkAllocationCallbacks *pAllocator,
                                                VkSwapchainKHR *pSwapchains) const
{
    TKIT_ASSERT(this->vkCreateSharedSwapchainsKHR,
                "[VULKIT][LOADER] The function 'vkCreateSharedSwapchainsKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
}
#endif
#if defined(VK_KHR_swapchain)
VkResult DeviceTable::CreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo,
                                         const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain) const
{
    TKIT_ASSERT(this->vkCreateSwapchainKHR,
                "[VULKIT][LOADER] The function 'vkCreateSwapchainKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain);
}
#endif
#if defined(VK_KHR_swapchain)
void DeviceTable::DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain,
                                      const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroySwapchainKHR,
                "[VULKIT][LOADER] The function 'vkDestroySwapchainKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroySwapchainKHR(device, swapchain, pAllocator);
}
#endif
#if defined(VK_KHR_swapchain)
VkResult DeviceTable::GetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount,
                                            VkImage *pSwapchainImages) const
{
    TKIT_ASSERT(this->vkGetSwapchainImagesKHR,
                "[VULKIT][LOADER] The function 'vkGetSwapchainImagesKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
}
#endif
#if defined(VK_KHR_swapchain)
VkResult DeviceTable::AcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout,
                                          VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex) const
{
    TKIT_ASSERT(this->vkAcquireNextImageKHR,
                "[VULKIT][LOADER] The function 'vkAcquireNextImageKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex);
}
#endif
#if defined(VK_KHR_swapchain)
VkResult DeviceTable::QueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo) const
{
    TKIT_ASSERT(this->vkQueuePresentKHR,
                "[VULKIT][LOADER] The function 'vkQueuePresentKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkQueuePresentKHR(queue, pPresentInfo);
}
#endif
#if defined(VK_EXT_debug_marker)
VkResult DeviceTable::DebugMarkerSetObjectNameEXT(VkDevice device,
                                                  const VkDebugMarkerObjectNameInfoEXT *pNameInfo) const
{
    TKIT_ASSERT(this->vkDebugMarkerSetObjectNameEXT,
                "[VULKIT][LOADER] The function 'vkDebugMarkerSetObjectNameEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkDebugMarkerSetObjectNameEXT(device, pNameInfo);
}
#endif
#if defined(VK_EXT_debug_marker)
VkResult DeviceTable::DebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo) const
{
    TKIT_ASSERT(this->vkDebugMarkerSetObjectTagEXT,
                "[VULKIT][LOADER] The function 'vkDebugMarkerSetObjectTagEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkDebugMarkerSetObjectTagEXT(device, pTagInfo);
}
#endif
#if defined(VK_EXT_debug_marker)
void DeviceTable::CmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer,
                                         const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const
{
    TKIT_ASSERT(this->vkCmdDebugMarkerBeginEXT,
                "[VULKIT][LOADER] The function 'vkCmdDebugMarkerBeginEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
}
#endif
#if defined(VK_EXT_debug_marker)
void DeviceTable::CmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) const
{
    TKIT_ASSERT(this->vkCmdDebugMarkerEndEXT,
                "[VULKIT][LOADER] The function 'vkCmdDebugMarkerEndEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDebugMarkerEndEXT(commandBuffer);
}
#endif
#if defined(VK_EXT_debug_marker)
void DeviceTable::CmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer,
                                          const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) const
{
    TKIT_ASSERT(this->vkCmdDebugMarkerInsertEXT,
                "[VULKIT][LOADER] The function 'vkCmdDebugMarkerInsertEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
}
#endif
#if defined(VK_NV_external_memory_win32)
VkResult DeviceTable::GetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory,
                                             VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE *pHandle) const
{
    TKIT_ASSERT(this->vkGetMemoryWin32HandleNV,
                "[VULKIT][LOADER] The function 'vkGetMemoryWin32HandleNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle);
}
#endif
#if defined(VK_NV_device_generated_commands)
void DeviceTable::CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed,
                                                const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const
{
    TKIT_ASSERT(this->vkCmdExecuteGeneratedCommandsNV,
                "[VULKIT][LOADER] The function 'vkCmdExecuteGeneratedCommandsNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdExecuteGeneratedCommandsNV(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
#endif
#if defined(VK_NV_device_generated_commands)
void DeviceTable::CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer,
                                                   const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) const
{
    TKIT_ASSERT(this->vkCmdPreprocessGeneratedCommandsNV,
                "[VULKIT][LOADER] The function 'vkCmdPreprocessGeneratedCommandsNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdPreprocessGeneratedCommandsNV(commandBuffer, pGeneratedCommandsInfo);
}
#endif
#if defined(VK_NV_device_generated_commands)
void DeviceTable::CmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                               VkPipeline pipeline, uint32_t groupIndex) const
{
    TKIT_ASSERT(this->vkCmdBindPipelineShaderGroupNV,
                "[VULKIT][LOADER] The function 'vkCmdBindPipelineShaderGroupNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindPipelineShaderGroupNV(commandBuffer, pipelineBindPoint, pipeline, groupIndex);
}
#endif
#if defined(VK_NV_device_generated_commands)
void DeviceTable::GetGeneratedCommandsMemoryRequirementsNV(VkDevice device,
                                                           const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo,
                                                           VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetGeneratedCommandsMemoryRequirementsNV,
                "[VULKIT][LOADER] The function 'vkGetGeneratedCommandsMemoryRequirementsNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetGeneratedCommandsMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_NV_device_generated_commands)
VkResult DeviceTable::CreateIndirectCommandsLayoutNV(VkDevice device,
                                                     const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo,
                                                     const VkAllocationCallbacks *pAllocator,
                                                     VkIndirectCommandsLayoutNV *pIndirectCommandsLayout) const
{
    TKIT_ASSERT(this->vkCreateIndirectCommandsLayoutNV,
                "[VULKIT][LOADER] The function 'vkCreateIndirectCommandsLayoutNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateIndirectCommandsLayoutNV(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
}
#endif
#if defined(VK_NV_device_generated_commands)
void DeviceTable::DestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout,
                                                  const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyIndirectCommandsLayoutNV,
                "[VULKIT][LOADER] The function 'vkDestroyIndirectCommandsLayoutNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkDestroyIndirectCommandsLayoutNV(device, indirectCommandsLayout, pAllocator);
}
#endif
#if defined(VK_EXT_device_generated_commands)
void DeviceTable::CmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed,
                                                 const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo) const
{
    TKIT_ASSERT(this->vkCmdExecuteGeneratedCommandsEXT,
                "[VULKIT][LOADER] The function 'vkCmdExecuteGeneratedCommandsEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdExecuteGeneratedCommandsEXT(commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
}
#endif
#if defined(VK_EXT_device_generated_commands)
void DeviceTable::CmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer,
                                                    const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo,
                                                    VkCommandBuffer stateCommandBuffer) const
{
    TKIT_ASSERT(this->vkCmdPreprocessGeneratedCommandsEXT,
                "[VULKIT][LOADER] The function 'vkCmdPreprocessGeneratedCommandsEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdPreprocessGeneratedCommandsEXT(commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer);
}
#endif
#if defined(VK_EXT_device_generated_commands)
void DeviceTable::GetGeneratedCommandsMemoryRequirementsEXT(VkDevice device,
                                                            const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo,
                                                            VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetGeneratedCommandsMemoryRequirementsEXT,
                "[VULKIT][LOADER] The function 'vkGetGeneratedCommandsMemoryRequirementsEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetGeneratedCommandsMemoryRequirementsEXT(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_EXT_device_generated_commands)
VkResult DeviceTable::CreateIndirectCommandsLayoutEXT(VkDevice device,
                                                      const VkIndirectCommandsLayoutCreateInfoEXT *pCreateInfo,
                                                      const VkAllocationCallbacks *pAllocator,
                                                      VkIndirectCommandsLayoutEXT *pIndirectCommandsLayout) const
{
    TKIT_ASSERT(this->vkCreateIndirectCommandsLayoutEXT,
                "[VULKIT][LOADER] The function 'vkCreateIndirectCommandsLayoutEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkCreateIndirectCommandsLayoutEXT(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
}
#endif
#if defined(VK_EXT_device_generated_commands)
void DeviceTable::DestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout,
                                                   const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyIndirectCommandsLayoutEXT,
                "[VULKIT][LOADER] The function 'vkDestroyIndirectCommandsLayoutEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkDestroyIndirectCommandsLayoutEXT(device, indirectCommandsLayout, pAllocator);
}
#endif
#if defined(VK_EXT_device_generated_commands)
VkResult DeviceTable::CreateIndirectExecutionSetEXT(VkDevice device,
                                                    const VkIndirectExecutionSetCreateInfoEXT *pCreateInfo,
                                                    const VkAllocationCallbacks *pAllocator,
                                                    VkIndirectExecutionSetEXT *pIndirectExecutionSet) const
{
    TKIT_ASSERT(this->vkCreateIndirectExecutionSetEXT,
                "[VULKIT][LOADER] The function 'vkCreateIndirectExecutionSetEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateIndirectExecutionSetEXT(device, pCreateInfo, pAllocator, pIndirectExecutionSet);
}
#endif
#if defined(VK_EXT_device_generated_commands)
void DeviceTable::DestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet,
                                                 const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyIndirectExecutionSetEXT,
                "[VULKIT][LOADER] The function 'vkDestroyIndirectExecutionSetEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyIndirectExecutionSetEXT(device, indirectExecutionSet, pAllocator);
}
#endif
#if defined(VK_EXT_device_generated_commands)
void DeviceTable::UpdateIndirectExecutionSetPipelineEXT(
    VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount,
    const VkWriteIndirectExecutionSetPipelineEXT *pExecutionSetWrites) const
{
    TKIT_ASSERT(this->vkUpdateIndirectExecutionSetPipelineEXT,
                "[VULKIT][LOADER] The function 'vkUpdateIndirectExecutionSetPipelineEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkUpdateIndirectExecutionSetPipelineEXT(device, indirectExecutionSet, executionSetWriteCount,
                                                  pExecutionSetWrites);
}
#endif
#if defined(VK_EXT_device_generated_commands)
void DeviceTable::UpdateIndirectExecutionSetShaderEXT(
    VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount,
    const VkWriteIndirectExecutionSetShaderEXT *pExecutionSetWrites) const
{
    TKIT_ASSERT(this->vkUpdateIndirectExecutionSetShaderEXT,
                "[VULKIT][LOADER] The function 'vkUpdateIndirectExecutionSetShaderEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkUpdateIndirectExecutionSetShaderEXT(device, indirectExecutionSet, executionSetWriteCount,
                                                pExecutionSetWrites);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdPushDescriptorSet(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                       VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount,
                                       const VkWriteDescriptorSet *pDescriptorWrites) const
{
    TKIT_ASSERT(this->vkCmdPushDescriptorSet,
                "[VULKIT][LOADER] The function 'vkCmdPushDescriptorSet' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdPushDescriptorSet(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount,
                                 pDescriptorWrites);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::TrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) const
{
    TKIT_ASSERT(this->vkTrimCommandPool,
                "[VULKIT][LOADER] The function 'vkTrimCommandPool' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkTrimCommandPool(device, commandPool, flags);
}
#endif
#if defined(VK_KHR_external_memory_win32)
VkResult DeviceTable::GetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo,
                                              HANDLE *pHandle) const
{
    TKIT_ASSERT(this->vkGetMemoryWin32HandleKHR,
                "[VULKIT][LOADER] The function 'vkGetMemoryWin32HandleKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
}
#endif
#if defined(VK_KHR_external_memory_win32)
VkResult DeviceTable::GetMemoryWin32HandlePropertiesKHR(
    VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle,
    VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties) const
{
    TKIT_ASSERT(this->vkGetMemoryWin32HandlePropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetMemoryWin32HandlePropertiesKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties);
}
#endif
#if defined(VK_KHR_external_memory_fd)
VkResult DeviceTable::GetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd) const
{
    TKIT_ASSERT(this->vkGetMemoryFdKHR,
                "[VULKIT][LOADER] The function 'vkGetMemoryFdKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetMemoryFdKHR(device, pGetFdInfo, pFd);
}
#endif
#if defined(VK_KHR_external_memory_fd)
VkResult DeviceTable::GetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd,
                                               VkMemoryFdPropertiesKHR *pMemoryFdProperties) const
{
    TKIT_ASSERT(this->vkGetMemoryFdPropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetMemoryFdPropertiesKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties);
}
#endif
#if defined(VK_FUCHSIA_external_memory)
VkResult DeviceTable::GetMemoryZirconHandleFUCHSIA(VkDevice device,
                                                   const VkMemoryGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo,
                                                   zx_handle_t *pZirconHandle) const
{
    TKIT_ASSERT(this->vkGetMemoryZirconHandleFUCHSIA,
                "[VULKIT][LOADER] The function 'vkGetMemoryZirconHandleFUCHSIA' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetMemoryZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
}
#endif
#if defined(VK_FUCHSIA_external_memory)
VkResult DeviceTable::GetMemoryZirconHandlePropertiesFUCHSIA(
    VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle,
    VkMemoryZirconHandlePropertiesFUCHSIA *pMemoryZirconHandleProperties) const
{
    TKIT_ASSERT(this->vkGetMemoryZirconHandlePropertiesFUCHSIA,
                "[VULKIT][LOADER] The function 'vkGetMemoryZirconHandlePropertiesFUCHSIA' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetMemoryZirconHandlePropertiesFUCHSIA(device, handleType, zirconHandle,
                                                          pMemoryZirconHandleProperties);
}
#endif
#if defined(VK_NV_external_memory_rdma)
VkResult DeviceTable::GetMemoryRemoteAddressNV(VkDevice device,
                                               const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo,
                                               VkRemoteAddressNV *pAddress) const
{
    TKIT_ASSERT(this->vkGetMemoryRemoteAddressNV,
                "[VULKIT][LOADER] The function 'vkGetMemoryRemoteAddressNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetMemoryRemoteAddressNV(device, pMemoryGetRemoteAddressInfo, pAddress);
}
#endif
#if defined(VK_NV_external_memory_sci_buf)
VkResult DeviceTable::GetMemorySciBufNV(VkDevice device, const VkMemoryGetSciBufInfoNV *pGetSciBufInfo,
                                        NvSciBufObj *pHandle) const
{
    TKIT_ASSERT(this->vkGetMemorySciBufNV,
                "[VULKIT][LOADER] The function 'vkGetMemorySciBufNV' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetMemorySciBufNV(device, pGetSciBufInfo, pHandle);
}
#endif
#if defined(VK_KHR_external_semaphore_win32)
VkResult DeviceTable::GetSemaphoreWin32HandleKHR(VkDevice device,
                                                 const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo,
                                                 HANDLE *pHandle) const
{
    TKIT_ASSERT(this->vkGetSemaphoreWin32HandleKHR,
                "[VULKIT][LOADER] The function 'vkGetSemaphoreWin32HandleKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
}
#endif
#if defined(VK_KHR_external_semaphore_win32)
VkResult DeviceTable::ImportSemaphoreWin32HandleKHR(
    VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo) const
{
    TKIT_ASSERT(this->vkImportSemaphoreWin32HandleKHR,
                "[VULKIT][LOADER] The function 'vkImportSemaphoreWin32HandleKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo);
}
#endif
#if defined(VK_KHR_external_semaphore_fd)
VkResult DeviceTable::GetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd) const
{
    TKIT_ASSERT(this->vkGetSemaphoreFdKHR,
                "[VULKIT][LOADER] The function 'vkGetSemaphoreFdKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetSemaphoreFdKHR(device, pGetFdInfo, pFd);
}
#endif
#if defined(VK_KHR_external_semaphore_fd)
VkResult DeviceTable::ImportSemaphoreFdKHR(VkDevice device,
                                           const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo) const
{
    TKIT_ASSERT(this->vkImportSemaphoreFdKHR,
                "[VULKIT][LOADER] The function 'vkImportSemaphoreFdKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo);
}
#endif
#if defined(VK_FUCHSIA_external_semaphore)
VkResult DeviceTable::GetSemaphoreZirconHandleFUCHSIA(VkDevice device,
                                                      const VkSemaphoreGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo,
                                                      zx_handle_t *pZirconHandle) const
{
    TKIT_ASSERT(this->vkGetSemaphoreZirconHandleFUCHSIA,
                "[VULKIT][LOADER] The function 'vkGetSemaphoreZirconHandleFUCHSIA' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetSemaphoreZirconHandleFUCHSIA(device, pGetZirconHandleInfo, pZirconHandle);
}
#endif
#if defined(VK_FUCHSIA_external_semaphore)
VkResult DeviceTable::ImportSemaphoreZirconHandleFUCHSIA(
    VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA *pImportSemaphoreZirconHandleInfo) const
{
    TKIT_ASSERT(this->vkImportSemaphoreZirconHandleFUCHSIA,
                "[VULKIT][LOADER] The function 'vkImportSemaphoreZirconHandleFUCHSIA' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkImportSemaphoreZirconHandleFUCHSIA(device, pImportSemaphoreZirconHandleInfo);
}
#endif
#if defined(VK_KHR_external_fence_win32)
VkResult DeviceTable::GetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo,
                                             HANDLE *pHandle) const
{
    TKIT_ASSERT(this->vkGetFenceWin32HandleKHR,
                "[VULKIT][LOADER] The function 'vkGetFenceWin32HandleKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle);
}
#endif
#if defined(VK_KHR_external_fence_win32)
VkResult DeviceTable::ImportFenceWin32HandleKHR(
    VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo) const
{
    TKIT_ASSERT(this->vkImportFenceWin32HandleKHR,
                "[VULKIT][LOADER] The function 'vkImportFenceWin32HandleKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo);
}
#endif
#if defined(VK_KHR_external_fence_fd)
VkResult DeviceTable::GetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd) const
{
    TKIT_ASSERT(this->vkGetFenceFdKHR,
                "[VULKIT][LOADER] The function 'vkGetFenceFdKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetFenceFdKHR(device, pGetFdInfo, pFd);
}
#endif
#if defined(VK_KHR_external_fence_fd)
VkResult DeviceTable::ImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo) const
{
    TKIT_ASSERT(this->vkImportFenceFdKHR,
                "[VULKIT][LOADER] The function 'vkImportFenceFdKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkImportFenceFdKHR(device, pImportFenceFdInfo);
}
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
VkResult DeviceTable::GetFenceSciSyncFenceNV(VkDevice device, const VkFenceGetSciSyncInfoNV *pGetSciSyncHandleInfo,
                                             void *pHandle) const
{
    TKIT_ASSERT(this->vkGetFenceSciSyncFenceNV,
                "[VULKIT][LOADER] The function 'vkGetFenceSciSyncFenceNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetFenceSciSyncFenceNV(device, pGetSciSyncHandleInfo, pHandle);
}
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
VkResult DeviceTable::GetFenceSciSyncObjNV(VkDevice device, const VkFenceGetSciSyncInfoNV *pGetSciSyncHandleInfo,
                                           void *pHandle) const
{
    TKIT_ASSERT(this->vkGetFenceSciSyncObjNV,
                "[VULKIT][LOADER] The function 'vkGetFenceSciSyncObjNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetFenceSciSyncObjNV(device, pGetSciSyncHandleInfo, pHandle);
}
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
VkResult DeviceTable::ImportFenceSciSyncFenceNV(VkDevice device,
                                                const VkImportFenceSciSyncInfoNV *pImportFenceSciSyncInfo) const
{
    TKIT_ASSERT(this->vkImportFenceSciSyncFenceNV,
                "[VULKIT][LOADER] The function 'vkImportFenceSciSyncFenceNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkImportFenceSciSyncFenceNV(device, pImportFenceSciSyncInfo);
}
#endif
#if defined(VK_NV_external_sci_sync) || defined(VK_NV_external_sci_sync2)
VkResult DeviceTable::ImportFenceSciSyncObjNV(VkDevice device,
                                              const VkImportFenceSciSyncInfoNV *pImportFenceSciSyncInfo) const
{
    TKIT_ASSERT(this->vkImportFenceSciSyncObjNV,
                "[VULKIT][LOADER] The function 'vkImportFenceSciSyncObjNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkImportFenceSciSyncObjNV(device, pImportFenceSciSyncInfo);
}
#endif
#if defined(VK_NV_external_sci_sync)
VkResult DeviceTable::GetSemaphoreSciSyncObjNV(VkDevice device, const VkSemaphoreGetSciSyncInfoNV *pGetSciSyncInfo,
                                               void *pHandle) const
{
    TKIT_ASSERT(this->vkGetSemaphoreSciSyncObjNV,
                "[VULKIT][LOADER] The function 'vkGetSemaphoreSciSyncObjNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetSemaphoreSciSyncObjNV(device, pGetSciSyncInfo, pHandle);
}
#endif
#if defined(VK_NV_external_sci_sync)
VkResult DeviceTable::ImportSemaphoreSciSyncObjNV(
    VkDevice device, const VkImportSemaphoreSciSyncInfoNV *pImportSemaphoreSciSyncInfo) const
{
    TKIT_ASSERT(this->vkImportSemaphoreSciSyncObjNV,
                "[VULKIT][LOADER] The function 'vkImportSemaphoreSciSyncObjNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkImportSemaphoreSciSyncObjNV(device, pImportSemaphoreSciSyncInfo);
}
#endif
#if defined(VK_NV_external_sci_sync2)
VkResult DeviceTable::CreateSemaphoreSciSyncPoolNV(VkDevice device,
                                                   const VkSemaphoreSciSyncPoolCreateInfoNV *pCreateInfo,
                                                   const VkAllocationCallbacks *pAllocator,
                                                   VkSemaphoreSciSyncPoolNV *pSemaphorePool) const
{
    TKIT_ASSERT(this->vkCreateSemaphoreSciSyncPoolNV,
                "[VULKIT][LOADER] The function 'vkCreateSemaphoreSciSyncPoolNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateSemaphoreSciSyncPoolNV(device, pCreateInfo, pAllocator, pSemaphorePool);
}
#endif
#if defined(VK_NV_external_sci_sync2)
void DeviceTable::DestroySemaphoreSciSyncPoolNV(VkDevice device, VkSemaphoreSciSyncPoolNV semaphorePool,
                                                const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroySemaphoreSciSyncPoolNV,
                "[VULKIT][LOADER] The function 'vkDestroySemaphoreSciSyncPoolNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroySemaphoreSciSyncPoolNV(device, semaphorePool, pAllocator);
}
#endif
#if defined(VK_EXT_display_control)
VkResult DeviceTable::DisplayPowerControlEXT(VkDevice device, VkDisplayKHR display,
                                             const VkDisplayPowerInfoEXT *pDisplayPowerInfo) const
{
    TKIT_ASSERT(this->vkDisplayPowerControlEXT,
                "[VULKIT][LOADER] The function 'vkDisplayPowerControlEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo);
}
#endif
#if defined(VK_EXT_display_control)
VkResult DeviceTable::RegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo,
                                             const VkAllocationCallbacks *pAllocator, VkFence *pFence) const
{
    TKIT_ASSERT(this->vkRegisterDeviceEventEXT,
                "[VULKIT][LOADER] The function 'vkRegisterDeviceEventEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence);
}
#endif
#if defined(VK_EXT_display_control)
VkResult DeviceTable::RegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display,
                                              const VkDisplayEventInfoEXT *pDisplayEventInfo,
                                              const VkAllocationCallbacks *pAllocator, VkFence *pFence) const
{
    TKIT_ASSERT(this->vkRegisterDisplayEventEXT,
                "[VULKIT][LOADER] The function 'vkRegisterDisplayEventEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence);
}
#endif
#if defined(VK_EXT_display_control)
VkResult DeviceTable::GetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain,
                                             VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue) const
{
    TKIT_ASSERT(this->vkGetSwapchainCounterEXT,
                "[VULKIT][LOADER] The function 'vkGetSwapchainCounterEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::GetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex,
                                                   uint32_t remoteDeviceIndex,
                                                   VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) const
{
    TKIT_ASSERT(this->vkGetDeviceGroupPeerMemoryFeatures,
                "[VULKIT][LOADER] The function 'vkGetDeviceGroupPeerMemoryFeatures' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex,
                                             pPeerMemoryFeatures);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
VkResult DeviceTable::BindBufferMemory2(VkDevice device, uint32_t bindInfoCount,
                                        const VkBindBufferMemoryInfo *pBindInfos) const
{
    TKIT_ASSERT(this->vkBindBufferMemory2,
                "[VULKIT][LOADER] The function 'vkBindBufferMemory2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkBindBufferMemory2(device, bindInfoCount, pBindInfos);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
VkResult DeviceTable::BindImageMemory2(VkDevice device, uint32_t bindInfoCount,
                                       const VkBindImageMemoryInfo *pBindInfos) const
{
    TKIT_ASSERT(this->vkBindImageMemory2,
                "[VULKIT][LOADER] The function 'vkBindImageMemory2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkBindImageMemory2(device, bindInfoCount, pBindInfos);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::CmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) const
{
    TKIT_ASSERT(this->vkCmdSetDeviceMask,
                "[VULKIT][LOADER] The function 'vkCmdSetDeviceMask' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetDeviceMask(commandBuffer, deviceMask);
}
#endif
#if (defined(VK_KHR_swapchain) && defined(VKIT_API_VERSION_1_1)) ||                                                    \
    (defined(VK_KHR_device_group) && defined(VK_KHR_surface))
VkResult DeviceTable::GetDeviceGroupPresentCapabilitiesKHR(
    VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities) const
{
    TKIT_ASSERT(this->vkGetDeviceGroupPresentCapabilitiesKHR,
                "[VULKIT][LOADER] The function 'vkGetDeviceGroupPresentCapabilitiesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities);
}
#endif
#if (defined(VK_KHR_swapchain) && defined(VKIT_API_VERSION_1_1)) ||                                                    \
    (defined(VK_KHR_device_group) && defined(VK_KHR_surface))
VkResult DeviceTable::GetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface,
                                                           VkDeviceGroupPresentModeFlagsKHR *pModes) const
{
    TKIT_ASSERT(this->vkGetDeviceGroupSurfacePresentModesKHR,
                "[VULKIT][LOADER] The function 'vkGetDeviceGroupSurfacePresentModesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes);
}
#endif
#if (defined(VK_KHR_swapchain) && defined(VKIT_API_VERSION_1_1)) ||                                                    \
    (defined(VK_KHR_device_group) && defined(VK_KHR_swapchain))
VkResult DeviceTable::AcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo,
                                           uint32_t *pImageIndex) const
{
    TKIT_ASSERT(this->vkAcquireNextImage2KHR,
                "[VULKIT][LOADER] The function 'vkAcquireNextImage2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::CmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY,
                                  uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY,
                                  uint32_t groupCountZ) const
{
    TKIT_ASSERT(this->vkCmdDispatchBase,
                "[VULKIT][LOADER] The function 'vkCmdDispatchBase' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
VkResult DeviceTable::CreateDescriptorUpdateTemplate(VkDevice device,
                                                     const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo,
                                                     const VkAllocationCallbacks *pAllocator,
                                                     VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) const
{
    TKIT_ASSERT(this->vkCreateDescriptorUpdateTemplate,
                "[VULKIT][LOADER] The function 'vkCreateDescriptorUpdateTemplate' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::DestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                  const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyDescriptorUpdateTemplate,
                "[VULKIT][LOADER] The function 'vkDestroyDescriptorUpdateTemplate' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::UpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet,
                                                  VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                  const void *pData) const
{
    TKIT_ASSERT(this->vkUpdateDescriptorSetWithTemplate,
                "[VULKIT][LOADER] The function 'vkUpdateDescriptorSetWithTemplate' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdPushDescriptorSetWithTemplate(VkCommandBuffer commandBuffer,
                                                   VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                                   VkPipelineLayout layout, uint32_t set, const void *pData) const
{
    TKIT_ASSERT(this->vkCmdPushDescriptorSetWithTemplate,
                "[VULKIT][LOADER] The function 'vkCmdPushDescriptorSetWithTemplate' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdPushDescriptorSetWithTemplate(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
#endif
#if defined(VK_EXT_hdr_metadata)
void DeviceTable::SetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR *pSwapchains,
                                    const VkHdrMetadataEXT *pMetadata) const
{
    TKIT_ASSERT(this->vkSetHdrMetadataEXT,
                "[VULKIT][LOADER] The function 'vkSetHdrMetadataEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata);
}
#endif
#if defined(VK_KHR_shared_presentable_image)
VkResult DeviceTable::GetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) const
{
    TKIT_ASSERT(this->vkGetSwapchainStatusKHR,
                "[VULKIT][LOADER] The function 'vkGetSwapchainStatusKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetSwapchainStatusKHR(device, swapchain);
}
#endif
#if defined(VK_GOOGLE_display_timing)
VkResult DeviceTable::GetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain,
                                                    VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties) const
{
    TKIT_ASSERT(this->vkGetRefreshCycleDurationGOOGLE,
                "[VULKIT][LOADER] The function 'vkGetRefreshCycleDurationGOOGLE' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties);
}
#endif
#if defined(VK_GOOGLE_display_timing)
VkResult DeviceTable::GetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain,
                                                      uint32_t *pPresentationTimingCount,
                                                      VkPastPresentationTimingGOOGLE *pPresentationTimings) const
{
    TKIT_ASSERT(this->vkGetPastPresentationTimingGOOGLE,
                "[VULKIT][LOADER] The function 'vkGetPastPresentationTimingGOOGLE' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings);
}
#endif
#if defined(VK_NV_clip_space_w_scaling)
void DeviceTable::CmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                           uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings) const
{
    TKIT_ASSERT(this->vkCmdSetViewportWScalingNV,
                "[VULKIT][LOADER] The function 'vkCmdSetViewportWScalingNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
}
#endif
#if defined(VK_EXT_discard_rectangles)
void DeviceTable::CmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle,
                                            uint32_t discardRectangleCount, const VkRect2D *pDiscardRectangles) const
{
    TKIT_ASSERT(this->vkCmdSetDiscardRectangleEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDiscardRectangleEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
}
#endif
#if VK_HEADER_VERSION >= 241 && ((defined(VK_EXT_discard_rectangles) && VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2))
void DeviceTable::CmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDiscardRectangleEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDiscardRectangleEnableEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdSetDiscardRectangleEnableEXT(commandBuffer, discardRectangleEnable);
}
#endif
#if VK_HEADER_VERSION >= 241 && ((defined(VK_EXT_discard_rectangles) && VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2 && \
                                  VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION >= 2))
void DeviceTable::CmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer,
                                                VkDiscardRectangleModeEXT discardRectangleMode) const
{
    TKIT_ASSERT(this->vkCmdSetDiscardRectangleModeEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDiscardRectangleModeEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDiscardRectangleModeEXT(commandBuffer, discardRectangleMode);
}
#endif
#if defined(VK_EXT_sample_locations)
void DeviceTable::CmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer,
                                           const VkSampleLocationsInfoEXT *pSampleLocationsInfo) const
{
    TKIT_ASSERT(this->vkCmdSetSampleLocationsEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetSampleLocationsEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::GetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo,
                                               VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetBufferMemoryRequirements2,
                "[VULKIT][LOADER] The function 'vkGetBufferMemoryRequirements2' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::GetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo,
                                              VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetImageMemoryRequirements2,
                "[VULKIT][LOADER] The function 'vkGetImageMemoryRequirements2' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::GetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo,
                                                    uint32_t *pSparseMemoryRequirementCount,
                                                    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetImageSparseMemoryRequirements2,
                "[VULKIT][LOADER] The function 'vkGetImageSparseMemoryRequirements2' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::GetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo,
                                                    VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetDeviceBufferMemoryRequirements,
                "[VULKIT][LOADER] The function 'vkGetDeviceBufferMemoryRequirements' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetDeviceBufferMemoryRequirements(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::GetDeviceImageMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo,
                                                   VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetDeviceImageMemoryRequirements,
                "[VULKIT][LOADER] The function 'vkGetDeviceImageMemoryRequirements' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetDeviceImageMemoryRequirements(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::GetDeviceImageSparseMemoryRequirements(
    VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetDeviceImageSparseMemoryRequirements,
                "[VULKIT][LOADER] The function 'vkGetDeviceImageSparseMemoryRequirements' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetDeviceImageSparseMemoryRequirements(device, pInfo, pSparseMemoryRequirementCount,
                                                   pSparseMemoryRequirements);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
VkResult DeviceTable::CreateSamplerYcbcrConversion(VkDevice device,
                                                   const VkSamplerYcbcrConversionCreateInfo *pCreateInfo,
                                                   const VkAllocationCallbacks *pAllocator,
                                                   VkSamplerYcbcrConversion *pYcbcrConversion) const
{
    TKIT_ASSERT(this->vkCreateSamplerYcbcrConversion,
                "[VULKIT][LOADER] The function 'vkCreateSamplerYcbcrConversion' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::DestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion,
                                                const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroySamplerYcbcrConversion,
                "[VULKIT][LOADER] The function 'vkDestroySamplerYcbcrConversion' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue) const
{
    TKIT_ASSERT(this->vkGetDeviceQueue2,
                "[VULKIT][LOADER] The function 'vkGetDeviceQueue2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkGetDeviceQueue2(device, pQueueInfo, pQueue);
}
#endif
#if defined(VK_EXT_validation_cache)
VkResult DeviceTable::CreateValidationCacheEXT(VkDevice device, const VkValidationCacheCreateInfoEXT *pCreateInfo,
                                               const VkAllocationCallbacks *pAllocator,
                                               VkValidationCacheEXT *pValidationCache) const
{
    TKIT_ASSERT(this->vkCreateValidationCacheEXT,
                "[VULKIT][LOADER] The function 'vkCreateValidationCacheEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache);
}
#endif
#if defined(VK_EXT_validation_cache)
void DeviceTable::DestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache,
                                            const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyValidationCacheEXT,
                "[VULKIT][LOADER] The function 'vkDestroyValidationCacheEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyValidationCacheEXT(device, validationCache, pAllocator);
}
#endif
#if defined(VK_EXT_validation_cache)
VkResult DeviceTable::GetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache,
                                                size_t *pDataSize, void *pData) const
{
    TKIT_ASSERT(this->vkGetValidationCacheDataEXT,
                "[VULKIT][LOADER] The function 'vkGetValidationCacheDataEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData);
}
#endif
#if defined(VK_EXT_validation_cache)
VkResult DeviceTable::MergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount,
                                               const VkValidationCacheEXT *pSrcCaches) const
{
    TKIT_ASSERT(this->vkMergeValidationCachesEXT,
                "[VULKIT][LOADER] The function 'vkMergeValidationCachesEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches);
}
#endif
#if defined(VKIT_API_VERSION_1_1)
void DeviceTable::GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo,
                                                VkDescriptorSetLayoutSupport *pSupport) const
{
    TKIT_ASSERT(this->vkGetDescriptorSetLayoutSupport,
                "[VULKIT][LOADER] The function 'vkGetDescriptorSetLayoutSupport' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport);
}
#endif
#if defined(VK_ANDROID_native_buffer)
VkResult DeviceTable::GetSwapchainGrallocUsageANDROID(VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
                                                      int *grallocUsage) const
{
    TKIT_ASSERT(this->vkGetSwapchainGrallocUsageANDROID,
                "[VULKIT][LOADER] The function 'vkGetSwapchainGrallocUsageANDROID' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetSwapchainGrallocUsageANDROID(device, format, imageUsage, grallocUsage);
}
#endif
#if defined(VK_ANDROID_native_buffer)
VkResult DeviceTable::GetSwapchainGrallocUsage2ANDROID(VkDevice device, VkFormat format, VkImageUsageFlags imageUsage,
                                                       VkSwapchainImageUsageFlagsANDROID swapchainImageUsage,
                                                       uint64_t *grallocConsumerUsage,
                                                       uint64_t *grallocProducerUsage) const
{
    TKIT_ASSERT(this->vkGetSwapchainGrallocUsage2ANDROID,
                "[VULKIT][LOADER] The function 'vkGetSwapchainGrallocUsage2ANDROID' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetSwapchainGrallocUsage2ANDROID(device, format, imageUsage, swapchainImageUsage,
                                                    grallocConsumerUsage, grallocProducerUsage);
}
#endif
#if defined(VK_ANDROID_native_buffer)
VkResult DeviceTable::AcquireImageANDROID(VkDevice device, VkImage image, int nativeFenceFd, VkSemaphore semaphore,
                                          VkFence fence) const
{
    TKIT_ASSERT(this->vkAcquireImageANDROID,
                "[VULKIT][LOADER] The function 'vkAcquireImageANDROID' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkAcquireImageANDROID(device, image, nativeFenceFd, semaphore, fence);
}
#endif
#if defined(VK_ANDROID_native_buffer)
VkResult DeviceTable::QueueSignalReleaseImageANDROID(VkQueue queue, uint32_t waitSemaphoreCount,
                                                     const VkSemaphore *pWaitSemaphores, VkImage image,
                                                     int *pNativeFenceFd) const
{
    TKIT_ASSERT(this->vkQueueSignalReleaseImageANDROID,
                "[VULKIT][LOADER] The function 'vkQueueSignalReleaseImageANDROID' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkQueueSignalReleaseImageANDROID(queue, waitSemaphoreCount, pWaitSemaphores, image, pNativeFenceFd);
}
#endif
#if defined(VK_AMD_shader_info)
VkResult DeviceTable::GetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage,
                                       VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo) const
{
    TKIT_ASSERT(this->vkGetShaderInfoAMD,
                "[VULKIT][LOADER] The function 'vkGetShaderInfoAMD' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
}
#endif
#if defined(VK_AMD_display_native_hdr)
void DeviceTable::SetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) const
{
    TKIT_ASSERT(this->vkSetLocalDimmingAMD,
                "[VULKIT][LOADER] The function 'vkSetLocalDimmingAMD' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkSetLocalDimmingAMD(device, swapChain, localDimmingEnable);
}
#endif
#if defined(VK_KHR_calibrated_timestamps)
VkResult DeviceTable::GetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount,
                                                 const VkCalibratedTimestampInfoKHR *pTimestampInfos,
                                                 uint64_t *pTimestamps, uint64_t *pMaxDeviation) const
{
    TKIT_ASSERT(this->vkGetCalibratedTimestampsKHR,
                "[VULKIT][LOADER] The function 'vkGetCalibratedTimestampsKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetCalibratedTimestampsKHR(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
}
#endif
#if defined(VK_EXT_debug_utils)
VkResult DeviceTable::SetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT *pNameInfo) const
{
    TKIT_ASSERT(this->vkSetDebugUtilsObjectNameEXT,
                "[VULKIT][LOADER] The function 'vkSetDebugUtilsObjectNameEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkSetDebugUtilsObjectNameEXT(device, pNameInfo);
}
#endif
#if defined(VK_EXT_debug_utils)
VkResult DeviceTable::SetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT *pTagInfo) const
{
    TKIT_ASSERT(this->vkSetDebugUtilsObjectTagEXT,
                "[VULKIT][LOADER] The function 'vkSetDebugUtilsObjectTagEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkSetDebugUtilsObjectTagEXT(device, pTagInfo);
}
#endif
#if defined(VK_EXT_debug_utils)
void DeviceTable::QueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const
{
    TKIT_ASSERT(this->vkQueueBeginDebugUtilsLabelEXT,
                "[VULKIT][LOADER] The function 'vkQueueBeginDebugUtilsLabelEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo);
}
#endif
#if defined(VK_EXT_debug_utils)
void DeviceTable::QueueEndDebugUtilsLabelEXT(VkQueue queue) const
{
    TKIT_ASSERT(this->vkQueueEndDebugUtilsLabelEXT,
                "[VULKIT][LOADER] The function 'vkQueueEndDebugUtilsLabelEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkQueueEndDebugUtilsLabelEXT(queue);
}
#endif
#if defined(VK_EXT_debug_utils)
void DeviceTable::QueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) const
{
    TKIT_ASSERT(this->vkQueueInsertDebugUtilsLabelEXT,
                "[VULKIT][LOADER] The function 'vkQueueInsertDebugUtilsLabelEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo);
}
#endif
#if defined(VK_EXT_debug_utils)
void DeviceTable::CmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer,
                                             const VkDebugUtilsLabelEXT *pLabelInfo) const
{
    TKIT_ASSERT(this->vkCmdBeginDebugUtilsLabelEXT,
                "[VULKIT][LOADER] The function 'vkCmdBeginDebugUtilsLabelEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
}
#endif
#if defined(VK_EXT_debug_utils)
void DeviceTable::CmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) const
{
    TKIT_ASSERT(this->vkCmdEndDebugUtilsLabelEXT,
                "[VULKIT][LOADER] The function 'vkCmdEndDebugUtilsLabelEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdEndDebugUtilsLabelEXT(commandBuffer);
}
#endif
#if defined(VK_EXT_debug_utils)
void DeviceTable::CmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer,
                                              const VkDebugUtilsLabelEXT *pLabelInfo) const
{
    TKIT_ASSERT(this->vkCmdInsertDebugUtilsLabelEXT,
                "[VULKIT][LOADER] The function 'vkCmdInsertDebugUtilsLabelEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
}
#endif
#if defined(VK_EXT_external_memory_host)
VkResult DeviceTable::GetMemoryHostPointerPropertiesEXT(
    VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer,
    VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties) const
{
    TKIT_ASSERT(this->vkGetMemoryHostPointerPropertiesEXT,
                "[VULKIT][LOADER] The function 'vkGetMemoryHostPointerPropertiesEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties);
}
#endif
#if defined(VK_AMD_buffer_marker)
void DeviceTable::CmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage,
                                          VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const
{
    TKIT_ASSERT(this->vkCmdWriteBufferMarkerAMD,
                "[VULKIT][LOADER] The function 'vkCmdWriteBufferMarkerAMD' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
VkResult DeviceTable::CreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo,
                                        const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const
{
    TKIT_ASSERT(this->vkCreateRenderPass2,
                "[VULKIT][LOADER] The function 'vkCreateRenderPass2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateRenderPass2(device, pCreateInfo, pAllocator, pRenderPass);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
void DeviceTable::CmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin,
                                      const VkSubpassBeginInfo *pSubpassBeginInfo) const
{
    TKIT_ASSERT(this->vkCmdBeginRenderPass2,
                "[VULKIT][LOADER] The function 'vkCmdBeginRenderPass2' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBeginRenderPass2(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
void DeviceTable::CmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo,
                                  const VkSubpassEndInfo *pSubpassEndInfo) const
{
    TKIT_ASSERT(this->vkCmdNextSubpass2,
                "[VULKIT][LOADER] The function 'vkCmdNextSubpass2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdNextSubpass2(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
void DeviceTable::CmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) const
{
    TKIT_ASSERT(this->vkCmdEndRenderPass2,
                "[VULKIT][LOADER] The function 'vkCmdEndRenderPass2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdEndRenderPass2(commandBuffer, pSubpassEndInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
VkResult DeviceTable::GetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const
{
    TKIT_ASSERT(this->vkGetSemaphoreCounterValue,
                "[VULKIT][LOADER] The function 'vkGetSemaphoreCounterValue' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetSemaphoreCounterValue(device, semaphore, pValue);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
VkResult DeviceTable::WaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) const
{
    TKIT_ASSERT(this->vkWaitSemaphores,
                "[VULKIT][LOADER] The function 'vkWaitSemaphores' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkWaitSemaphores(device, pWaitInfo, timeout);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
VkResult DeviceTable::SignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) const
{
    TKIT_ASSERT(this->vkSignalSemaphore,
                "[VULKIT][LOADER] The function 'vkSignalSemaphore' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkSignalSemaphore(device, pSignalInfo);
}
#endif
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
VkResult DeviceTable::GetAndroidHardwareBufferPropertiesANDROID(
    VkDevice device, const struct AHardwareBuffer *buffer, VkAndroidHardwareBufferPropertiesANDROID *pProperties) const
{
    TKIT_ASSERT(this->vkGetAndroidHardwareBufferPropertiesANDROID,
                "[VULKIT][LOADER] The function 'vkGetAndroidHardwareBufferPropertiesANDROID' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties);
}
#endif
#if defined(VK_ANDROID_external_memory_android_hardware_buffer)
VkResult DeviceTable::GetMemoryAndroidHardwareBufferANDROID(VkDevice device,
                                                            const VkMemoryGetAndroidHardwareBufferInfoANDROID *pInfo,
                                                            struct AHardwareBuffer **pBuffer) const
{
    TKIT_ASSERT(this->vkGetMemoryAndroidHardwareBufferANDROID,
                "[VULKIT][LOADER] The function 'vkGetMemoryAndroidHardwareBufferANDROID' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
void DeviceTable::CmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                       VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                       uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawIndirectCount,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndirectCount' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
void DeviceTable::CmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                              VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                              uint32_t maxDrawCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawIndexedIndirectCount,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndexedIndirectCount' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawIndexedIndirectCount(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                        stride);
}
#endif
#if defined(VK_NV_device_diagnostic_checkpoints)
void DeviceTable::CmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker) const
{
    TKIT_ASSERT(this->vkCmdSetCheckpointNV,
                "[VULKIT][LOADER] The function 'vkCmdSetCheckpointNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker);
}
#endif
#if defined(VK_NV_device_diagnostic_checkpoints)
void DeviceTable::GetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount,
                                           VkCheckpointDataNV *pCheckpointData) const
{
    TKIT_ASSERT(this->vkGetQueueCheckpointDataNV,
                "[VULKIT][LOADER] The function 'vkGetQueueCheckpointDataNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData);
}
#endif
#if defined(VK_EXT_transform_feedback)
void DeviceTable::CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding,
                                                     uint32_t bindingCount, const VkBuffer *pBuffers,
                                                     const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes) const
{
    TKIT_ASSERT(this->vkCmdBindTransformFeedbackBuffersEXT,
                "[VULKIT][LOADER] The function 'vkCmdBindTransformFeedbackBuffersEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
}
#endif
#if defined(VK_EXT_transform_feedback)
void DeviceTable::CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                               uint32_t counterBufferCount, const VkBuffer *pCounterBuffers,
                                               const VkDeviceSize *pCounterBufferOffsets) const
{
    TKIT_ASSERT(this->vkCmdBeginTransformFeedbackEXT,
                "[VULKIT][LOADER] The function 'vkCmdBeginTransformFeedbackEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers,
                                         pCounterBufferOffsets);
}
#endif
#if defined(VK_EXT_transform_feedback)
void DeviceTable::CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer,
                                             uint32_t counterBufferCount, const VkBuffer *pCounterBuffers,
                                             const VkDeviceSize *pCounterBufferOffsets) const
{
    TKIT_ASSERT(this->vkCmdEndTransformFeedbackEXT,
                "[VULKIT][LOADER] The function 'vkCmdEndTransformFeedbackEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers,
                                       pCounterBufferOffsets);
}
#endif
#if defined(VK_EXT_transform_feedback)
void DeviceTable::CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                          VkQueryControlFlags flags, uint32_t index) const
{
    TKIT_ASSERT(this->vkCmdBeginQueryIndexedEXT,
                "[VULKIT][LOADER] The function 'vkCmdBeginQueryIndexedEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index);
}
#endif
#if defined(VK_EXT_transform_feedback)
void DeviceTable::CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query,
                                        uint32_t index) const
{
    TKIT_ASSERT(this->vkCmdEndQueryIndexedEXT,
                "[VULKIT][LOADER] The function 'vkCmdEndQueryIndexedEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index);
}
#endif
#if defined(VK_EXT_transform_feedback)
void DeviceTable::CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount,
                                              uint32_t firstInstance, VkBuffer counterBuffer,
                                              VkDeviceSize counterBufferOffset, uint32_t counterOffset,
                                              uint32_t vertexStride) const
{
    TKIT_ASSERT(this->vkCmdDrawIndirectByteCountEXT,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndirectByteCountEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset,
                                        counterOffset, vertexStride);
}
#endif
#if (defined(VK_NV_scissor_exclusive) && VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION >= 2)
void DeviceTable::CmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor,
                                           uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors) const
{
    TKIT_ASSERT(this->vkCmdSetExclusiveScissorNV,
                "[VULKIT][LOADER] The function 'vkCmdSetExclusiveScissorNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
}
#endif
#if VK_HEADER_VERSION >= 241 && ((defined(VK_NV_scissor_exclusive) && VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION >= 2))
void DeviceTable::CmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor,
                                                 uint32_t exclusiveScissorCount,
                                                 const VkBool32 *pExclusiveScissorEnables) const
{
    TKIT_ASSERT(this->vkCmdSetExclusiveScissorEnableNV,
                "[VULKIT][LOADER] The function 'vkCmdSetExclusiveScissorEnableNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetExclusiveScissorEnableNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount,
                                           pExclusiveScissorEnables);
}
#endif
#if defined(VK_NV_shading_rate_image)
void DeviceTable::CmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView,
                                            VkImageLayout imageLayout) const
{
    TKIT_ASSERT(this->vkCmdBindShadingRateImageNV,
                "[VULKIT][LOADER] The function 'vkCmdBindShadingRateImageNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout);
}
#endif
#if defined(VK_NV_shading_rate_image)
void DeviceTable::CmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport,
                                                     uint32_t viewportCount,
                                                     const VkShadingRatePaletteNV *pShadingRatePalettes) const
{
    TKIT_ASSERT(this->vkCmdSetViewportShadingRatePaletteNV,
                "[VULKIT][LOADER] The function 'vkCmdSetViewportShadingRatePaletteNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
}
#endif
#if defined(VK_NV_shading_rate_image)
void DeviceTable::CmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType,
                                            uint32_t customSampleOrderCount,
                                            const VkCoarseSampleOrderCustomNV *pCustomSampleOrders) const
{
    TKIT_ASSERT(this->vkCmdSetCoarseSampleOrderNV,
                "[VULKIT][LOADER] The function 'vkCmdSetCoarseSampleOrderNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
}
#endif
#if defined(VK_NV_mesh_shader)
void DeviceTable::CmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) const
{
    TKIT_ASSERT(this->vkCmdDrawMeshTasksNV,
                "[VULKIT][LOADER] The function 'vkCmdDrawMeshTasksNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask);
}
#endif
#if defined(VK_NV_mesh_shader)
void DeviceTable::CmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                             uint32_t drawCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawMeshTasksIndirectNV,
                "[VULKIT][LOADER] The function 'vkCmdDrawMeshTasksIndirectNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride);
}
#endif
#if (defined(VK_NV_mesh_shader) &&                                                                                     \
     (defined(VKIT_API_VERSION_1_2) || defined(VK_KHR_draw_indirect_count) || defined(VK_AMD_draw_indirect_count)))
void DeviceTable::CmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                  VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                                  uint32_t maxDrawCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawMeshTasksIndirectCountNV,
                "[VULKIT][LOADER] The function 'vkCmdDrawMeshTasksIndirectCountNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                            stride);
}
#endif
#if defined(VK_EXT_mesh_shader)
void DeviceTable::CmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY,
                                      uint32_t groupCountZ) const
{
    TKIT_ASSERT(this->vkCmdDrawMeshTasksEXT,
                "[VULKIT][LOADER] The function 'vkCmdDrawMeshTasksEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawMeshTasksEXT(commandBuffer, groupCountX, groupCountY, groupCountZ);
}
#endif
#if defined(VK_EXT_mesh_shader)
void DeviceTable::CmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                              uint32_t drawCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawMeshTasksIndirectEXT,
                "[VULKIT][LOADER] The function 'vkCmdDrawMeshTasksIndirectEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawMeshTasksIndirectEXT(commandBuffer, buffer, offset, drawCount, stride);
}
#endif
#if (defined(VK_EXT_mesh_shader) &&                                                                                    \
     (defined(VKIT_API_VERSION_1_2) || defined(VK_KHR_draw_indirect_count) || defined(VK_AMD_draw_indirect_count)))
void DeviceTable::CmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                   VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                                   uint32_t maxDrawCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawMeshTasksIndirectCountEXT,
                "[VULKIT][LOADER] The function 'vkCmdDrawMeshTasksIndirectCountEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdDrawMeshTasksIndirectCountEXT(commandBuffer, buffer, offset, countBuffer, countBufferOffset,
                                             maxDrawCount, stride);
}
#endif
#if defined(VK_NV_ray_tracing)
VkResult DeviceTable::CompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) const
{
    TKIT_ASSERT(this->vkCompileDeferredNV,
                "[VULKIT][LOADER] The function 'vkCompileDeferredNV' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCompileDeferredNV(device, pipeline, shader);
}
#endif
#if defined(VK_NV_ray_tracing)
VkResult DeviceTable::CreateAccelerationStructureNV(VkDevice device,
                                                    const VkAccelerationStructureCreateInfoNV *pCreateInfo,
                                                    const VkAllocationCallbacks *pAllocator,
                                                    VkAccelerationStructureNV *pAccelerationStructure) const
{
    TKIT_ASSERT(this->vkCreateAccelerationStructureNV,
                "[VULKIT][LOADER] The function 'vkCreateAccelerationStructureNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
#endif
#if defined(VK_HUAWEI_invocation_mask)
void DeviceTable::CmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView,
                                              VkImageLayout imageLayout) const
{
    TKIT_ASSERT(this->vkCmdBindInvocationMaskHUAWEI,
                "[VULKIT][LOADER] The function 'vkCmdBindInvocationMaskHUAWEI' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindInvocationMaskHUAWEI(commandBuffer, imageView, imageLayout);
}
#endif
#if defined(VK_KHR_acceleration_structure)
void DeviceTable::DestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure,
                                                  const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyAccelerationStructureKHR,
                "[VULKIT][LOADER] The function 'vkDestroyAccelerationStructureKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkDestroyAccelerationStructureKHR(device, accelerationStructure, pAllocator);
}
#endif
#if defined(VK_NV_ray_tracing)
void DeviceTable::DestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure,
                                                 const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyAccelerationStructureNV,
                "[VULKIT][LOADER] The function 'vkDestroyAccelerationStructureNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator);
}
#endif
#if defined(VK_NV_ray_tracing)
void DeviceTable::GetAccelerationStructureMemoryRequirementsNV(
    VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo,
    VkMemoryRequirements2KHR *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetAccelerationStructureMemoryRequirementsNV,
                "[VULKIT][LOADER] The function 'vkGetAccelerationStructureMemoryRequirementsNV' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_NV_ray_tracing)
VkResult DeviceTable::BindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount,
                                                        const VkBindAccelerationStructureMemoryInfoNV *pBindInfos) const
{
    TKIT_ASSERT(this->vkBindAccelerationStructureMemoryNV,
                "[VULKIT][LOADER] The function 'vkBindAccelerationStructureMemoryNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos);
}
#endif
#if defined(VK_NV_ray_tracing)
void DeviceTable::CmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst,
                                                 VkAccelerationStructureNV src,
                                                 VkCopyAccelerationStructureModeKHR mode) const
{
    TKIT_ASSERT(this->vkCmdCopyAccelerationStructureNV,
                "[VULKIT][LOADER] The function 'vkCmdCopyAccelerationStructureNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode);
}
#endif
#if defined(VK_KHR_acceleration_structure)
void DeviceTable::CmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer,
                                                  const VkCopyAccelerationStructureInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyAccelerationStructureKHR,
                "[VULKIT][LOADER] The function 'vkCmdCopyAccelerationStructureKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdCopyAccelerationStructureKHR(commandBuffer, pInfo);
}
#endif
#if defined(VK_KHR_acceleration_structure)
VkResult DeviceTable::CopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                   const VkCopyAccelerationStructureInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkCopyAccelerationStructureKHR,
                "[VULKIT][LOADER] The function 'vkCopyAccelerationStructureKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCopyAccelerationStructureKHR(device, deferredOperation, pInfo);
}
#endif
#if defined(VK_KHR_acceleration_structure)
void DeviceTable::CmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer,
                                                          const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyAccelerationStructureToMemoryKHR,
                "[VULKIT][LOADER] The function 'vkCmdCopyAccelerationStructureToMemoryKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdCopyAccelerationStructureToMemoryKHR(commandBuffer, pInfo);
}
#endif
#if defined(VK_KHR_acceleration_structure)
VkResult DeviceTable::CopyAccelerationStructureToMemoryKHR(
    VkDevice device, VkDeferredOperationKHR deferredOperation,
    const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkCopyAccelerationStructureToMemoryKHR,
                "[VULKIT][LOADER] The function 'vkCopyAccelerationStructureToMemoryKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkCopyAccelerationStructureToMemoryKHR(device, deferredOperation, pInfo);
}
#endif
#if defined(VK_KHR_acceleration_structure)
void DeviceTable::CmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer,
                                                          const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyMemoryToAccelerationStructureKHR,
                "[VULKIT][LOADER] The function 'vkCmdCopyMemoryToAccelerationStructureKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdCopyMemoryToAccelerationStructureKHR(commandBuffer, pInfo);
}
#endif
#if defined(VK_KHR_acceleration_structure)
VkResult DeviceTable::CopyMemoryToAccelerationStructureKHR(
    VkDevice device, VkDeferredOperationKHR deferredOperation,
    const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkCopyMemoryToAccelerationStructureKHR,
                "[VULKIT][LOADER] The function 'vkCopyMemoryToAccelerationStructureKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkCopyMemoryToAccelerationStructureKHR(device, deferredOperation, pInfo);
}
#endif
#if defined(VK_KHR_acceleration_structure)
void DeviceTable::CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer,
                                                              uint32_t accelerationStructureCount,
                                                              const VkAccelerationStructureKHR *pAccelerationStructures,
                                                              VkQueryType queryType, VkQueryPool queryPool,
                                                              uint32_t firstQuery) const
{
    TKIT_ASSERT(this->vkCmdWriteAccelerationStructuresPropertiesKHR,
                "[VULKIT][LOADER] The function 'vkCmdWriteAccelerationStructuresPropertiesKHR' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkCmdWriteAccelerationStructuresPropertiesKHR(commandBuffer, accelerationStructureCount,
                                                        pAccelerationStructures, queryType, queryPool, firstQuery);
}
#endif
#if defined(VK_NV_ray_tracing)
void DeviceTable::CmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer,
                                                             uint32_t accelerationStructureCount,
                                                             const VkAccelerationStructureNV *pAccelerationStructures,
                                                             VkQueryType queryType, VkQueryPool queryPool,
                                                             uint32_t firstQuery) const
{
    TKIT_ASSERT(this->vkCmdWriteAccelerationStructuresPropertiesNV,
                "[VULKIT][LOADER] The function 'vkCmdWriteAccelerationStructuresPropertiesNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount,
                                                       pAccelerationStructures, queryType, queryPool, firstQuery);
}
#endif
#if defined(VK_NV_ray_tracing)
void DeviceTable::CmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer,
                                                  const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData,
                                                  VkDeviceSize instanceOffset, VkBool32 update,
                                                  VkAccelerationStructureNV dst, VkAccelerationStructureNV src,
                                                  VkBuffer scratch, VkDeviceSize scratchOffset) const
{
    TKIT_ASSERT(this->vkCmdBuildAccelerationStructureNV,
                "[VULKIT][LOADER] The function 'vkCmdBuildAccelerationStructureNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src,
                                            scratch, scratchOffset);
}
#endif
#if defined(VK_KHR_acceleration_structure)
VkResult DeviceTable::WriteAccelerationStructuresPropertiesKHR(
    VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures,
    VkQueryType queryType, size_t dataSize, void *pData, size_t stride) const
{
    TKIT_ASSERT(this->vkWriteAccelerationStructuresPropertiesKHR,
                "[VULKIT][LOADER] The function 'vkWriteAccelerationStructuresPropertiesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkWriteAccelerationStructuresPropertiesKHR(device, accelerationStructureCount, pAccelerationStructures,
                                                            queryType, dataSize, pData, stride);
}
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
void DeviceTable::CmdTraceRaysKHR(VkCommandBuffer commandBuffer,
                                  const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable,
                                  const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable,
                                  const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable,
                                  const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width,
                                  uint32_t height, uint32_t depth) const
{
    TKIT_ASSERT(this->vkCmdTraceRaysKHR,
                "[VULKIT][LOADER] The function 'vkCmdTraceRaysKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdTraceRaysKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable,
                            pCallableShaderBindingTable, width, height, depth);
}
#endif
#if defined(VK_NV_ray_tracing)
void DeviceTable::CmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer,
                                 VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer,
                                 VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride,
                                 VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset,
                                 VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer,
                                 VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride,
                                 uint32_t width, uint32_t height, uint32_t depth) const
{
    TKIT_ASSERT(this->vkCmdTraceRaysNV,
                "[VULKIT][LOADER] The function 'vkCmdTraceRaysNV' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset,
                           missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride,
                           hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride,
                           callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride,
                           width, height, depth);
}
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
VkResult DeviceTable::GetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup,
                                                         uint32_t groupCount, size_t dataSize, void *pData) const
{
    TKIT_ASSERT(this->vkGetRayTracingShaderGroupHandlesKHR,
                "[VULKIT][LOADER] The function 'vkGetRayTracingShaderGroupHandlesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetRayTracingShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
VkResult DeviceTable::GetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline,
                                                                      uint32_t firstGroup, uint32_t groupCount,
                                                                      size_t dataSize, void *pData) const
{
    TKIT_ASSERT(this->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR,
                "[VULKIT][LOADER] The function 'vkGetRayTracingCaptureReplayShaderGroupHandlesKHR' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    return this->vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(device, pipeline, firstGroup, groupCount, dataSize,
                                                                   pData);
}
#endif
#if defined(VK_NV_ray_tracing)
VkResult DeviceTable::GetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure,
                                                       size_t dataSize, void *pData) const
{
    TKIT_ASSERT(this->vkGetAccelerationStructureHandleNV,
                "[VULKIT][LOADER] The function 'vkGetAccelerationStructureHandleNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData);
}
#endif
#if defined(VK_NV_ray_tracing)
VkResult DeviceTable::CreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache,
                                                  uint32_t createInfoCount,
                                                  const VkRayTracingPipelineCreateInfoNV *pCreateInfos,
                                                  const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const
{
    TKIT_ASSERT(this->vkCreateRayTracingPipelinesNV,
                "[VULKIT][LOADER] The function 'vkCreateRayTracingPipelinesNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
                                               pPipelines);
}
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
VkResult DeviceTable::CreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                   VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                                   const VkRayTracingPipelineCreateInfoKHR *pCreateInfos,
                                                   const VkAllocationCallbacks *pAllocator,
                                                   VkPipeline *pPipelines) const
{
    TKIT_ASSERT(this->vkCreateRayTracingPipelinesKHR,
                "[VULKIT][LOADER] The function 'vkCreateRayTracingPipelinesKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateRayTracingPipelinesKHR(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos,
                                                pAllocator, pPipelines);
}
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
void DeviceTable::CmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer,
                                          const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable,
                                          const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable,
                                          const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable,
                                          const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable,
                                          VkDeviceAddress indirectDeviceAddress) const
{
    TKIT_ASSERT(this->vkCmdTraceRaysIndirectKHR,
                "[VULKIT][LOADER] The function 'vkCmdTraceRaysIndirectKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdTraceRaysIndirectKHR(commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable,
                                    pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
}
#endif
#if (defined(VK_KHR_ray_tracing_maintenance1) && defined(VK_KHR_ray_tracing_pipeline))
void DeviceTable::CmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) const
{
    TKIT_ASSERT(this->vkCmdTraceRaysIndirect2KHR,
                "[VULKIT][LOADER] The function 'vkCmdTraceRaysIndirect2KHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdTraceRaysIndirect2KHR(commandBuffer, indirectDeviceAddress);
}
#endif
#if defined(VK_NV_cluster_acceleration_structure)
void DeviceTable::GetClusterAccelerationStructureBuildSizesNV(VkDevice device,
                                                              const VkClusterAccelerationStructureInputInfoNV *pInfo,
                                                              VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const
{
    TKIT_ASSERT(this->vkGetClusterAccelerationStructureBuildSizesNV,
                "[VULKIT][LOADER] The function 'vkGetClusterAccelerationStructureBuildSizesNV' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkGetClusterAccelerationStructureBuildSizesNV(device, pInfo, pSizeInfo);
}
#endif
#if defined(VK_NV_cluster_acceleration_structure)
void DeviceTable::CmdBuildClusterAccelerationStructureIndirectNV(
    VkCommandBuffer commandBuffer, const VkClusterAccelerationStructureCommandsInfoNV *pCommandInfos) const
{
    TKIT_ASSERT(this->vkCmdBuildClusterAccelerationStructureIndirectNV,
                "[VULKIT][LOADER] The function 'vkCmdBuildClusterAccelerationStructureIndirectNV' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkCmdBuildClusterAccelerationStructureIndirectNV(commandBuffer, pCommandInfos);
}
#endif
#if defined(VK_KHR_acceleration_structure)
void DeviceTable::GetDeviceAccelerationStructureCompatibilityKHR(
    VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo,
    VkAccelerationStructureCompatibilityKHR *pCompatibility) const
{
    TKIT_ASSERT(this->vkGetDeviceAccelerationStructureCompatibilityKHR,
                "[VULKIT][LOADER] The function 'vkGetDeviceAccelerationStructureCompatibilityKHR' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkGetDeviceAccelerationStructureCompatibilityKHR(device, pVersionInfo, pCompatibility);
}
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
VkDeviceSize DeviceTable::GetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group,
                                                               VkShaderGroupShaderKHR groupShader) const
{
    TKIT_ASSERT(this->vkGetRayTracingShaderGroupStackSizeKHR,
                "[VULKIT][LOADER] The function 'vkGetRayTracingShaderGroupStackSizeKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetRayTracingShaderGroupStackSizeKHR(device, pipeline, group, groupShader);
}
#endif
#if defined(VK_KHR_ray_tracing_pipeline)
void DeviceTable::CmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) const
{
    TKIT_ASSERT(this->vkCmdSetRayTracingPipelineStackSizeKHR,
                "[VULKIT][LOADER] The function 'vkCmdSetRayTracingPipelineStackSizeKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetRayTracingPipelineStackSizeKHR(commandBuffer, pipelineStackSize);
}
#endif
#if defined(VK_NVX_image_view_handle)
uint32_t DeviceTable::GetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX *pInfo) const
{
    TKIT_ASSERT(this->vkGetImageViewHandleNVX,
                "[VULKIT][LOADER] The function 'vkGetImageViewHandleNVX' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetImageViewHandleNVX(device, pInfo);
}
#endif
#if (defined(VK_NVX_image_view_handle) && VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION >= 3)
uint64_t DeviceTable::GetImageViewHandle64NVX(VkDevice device, const VkImageViewHandleInfoNVX *pInfo) const
{
    TKIT_ASSERT(this->vkGetImageViewHandle64NVX,
                "[VULKIT][LOADER] The function 'vkGetImageViewHandle64NVX' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetImageViewHandle64NVX(device, pInfo);
}
#endif
#if (defined(VK_NVX_image_view_handle) && VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION >= 3 &&                                \
     VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION >= 2)
VkResult DeviceTable::GetImageViewAddressNVX(VkDevice device, VkImageView imageView,
                                             VkImageViewAddressPropertiesNVX *pProperties) const
{
    TKIT_ASSERT(this->vkGetImageViewAddressNVX,
                "[VULKIT][LOADER] The function 'vkGetImageViewAddressNVX' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetImageViewAddressNVX(device, imageView, pProperties);
}
#endif
#if (defined(VK_EXT_full_screen_exclusive) && (defined(VK_KHR_device_group) || defined(VKIT_API_VERSION_1_1)))
VkResult DeviceTable::GetDeviceGroupSurfacePresentModes2EXT(VkDevice device,
                                                            const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo,
                                                            VkDeviceGroupPresentModeFlagsKHR *pModes) const
{
    TKIT_ASSERT(this->vkGetDeviceGroupSurfacePresentModes2EXT,
                "[VULKIT][LOADER] The function 'vkGetDeviceGroupSurfacePresentModes2EXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes);
}
#endif
#if defined(VK_EXT_full_screen_exclusive)
VkResult DeviceTable::AcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const
{
    TKIT_ASSERT(this->vkAcquireFullScreenExclusiveModeEXT,
                "[VULKIT][LOADER] The function 'vkAcquireFullScreenExclusiveModeEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkAcquireFullScreenExclusiveModeEXT(device, swapchain);
}
#endif
#if defined(VK_EXT_full_screen_exclusive)
VkResult DeviceTable::ReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) const
{
    TKIT_ASSERT(this->vkReleaseFullScreenExclusiveModeEXT,
                "[VULKIT][LOADER] The function 'vkReleaseFullScreenExclusiveModeEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkReleaseFullScreenExclusiveModeEXT(device, swapchain);
}
#endif
#if defined(VK_KHR_performance_query)
VkResult DeviceTable::AcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkAcquireProfilingLockKHR,
                "[VULKIT][LOADER] The function 'vkAcquireProfilingLockKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkAcquireProfilingLockKHR(device, pInfo);
}
#endif
#if defined(VK_KHR_performance_query)
void DeviceTable::ReleaseProfilingLockKHR(VkDevice device) const
{
    TKIT_ASSERT(this->vkReleaseProfilingLockKHR,
                "[VULKIT][LOADER] The function 'vkReleaseProfilingLockKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkReleaseProfilingLockKHR(device);
}
#endif
#if defined(VK_EXT_image_drm_format_modifier)
VkResult DeviceTable::GetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image,
                                                             VkImageDrmFormatModifierPropertiesEXT *pProperties) const
{
    TKIT_ASSERT(this->vkGetImageDrmFormatModifierPropertiesEXT,
                "[VULKIT][LOADER] The function 'vkGetImageDrmFormatModifierPropertiesEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetImageDrmFormatModifierPropertiesEXT(device, image, pProperties);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
uint64_t DeviceTable::GetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const
{
    TKIT_ASSERT(this->vkGetBufferOpaqueCaptureAddress,
                "[VULKIT][LOADER] The function 'vkGetBufferOpaqueCaptureAddress' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetBufferOpaqueCaptureAddress(device, pInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
VkDeviceAddress DeviceTable::GetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) const
{
    TKIT_ASSERT(this->vkGetBufferDeviceAddress,
                "[VULKIT][LOADER] The function 'vkGetBufferDeviceAddress' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetBufferDeviceAddress(device, pInfo);
}
#endif
#if defined(VK_INTEL_performance_query)
VkResult DeviceTable::InitializePerformanceApiINTEL(VkDevice device,
                                                    const VkInitializePerformanceApiInfoINTEL *pInitializeInfo) const
{
    TKIT_ASSERT(this->vkInitializePerformanceApiINTEL,
                "[VULKIT][LOADER] The function 'vkInitializePerformanceApiINTEL' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkInitializePerformanceApiINTEL(device, pInitializeInfo);
}
#endif
#if defined(VK_INTEL_performance_query)
void DeviceTable::UninitializePerformanceApiINTEL(VkDevice device) const
{
    TKIT_ASSERT(this->vkUninitializePerformanceApiINTEL,
                "[VULKIT][LOADER] The function 'vkUninitializePerformanceApiINTEL' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkUninitializePerformanceApiINTEL(device);
}
#endif
#if defined(VK_INTEL_performance_query)
VkResult DeviceTable::CmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer,
                                                   const VkPerformanceMarkerInfoINTEL *pMarkerInfo) const
{
    TKIT_ASSERT(this->vkCmdSetPerformanceMarkerINTEL,
                "[VULKIT][LOADER] The function 'vkCmdSetPerformanceMarkerINTEL' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo);
}
#endif
#if defined(VK_INTEL_performance_query)
VkResult DeviceTable::CmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer,
                                                         const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo) const
{
    TKIT_ASSERT(this->vkCmdSetPerformanceStreamMarkerINTEL,
                "[VULKIT][LOADER] The function 'vkCmdSetPerformanceStreamMarkerINTEL' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo);
}
#endif
#if defined(VK_INTEL_performance_query)
VkResult DeviceTable::CmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer,
                                                     const VkPerformanceOverrideInfoINTEL *pOverrideInfo) const
{
    TKIT_ASSERT(this->vkCmdSetPerformanceOverrideINTEL,
                "[VULKIT][LOADER] The function 'vkCmdSetPerformanceOverrideINTEL' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo);
}
#endif
#if defined(VK_INTEL_performance_query)
VkResult DeviceTable::AcquirePerformanceConfigurationINTEL(
    VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo,
    VkPerformanceConfigurationINTEL *pConfiguration) const
{
    TKIT_ASSERT(this->vkAcquirePerformanceConfigurationINTEL,
                "[VULKIT][LOADER] The function 'vkAcquirePerformanceConfigurationINTEL' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkAcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration);
}
#endif
#if defined(VK_INTEL_performance_query)
VkResult DeviceTable::ReleasePerformanceConfigurationINTEL(VkDevice device,
                                                           VkPerformanceConfigurationINTEL configuration) const
{
    TKIT_ASSERT(this->vkReleasePerformanceConfigurationINTEL,
                "[VULKIT][LOADER] The function 'vkReleasePerformanceConfigurationINTEL' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkReleasePerformanceConfigurationINTEL(device, configuration);
}
#endif
#if defined(VK_INTEL_performance_query)
VkResult DeviceTable::QueueSetPerformanceConfigurationINTEL(VkQueue queue,
                                                            VkPerformanceConfigurationINTEL configuration) const
{
    TKIT_ASSERT(this->vkQueueSetPerformanceConfigurationINTEL,
                "[VULKIT][LOADER] The function 'vkQueueSetPerformanceConfigurationINTEL' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkQueueSetPerformanceConfigurationINTEL(queue, configuration);
}
#endif
#if defined(VK_INTEL_performance_query)
VkResult DeviceTable::GetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter,
                                                   VkPerformanceValueINTEL *pValue) const
{
    TKIT_ASSERT(this->vkGetPerformanceParameterINTEL,
                "[VULKIT][LOADER] The function 'vkGetPerformanceParameterINTEL' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetPerformanceParameterINTEL(device, parameter, pValue);
}
#endif
#if defined(VKIT_API_VERSION_1_2)
uint64_t DeviceTable::GetDeviceMemoryOpaqueCaptureAddress(VkDevice device,
                                                          const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) const
{
    TKIT_ASSERT(this->vkGetDeviceMemoryOpaqueCaptureAddress,
                "[VULKIT][LOADER] The function 'vkGetDeviceMemoryOpaqueCaptureAddress' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetDeviceMemoryOpaqueCaptureAddress(device, pInfo);
}
#endif
#if defined(VK_KHR_pipeline_executable_properties)
VkResult DeviceTable::GetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo,
                                                         uint32_t *pExecutableCount,
                                                         VkPipelineExecutablePropertiesKHR *pProperties) const
{
    TKIT_ASSERT(this->vkGetPipelineExecutablePropertiesKHR,
                "[VULKIT][LOADER] The function 'vkGetPipelineExecutablePropertiesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties);
}
#endif
#if defined(VK_KHR_pipeline_executable_properties)
VkResult DeviceTable::GetPipelineExecutableStatisticsKHR(VkDevice device,
                                                         const VkPipelineExecutableInfoKHR *pExecutableInfo,
                                                         uint32_t *pStatisticCount,
                                                         VkPipelineExecutableStatisticKHR *pStatistics) const
{
    TKIT_ASSERT(this->vkGetPipelineExecutableStatisticsKHR,
                "[VULKIT][LOADER] The function 'vkGetPipelineExecutableStatisticsKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics);
}
#endif
#if defined(VK_KHR_pipeline_executable_properties)
VkResult DeviceTable::GetPipelineExecutableInternalRepresentationsKHR(
    VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount,
    VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations) const
{
    TKIT_ASSERT(this->vkGetPipelineExecutableInternalRepresentationsKHR,
                "[VULKIT][LOADER] The function 'vkGetPipelineExecutableInternalRepresentationsKHR' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    return this->vkGetPipelineExecutableInternalRepresentationsKHR(
        device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdSetLineStipple(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                    uint16_t lineStipplePattern) const
{
    TKIT_ASSERT(this->vkCmdSetLineStipple,
                "[VULKIT][LOADER] The function 'vkCmdSetLineStipple' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetLineStipple(commandBuffer, lineStippleFactor, lineStipplePattern);
}
#endif
#if defined(VK_KHR_acceleration_structure)
VkResult DeviceTable::CreateAccelerationStructureKHR(VkDevice device,
                                                     const VkAccelerationStructureCreateInfoKHR *pCreateInfo,
                                                     const VkAllocationCallbacks *pAllocator,
                                                     VkAccelerationStructureKHR *pAccelerationStructure) const
{
    TKIT_ASSERT(this->vkCreateAccelerationStructureKHR,
                "[VULKIT][LOADER] The function 'vkCreateAccelerationStructureKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateAccelerationStructureKHR(device, pCreateInfo, pAllocator, pAccelerationStructure);
}
#endif
#if defined(VK_KHR_acceleration_structure)
void DeviceTable::CmdBuildAccelerationStructuresKHR(
    VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos) const
{
    TKIT_ASSERT(this->vkCmdBuildAccelerationStructuresKHR,
                "[VULKIT][LOADER] The function 'vkCmdBuildAccelerationStructuresKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdBuildAccelerationStructuresKHR(commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
}
#endif
#if defined(VK_KHR_acceleration_structure)
void DeviceTable::CmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount,
                                                            const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
                                                            const VkDeviceAddress *pIndirectDeviceAddresses,
                                                            const uint32_t *pIndirectStrides,
                                                            const uint32_t *const *ppMaxPrimitiveCounts) const
{
    TKIT_ASSERT(this->vkCmdBuildAccelerationStructuresIndirectKHR,
                "[VULKIT][LOADER] The function 'vkCmdBuildAccelerationStructuresIndirectKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdBuildAccelerationStructuresIndirectKHR(commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses,
                                                      pIndirectStrides, ppMaxPrimitiveCounts);
}
#endif
#if defined(VK_KHR_acceleration_structure)
VkResult DeviceTable::BuildAccelerationStructuresKHR(
    VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount,
    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
    const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos) const
{
    TKIT_ASSERT(this->vkBuildAccelerationStructuresKHR,
                "[VULKIT][LOADER] The function 'vkBuildAccelerationStructuresKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkBuildAccelerationStructuresKHR(device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
}
#endif
#if defined(VK_KHR_acceleration_structure)
VkDeviceAddress DeviceTable::GetAccelerationStructureDeviceAddressKHR(
    VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkGetAccelerationStructureDeviceAddressKHR,
                "[VULKIT][LOADER] The function 'vkGetAccelerationStructureDeviceAddressKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetAccelerationStructureDeviceAddressKHR(device, pInfo);
}
#endif
#if defined(VK_KHR_deferred_host_operations)
VkResult DeviceTable::CreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks *pAllocator,
                                                 VkDeferredOperationKHR *pDeferredOperation) const
{
    TKIT_ASSERT(this->vkCreateDeferredOperationKHR,
                "[VULKIT][LOADER] The function 'vkCreateDeferredOperationKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDeferredOperationKHR(device, pAllocator, pDeferredOperation);
}
#endif
#if defined(VK_KHR_deferred_host_operations)
void DeviceTable::DestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation,
                                              const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyDeferredOperationKHR,
                "[VULKIT][LOADER] The function 'vkDestroyDeferredOperationKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyDeferredOperationKHR(device, operation, pAllocator);
}
#endif
#if defined(VK_KHR_deferred_host_operations)
uint32_t DeviceTable::GetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) const
{
    TKIT_ASSERT(this->vkGetDeferredOperationMaxConcurrencyKHR,
                "[VULKIT][LOADER] The function 'vkGetDeferredOperationMaxConcurrencyKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetDeferredOperationMaxConcurrencyKHR(device, operation);
}
#endif
#if defined(VK_KHR_deferred_host_operations)
VkResult DeviceTable::GetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) const
{
    TKIT_ASSERT(this->vkGetDeferredOperationResultKHR,
                "[VULKIT][LOADER] The function 'vkGetDeferredOperationResultKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetDeferredOperationResultKHR(device, operation);
}
#endif
#if defined(VK_KHR_deferred_host_operations)
VkResult DeviceTable::DeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) const
{
    TKIT_ASSERT(this->vkDeferredOperationJoinKHR,
                "[VULKIT][LOADER] The function 'vkDeferredOperationJoinKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkDeferredOperationJoinKHR(device, operation);
}
#endif
#if defined(VK_NV_device_generated_commands_compute)
void DeviceTable::GetPipelineIndirectMemoryRequirementsNV(VkDevice device,
                                                          const VkComputePipelineCreateInfo *pCreateInfo,
                                                          VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetPipelineIndirectMemoryRequirementsNV,
                "[VULKIT][LOADER] The function 'vkGetPipelineIndirectMemoryRequirementsNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetPipelineIndirectMemoryRequirementsNV(device, pCreateInfo, pMemoryRequirements);
}
#endif
#if defined(VK_NV_device_generated_commands_compute)
VkDeviceAddress DeviceTable::GetPipelineIndirectDeviceAddressNV(
    VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo) const
{
    TKIT_ASSERT(this->vkGetPipelineIndirectDeviceAddressNV,
                "[VULKIT][LOADER] The function 'vkGetPipelineIndirectDeviceAddressNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetPipelineIndirectDeviceAddressNV(device, pInfo);
}
#endif
#if defined(VK_AMD_anti_lag)
void DeviceTable::AntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD *pData) const
{
    TKIT_ASSERT(this->vkAntiLagUpdateAMD,
                "[VULKIT][LOADER] The function 'vkAntiLagUpdateAMD' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkAntiLagUpdateAMD(device, pData);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const
{
    TKIT_ASSERT(this->vkCmdSetCullMode,
                "[VULKIT][LOADER] The function 'vkCmdSetCullMode' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetCullMode(commandBuffer, cullMode);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const
{
    TKIT_ASSERT(this->vkCmdSetFrontFace,
                "[VULKIT][LOADER] The function 'vkCmdSetFrontFace' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetFrontFace(commandBuffer, frontFace);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const
{
    TKIT_ASSERT(this->vkCmdSetPrimitiveTopology,
                "[VULKIT][LOADER] The function 'vkCmdSetPrimitiveTopology' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetPrimitiveTopology(commandBuffer, primitiveTopology);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                          const VkViewport *pViewports) const
{
    TKIT_ASSERT(this->vkCmdSetViewportWithCount,
                "[VULKIT][LOADER] The function 'vkCmdSetViewportWithCount' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetViewportWithCount(commandBuffer, viewportCount, pViewports);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                         const VkRect2D *pScissors) const
{
    TKIT_ASSERT(this->vkCmdSetScissorWithCount,
                "[VULKIT][LOADER] The function 'vkCmdSetScissorWithCount' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetScissorWithCount(commandBuffer, scissorCount, pScissors);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdBindIndexBuffer2(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                      VkDeviceSize size, VkIndexType indexType) const
{
    TKIT_ASSERT(this->vkCmdBindIndexBuffer2,
                "[VULKIT][LOADER] The function 'vkCmdBindIndexBuffer2' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindIndexBuffer2(commandBuffer, buffer, offset, size, indexType);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
                                        const VkBuffer *pBuffers, const VkDeviceSize *pOffsets,
                                        const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const
{
    TKIT_ASSERT(this->vkCmdBindVertexBuffers2,
                "[VULKIT][LOADER] The function 'vkCmdBindVertexBuffers2' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindVertexBuffers2(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthTestEnable,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthTestEnable' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthTestEnable(commandBuffer, depthTestEnable);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthWriteEnable,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthWriteEnable' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthWriteEnable(commandBuffer, depthWriteEnable);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const
{
    TKIT_ASSERT(this->vkCmdSetDepthCompareOp,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthCompareOp' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthCompareOp(commandBuffer, depthCompareOp);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthBoundsTestEnable,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthBoundsTestEnable' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthBoundsTestEnable(commandBuffer, depthBoundsTestEnable);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const
{
    TKIT_ASSERT(this->vkCmdSetStencilTestEnable,
                "[VULKIT][LOADER] The function 'vkCmdSetStencilTestEnable' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetStencilTestEnable(commandBuffer, stencilTestEnable);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp,
                                  VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const
{
    TKIT_ASSERT(this->vkCmdSetStencilOp,
                "[VULKIT][LOADER] The function 'vkCmdSetStencilOp' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetStencilOp(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) const
{
    TKIT_ASSERT(this->vkCmdSetPatchControlPointsEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetPatchControlPointsEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetPatchControlPointsEXT(commandBuffer, patchControlPoints);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) const
{
    TKIT_ASSERT(this->vkCmdSetRasterizerDiscardEnable,
                "[VULKIT][LOADER] The function 'vkCmdSetRasterizerDiscardEnable' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetRasterizerDiscardEnable(commandBuffer, rasterizerDiscardEnable);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthBiasEnable,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthBiasEnable' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthBiasEnable(commandBuffer, depthBiasEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) const
{
    TKIT_ASSERT(this->vkCmdSetLogicOpEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetLogicOpEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetLogicOpEXT(commandBuffer, logicOp);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const
{
    TKIT_ASSERT(this->vkCmdSetPrimitiveRestartEnable,
                "[VULKIT][LOADER] The function 'vkCmdSetPrimitiveRestartEnable' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetPrimitiveRestartEnable(commandBuffer, primitiveRestartEnable);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && (defined(VK_KHR_maintenance2) || defined(VKIT_API_VERSION_1_1))) ||    \
    defined(VK_EXT_shader_object)
void DeviceTable::CmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer,
                                                    VkTessellationDomainOrigin domainOrigin) const
{
    TKIT_ASSERT(this->vkCmdSetTessellationDomainOriginEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetTessellationDomainOriginEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdSetTessellationDomainOriginEXT(commandBuffer, domainOrigin);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthClampEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthClampEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthClampEnableEXT(commandBuffer, depthClampEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) const
{
    TKIT_ASSERT(this->vkCmdSetPolygonModeEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetPolygonModeEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetPolygonModeEXT(commandBuffer, polygonMode);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer,
                                                VkSampleCountFlagBits rasterizationSamples) const
{
    TKIT_ASSERT(this->vkCmdSetRasterizationSamplesEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetRasterizationSamplesEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetRasterizationSamplesEXT(commandBuffer, rasterizationSamples);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples,
                                      const VkSampleMask *pSampleMask) const
{
    TKIT_ASSERT(this->vkCmdSetSampleMaskEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetSampleMaskEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetSampleMaskEXT(commandBuffer, samples, pSampleMask);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) const
{
    TKIT_ASSERT(this->vkCmdSetAlphaToCoverageEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetAlphaToCoverageEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetAlphaToCoverageEnableEXT(commandBuffer, alphaToCoverageEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) const
{
    TKIT_ASSERT(this->vkCmdSetAlphaToOneEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetAlphaToOneEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetAlphaToOneEnableEXT(commandBuffer, alphaToOneEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) const
{
    TKIT_ASSERT(this->vkCmdSetLogicOpEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetLogicOpEnableEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetLogicOpEnableEXT(commandBuffer, logicOpEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                            uint32_t attachmentCount, const VkBool32 *pColorBlendEnables) const
{
    TKIT_ASSERT(this->vkCmdSetColorBlendEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetColorBlendEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetColorBlendEnableEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                              uint32_t attachmentCount,
                                              const VkColorBlendEquationEXT *pColorBlendEquations) const
{
    TKIT_ASSERT(this->vkCmdSetColorBlendEquationEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetColorBlendEquationEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetColorBlendEquationEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
}
#endif
#if defined(VK_EXT_extended_dynamic_state3) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                          uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks) const
{
    TKIT_ASSERT(this->vkCmdSetColorWriteMaskEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetColorWriteMaskEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetColorWriteMaskEXT(commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_transform_feedback)) ||                                 \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_transform_feedback))
void DeviceTable::CmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) const
{
    TKIT_ASSERT(this->vkCmdSetRasterizationStreamEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetRasterizationStreamEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetRasterizationStreamEXT(commandBuffer, rasterizationStream);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_conservative_rasterization)) ||                         \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_conservative_rasterization))
void DeviceTable::CmdSetConservativeRasterizationModeEXT(
    VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) const
{
    TKIT_ASSERT(this->vkCmdSetConservativeRasterizationModeEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetConservativeRasterizationModeEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetConservativeRasterizationModeEXT(commandBuffer, conservativeRasterizationMode);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_conservative_rasterization)) ||                         \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_conservative_rasterization))
void DeviceTable::CmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer,
                                                            float extraPrimitiveOverestimationSize) const
{
    TKIT_ASSERT(this->vkCmdSetExtraPrimitiveOverestimationSizeEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetExtraPrimitiveOverestimationSizeEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetExtraPrimitiveOverestimationSizeEXT(commandBuffer, extraPrimitiveOverestimationSize);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_enable)) ||                                  \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_enable))
void DeviceTable::CmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthClipEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthClipEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthClipEnableEXT(commandBuffer, depthClipEnable);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_sample_locations)) ||                                   \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_sample_locations))
void DeviceTable::CmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) const
{
    TKIT_ASSERT(this->vkCmdSetSampleLocationsEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetSampleLocationsEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetSampleLocationsEnableEXT(commandBuffer, sampleLocationsEnable);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_blend_operation_advanced)) ||                           \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_blend_operation_advanced))
void DeviceTable::CmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment,
                                              uint32_t attachmentCount,
                                              const VkColorBlendAdvancedEXT *pColorBlendAdvanced) const
{
    TKIT_ASSERT(this->vkCmdSetColorBlendAdvancedEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetColorBlendAdvancedEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetColorBlendAdvancedEXT(commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_provoking_vertex)) ||                                   \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_provoking_vertex))
void DeviceTable::CmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer,
                                               VkProvokingVertexModeEXT provokingVertexMode) const
{
    TKIT_ASSERT(this->vkCmdSetProvokingVertexModeEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetProvokingVertexModeEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetProvokingVertexModeEXT(commandBuffer, provokingVertexMode);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_line_rasterization)) ||                                 \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_line_rasterization))
void DeviceTable::CmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer,
                                                 VkLineRasterizationModeEXT lineRasterizationMode) const
{
    TKIT_ASSERT(this->vkCmdSetLineRasterizationModeEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetLineRasterizationModeEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetLineRasterizationModeEXT(commandBuffer, lineRasterizationMode);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_line_rasterization)) ||                                 \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_line_rasterization))
void DeviceTable::CmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) const
{
    TKIT_ASSERT(this->vkCmdSetLineStippleEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetLineStippleEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetLineStippleEnableEXT(commandBuffer, stippledLineEnable);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_EXT_depth_clip_control)) ||                                 \
    (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clip_control))
void DeviceTable::CmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) const
{
    TKIT_ASSERT(this->vkCmdSetDepthClipNegativeOneToOneEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthClipNegativeOneToOneEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetDepthClipNegativeOneToOneEXT(commandBuffer, negativeOneToOne);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_clip_space_w_scaling)) ||                                \
    (defined(VK_EXT_shader_object) && defined(VK_NV_clip_space_w_scaling))
void DeviceTable::CmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) const
{
    TKIT_ASSERT(this->vkCmdSetViewportWScalingEnableNV,
                "[VULKIT][LOADER] The function 'vkCmdSetViewportWScalingEnableNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetViewportWScalingEnableNV(commandBuffer, viewportWScalingEnable);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_viewport_swizzle)) ||                                    \
    (defined(VK_EXT_shader_object) && defined(VK_NV_viewport_swizzle))
void DeviceTable::CmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount,
                                          const VkViewportSwizzleNV *pViewportSwizzles) const
{
    TKIT_ASSERT(this->vkCmdSetViewportSwizzleNV,
                "[VULKIT][LOADER] The function 'vkCmdSetViewportSwizzleNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetViewportSwizzleNV(commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_fragment_coverage_to_color)) ||                          \
    (defined(VK_EXT_shader_object) && defined(VK_NV_fragment_coverage_to_color))
void DeviceTable::CmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) const
{
    TKIT_ASSERT(this->vkCmdSetCoverageToColorEnableNV,
                "[VULKIT][LOADER] The function 'vkCmdSetCoverageToColorEnableNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetCoverageToColorEnableNV(commandBuffer, coverageToColorEnable);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_fragment_coverage_to_color)) ||                          \
    (defined(VK_EXT_shader_object) && defined(VK_NV_fragment_coverage_to_color))
void DeviceTable::CmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) const
{
    TKIT_ASSERT(this->vkCmdSetCoverageToColorLocationNV,
                "[VULKIT][LOADER] The function 'vkCmdSetCoverageToColorLocationNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdSetCoverageToColorLocationNV(commandBuffer, coverageToColorLocation);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) ||                           \
    (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples))
void DeviceTable::CmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer,
                                                 VkCoverageModulationModeNV coverageModulationMode) const
{
    TKIT_ASSERT(this->vkCmdSetCoverageModulationModeNV,
                "[VULKIT][LOADER] The function 'vkCmdSetCoverageModulationModeNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetCoverageModulationModeNV(commandBuffer, coverageModulationMode);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) ||                           \
    (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples))
void DeviceTable::CmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer,
                                                        VkBool32 coverageModulationTableEnable) const
{
    TKIT_ASSERT(this->vkCmdSetCoverageModulationTableEnableNV,
                "[VULKIT][LOADER] The function 'vkCmdSetCoverageModulationTableEnableNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetCoverageModulationTableEnableNV(commandBuffer, coverageModulationTableEnable);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_framebuffer_mixed_samples)) ||                           \
    (defined(VK_EXT_shader_object) && defined(VK_NV_framebuffer_mixed_samples))
void DeviceTable::CmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount,
                                                  const float *pCoverageModulationTable) const
{
    TKIT_ASSERT(this->vkCmdSetCoverageModulationTableNV,
                "[VULKIT][LOADER] The function 'vkCmdSetCoverageModulationTableNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdSetCoverageModulationTableNV(commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_shading_rate_image)) ||                                  \
    (defined(VK_EXT_shader_object) && defined(VK_NV_shading_rate_image))
void DeviceTable::CmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) const
{
    TKIT_ASSERT(this->vkCmdSetShadingRateImageEnableNV,
                "[VULKIT][LOADER] The function 'vkCmdSetShadingRateImageEnableNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetShadingRateImageEnableNV(commandBuffer, shadingRateImageEnable);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_coverage_reduction_mode)) ||                             \
    (defined(VK_EXT_shader_object) && defined(VK_NV_coverage_reduction_mode))
void DeviceTable::CmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer,
                                                VkCoverageReductionModeNV coverageReductionMode) const
{
    TKIT_ASSERT(this->vkCmdSetCoverageReductionModeNV,
                "[VULKIT][LOADER] The function 'vkCmdSetCoverageReductionModeNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetCoverageReductionModeNV(commandBuffer, coverageReductionMode);
}
#endif
#if (defined(VK_EXT_extended_dynamic_state3) && defined(VK_NV_representative_fragment_test)) ||                        \
    (defined(VK_EXT_shader_object) && defined(VK_NV_representative_fragment_test))
void DeviceTable::CmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer,
                                                           VkBool32 representativeFragmentTestEnable) const
{
    TKIT_ASSERT(this->vkCmdSetRepresentativeFragmentTestEnableNV,
                "[VULKIT][LOADER] The function 'vkCmdSetRepresentativeFragmentTestEnableNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetRepresentativeFragmentTestEnableNV(commandBuffer, representativeFragmentTestEnable);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
VkResult DeviceTable::CreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo,
                                            const VkAllocationCallbacks *pAllocator,
                                            VkPrivateDataSlot *pPrivateDataSlot) const
{
    TKIT_ASSERT(this->vkCreatePrivateDataSlot,
                "[VULKIT][LOADER] The function 'vkCreatePrivateDataSlot' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreatePrivateDataSlot(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::DestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot,
                                         const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyPrivateDataSlot,
                "[VULKIT][LOADER] The function 'vkDestroyPrivateDataSlot' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyPrivateDataSlot(device, privateDataSlot, pAllocator);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
VkResult DeviceTable::SetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                     VkPrivateDataSlot privateDataSlot, uint64_t data) const
{
    TKIT_ASSERT(this->vkSetPrivateData,
                "[VULKIT][LOADER] The function 'vkSetPrivateData' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkSetPrivateData(device, objectType, objectHandle, privateDataSlot, data);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::GetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                 VkPrivateDataSlot privateDataSlot, uint64_t *pData) const
{
    TKIT_ASSERT(this->vkGetPrivateData,
                "[VULKIT][LOADER] The function 'vkGetPrivateData' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkGetPrivateData(device, objectType, objectHandle, privateDataSlot, pData);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyBuffer2,
                "[VULKIT][LOADER] The function 'vkCmdCopyBuffer2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdCopyBuffer2(commandBuffer, pCopyBufferInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyImage2,
                "[VULKIT][LOADER] The function 'vkCmdCopyImage2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdCopyImage2(commandBuffer, pCopyImageInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) const
{
    TKIT_ASSERT(this->vkCmdBlitImage2,
                "[VULKIT][LOADER] The function 'vkCmdBlitImage2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdBlitImage2(commandBuffer, pBlitImageInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdCopyBufferToImage2(VkCommandBuffer commandBuffer,
                                        const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyBufferToImage2,
                "[VULKIT][LOADER] The function 'vkCmdCopyBufferToImage2' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyBufferToImage2(commandBuffer, pCopyBufferToImageInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer,
                                        const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyImageToBuffer2,
                "[VULKIT][LOADER] The function 'vkCmdCopyImageToBuffer2' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyImageToBuffer2(commandBuffer, pCopyImageToBufferInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdResolveImage2(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) const
{
    TKIT_ASSERT(this->vkCmdResolveImage2,
                "[VULKIT][LOADER] The function 'vkCmdResolveImage2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdResolveImage2(commandBuffer, pResolveImageInfo);
}
#endif
#if defined(VK_KHR_object_refresh)
void DeviceTable::CmdRefreshObjectsKHR(VkCommandBuffer commandBuffer,
                                       const VkRefreshObjectListKHR *pRefreshObjects) const
{
    TKIT_ASSERT(this->vkCmdRefreshObjectsKHR,
                "[VULKIT][LOADER] The function 'vkCmdRefreshObjectsKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdRefreshObjectsKHR(commandBuffer, pRefreshObjects);
}
#endif
#if defined(VK_KHR_fragment_shading_rate)
void DeviceTable::CmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D *pFragmentSize,
                                               const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const
{
    TKIT_ASSERT(this->vkCmdSetFragmentShadingRateKHR,
                "[VULKIT][LOADER] The function 'vkCmdSetFragmentShadingRateKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetFragmentShadingRateKHR(commandBuffer, pFragmentSize, combinerOps);
}
#endif
#if defined(VK_NV_fragment_shading_rate_enums)
void DeviceTable::CmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate,
                                                  const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) const
{
    TKIT_ASSERT(this->vkCmdSetFragmentShadingRateEnumNV,
                "[VULKIT][LOADER] The function 'vkCmdSetFragmentShadingRateEnumNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdSetFragmentShadingRateEnumNV(commandBuffer, shadingRate, combinerOps);
}
#endif
#if defined(VK_KHR_acceleration_structure)
void DeviceTable::GetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType,
                                                        const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo,
                                                        const uint32_t *pMaxPrimitiveCounts,
                                                        VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const
{
    TKIT_ASSERT(this->vkGetAccelerationStructureBuildSizesKHR,
                "[VULKIT][LOADER] The function 'vkGetAccelerationStructureBuildSizesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetAccelerationStructureBuildSizesKHR(device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
}
#endif
#if defined(VK_EXT_vertex_input_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount,
                                       const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions,
                                       uint32_t vertexAttributeDescriptionCount,
                                       const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions) const
{
    TKIT_ASSERT(this->vkCmdSetVertexInputEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetVertexInputEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetVertexInputEXT(commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions,
                                 vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
}
#endif
#if defined(VK_EXT_color_write_enable)
void DeviceTable::CmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount,
                                            const VkBool32 *pColorWriteEnables) const
{
    TKIT_ASSERT(this->vkCmdSetColorWriteEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetColorWriteEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetColorWriteEnableEXT(commandBuffer, attachmentCount, pColorWriteEnables);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event,
                               const VkDependencyInfo *pDependencyInfo) const
{
    TKIT_ASSERT(this->vkCmdSetEvent2,
                "[VULKIT][LOADER] The function 'vkCmdSetEvent2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetEvent2(commandBuffer, event, pDependencyInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) const
{
    TKIT_ASSERT(this->vkCmdResetEvent2,
                "[VULKIT][LOADER] The function 'vkCmdResetEvent2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdResetEvent2(commandBuffer, event, stageMask);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents,
                                 const VkDependencyInfo *pDependencyInfos) const
{
    TKIT_ASSERT(this->vkCmdWaitEvents2,
                "[VULKIT][LOADER] The function 'vkCmdWaitEvents2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdWaitEvents2(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) const
{
    TKIT_ASSERT(this->vkCmdPipelineBarrier2,
                "[VULKIT][LOADER] The function 'vkCmdPipelineBarrier2' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdPipelineBarrier2(commandBuffer, pDependencyInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
VkResult DeviceTable::QueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits,
                                   VkFence fence) const
{
    TKIT_ASSERT(this->vkQueueSubmit2,
                "[VULKIT][LOADER] The function 'vkQueueSubmit2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkQueueSubmit2(queue, submitCount, pSubmits, fence);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool,
                                     uint32_t query) const
{
    TKIT_ASSERT(this->vkCmdWriteTimestamp2,
                "[VULKIT][LOADER] The function 'vkCmdWriteTimestamp2' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdWriteTimestamp2(commandBuffer, stage, queryPool, query);
}
#endif
#if (defined(VK_AMD_buffer_marker) && (defined(VKIT_API_VERSION_1_3) || defined(VK_KHR_synchronization2)))
void DeviceTable::CmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage,
                                           VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) const
{
    TKIT_ASSERT(this->vkCmdWriteBufferMarker2AMD,
                "[VULKIT][LOADER] The function 'vkCmdWriteBufferMarker2AMD' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdWriteBufferMarker2AMD(commandBuffer, stage, dstBuffer, dstOffset, marker);
}
#endif
#if (defined(VK_NV_device_diagnostic_checkpoints) &&                                                                   \
     (defined(VKIT_API_VERSION_1_3) || defined(VK_KHR_synchronization2)))
void DeviceTable::GetQueueCheckpointData2NV(VkQueue queue, uint32_t *pCheckpointDataCount,
                                            VkCheckpointData2NV *pCheckpointData) const
{
    TKIT_ASSERT(this->vkGetQueueCheckpointData2NV,
                "[VULKIT][LOADER] The function 'vkGetQueueCheckpointData2NV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetQueueCheckpointData2NV(queue, pCheckpointDataCount, pCheckpointData);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
VkResult DeviceTable::CopyMemoryToImage(VkDevice device, const VkCopyMemoryToImageInfo *pCopyMemoryToImageInfo) const
{
    TKIT_ASSERT(this->vkCopyMemoryToImage,
                "[VULKIT][LOADER] The function 'vkCopyMemoryToImage' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCopyMemoryToImage(device, pCopyMemoryToImageInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
VkResult DeviceTable::CopyImageToMemory(VkDevice device, const VkCopyImageToMemoryInfo *pCopyImageToMemoryInfo) const
{
    TKIT_ASSERT(this->vkCopyImageToMemory,
                "[VULKIT][LOADER] The function 'vkCopyImageToMemory' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCopyImageToMemory(device, pCopyImageToMemoryInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
VkResult DeviceTable::CopyImageToImage(VkDevice device, const VkCopyImageToImageInfo *pCopyImageToImageInfo) const
{
    TKIT_ASSERT(this->vkCopyImageToImage,
                "[VULKIT][LOADER] The function 'vkCopyImageToImage' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCopyImageToImage(device, pCopyImageToImageInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
VkResult DeviceTable::TransitionImageLayout(VkDevice device, uint32_t transitionCount,
                                            const VkHostImageLayoutTransitionInfo *pTransitions) const
{
    TKIT_ASSERT(this->vkTransitionImageLayout,
                "[VULKIT][LOADER] The function 'vkTransitionImageLayout' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkTransitionImageLayout(device, transitionCount, pTransitions);
}
#endif
#if defined(VK_KHR_video_queue)
VkResult DeviceTable::CreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR *pCreateInfo,
                                            const VkAllocationCallbacks *pAllocator,
                                            VkVideoSessionKHR *pVideoSession) const
{
    TKIT_ASSERT(this->vkCreateVideoSessionKHR,
                "[VULKIT][LOADER] The function 'vkCreateVideoSessionKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateVideoSessionKHR(device, pCreateInfo, pAllocator, pVideoSession);
}
#endif
#if defined(VK_KHR_video_queue)
void DeviceTable::DestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession,
                                         const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyVideoSessionKHR,
                "[VULKIT][LOADER] The function 'vkDestroyVideoSessionKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyVideoSessionKHR(device, videoSession, pAllocator);
}
#endif
#if defined(VK_KHR_video_queue)
VkResult DeviceTable::CreateVideoSessionParametersKHR(VkDevice device,
                                                      const VkVideoSessionParametersCreateInfoKHR *pCreateInfo,
                                                      const VkAllocationCallbacks *pAllocator,
                                                      VkVideoSessionParametersKHR *pVideoSessionParameters) const
{
    TKIT_ASSERT(this->vkCreateVideoSessionParametersKHR,
                "[VULKIT][LOADER] The function 'vkCreateVideoSessionParametersKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkCreateVideoSessionParametersKHR(device, pCreateInfo, pAllocator, pVideoSessionParameters);
}
#endif
#if defined(VK_KHR_video_queue)
VkResult DeviceTable::UpdateVideoSessionParametersKHR(VkDevice device,
                                                      VkVideoSessionParametersKHR videoSessionParameters,
                                                      const VkVideoSessionParametersUpdateInfoKHR *pUpdateInfo) const
{
    TKIT_ASSERT(this->vkUpdateVideoSessionParametersKHR,
                "[VULKIT][LOADER] The function 'vkUpdateVideoSessionParametersKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkUpdateVideoSessionParametersKHR(device, videoSessionParameters, pUpdateInfo);
}
#endif
#if defined(VK_KHR_video_encode_queue)
VkResult DeviceTable::GetEncodedVideoSessionParametersKHR(
    VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR *pVideoSessionParametersInfo,
    VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo, size_t *pDataSize, void *pData) const
{
    TKIT_ASSERT(this->vkGetEncodedVideoSessionParametersKHR,
                "[VULKIT][LOADER] The function 'vkGetEncodedVideoSessionParametersKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetEncodedVideoSessionParametersKHR(device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize,
                                                       pData);
}
#endif
#if defined(VK_KHR_video_queue)
void DeviceTable::DestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters,
                                                   const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyVideoSessionParametersKHR,
                "[VULKIT][LOADER] The function 'vkDestroyVideoSessionParametersKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkDestroyVideoSessionParametersKHR(device, videoSessionParameters, pAllocator);
}
#endif
#if defined(VK_KHR_video_queue)
VkResult DeviceTable::GetVideoSessionMemoryRequirementsKHR(
    VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount,
    VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetVideoSessionMemoryRequirementsKHR,
                "[VULKIT][LOADER] The function 'vkGetVideoSessionMemoryRequirementsKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetVideoSessionMemoryRequirementsKHR(device, videoSession, pMemoryRequirementsCount,
                                                        pMemoryRequirements);
}
#endif
#if defined(VK_KHR_video_queue)
VkResult DeviceTable::BindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession,
                                                uint32_t bindSessionMemoryInfoCount,
                                                const VkBindVideoSessionMemoryInfoKHR *pBindSessionMemoryInfos) const
{
    TKIT_ASSERT(this->vkBindVideoSessionMemoryKHR,
                "[VULKIT][LOADER] The function 'vkBindVideoSessionMemoryKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkBindVideoSessionMemoryKHR(device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
}
#endif
#if defined(VK_KHR_video_decode_queue)
void DeviceTable::CmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR *pDecodeInfo) const
{
    TKIT_ASSERT(this->vkCmdDecodeVideoKHR,
                "[VULKIT][LOADER] The function 'vkCmdDecodeVideoKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdDecodeVideoKHR(commandBuffer, pDecodeInfo);
}
#endif
#if defined(VK_KHR_video_queue)
void DeviceTable::CmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer,
                                         const VkVideoBeginCodingInfoKHR *pBeginInfo) const
{
    TKIT_ASSERT(this->vkCmdBeginVideoCodingKHR,
                "[VULKIT][LOADER] The function 'vkCmdBeginVideoCodingKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBeginVideoCodingKHR(commandBuffer, pBeginInfo);
}
#endif
#if defined(VK_KHR_video_queue)
void DeviceTable::CmdControlVideoCodingKHR(VkCommandBuffer commandBuffer,
                                           const VkVideoCodingControlInfoKHR *pCodingControlInfo) const
{
    TKIT_ASSERT(this->vkCmdControlVideoCodingKHR,
                "[VULKIT][LOADER] The function 'vkCmdControlVideoCodingKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdControlVideoCodingKHR(commandBuffer, pCodingControlInfo);
}
#endif
#if defined(VK_KHR_video_queue)
void DeviceTable::CmdEndVideoCodingKHR(VkCommandBuffer commandBuffer,
                                       const VkVideoEndCodingInfoKHR *pEndCodingInfo) const
{
    TKIT_ASSERT(this->vkCmdEndVideoCodingKHR,
                "[VULKIT][LOADER] The function 'vkCmdEndVideoCodingKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdEndVideoCodingKHR(commandBuffer, pEndCodingInfo);
}
#endif
#if defined(VK_KHR_video_encode_queue)
void DeviceTable::CmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR *pEncodeInfo) const
{
    TKIT_ASSERT(this->vkCmdEncodeVideoKHR,
                "[VULKIT][LOADER] The function 'vkCmdEncodeVideoKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdEncodeVideoKHR(commandBuffer, pEncodeInfo);
}
#endif
#if defined(VK_NV_memory_decompression)
void DeviceTable::CmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount,
                                        const VkDecompressMemoryRegionNV *pDecompressMemoryRegions) const
{
    TKIT_ASSERT(this->vkCmdDecompressMemoryNV,
                "[VULKIT][LOADER] The function 'vkCmdDecompressMemoryNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDecompressMemoryNV(commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
}
#endif
#if defined(VK_NV_memory_decompression)
void DeviceTable::CmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer,
                                                     VkDeviceAddress indirectCommandsAddress,
                                                     VkDeviceAddress indirectCommandsCountAddress,
                                                     uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDecompressMemoryIndirectCountNV,
                "[VULKIT][LOADER] The function 'vkCmdDecompressMemoryIndirectCountNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdDecompressMemoryIndirectCountNV(commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress,
                                               stride);
}
#endif
#if defined(VK_NV_partitioned_acceleration_structure)
void DeviceTable::GetPartitionedAccelerationStructuresBuildSizesNV(
    VkDevice device, const VkPartitionedAccelerationStructureInstancesInputNV *pInfo,
    VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) const
{
    TKIT_ASSERT(this->vkGetPartitionedAccelerationStructuresBuildSizesNV,
                "[VULKIT][LOADER] The function 'vkGetPartitionedAccelerationStructuresBuildSizesNV' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    this->vkGetPartitionedAccelerationStructuresBuildSizesNV(device, pInfo, pSizeInfo);
}
#endif
#if defined(VK_NV_partitioned_acceleration_structure)
void DeviceTable::CmdBuildPartitionedAccelerationStructuresNV(
    VkCommandBuffer commandBuffer, const VkBuildPartitionedAccelerationStructureInfoNV *pBuildInfo) const
{
    TKIT_ASSERT(this->vkCmdBuildPartitionedAccelerationStructuresNV,
                "[VULKIT][LOADER] The function 'vkCmdBuildPartitionedAccelerationStructuresNV' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkCmdBuildPartitionedAccelerationStructuresNV(commandBuffer, pBuildInfo);
}
#endif
#if defined(VK_NVX_binary_import)
VkResult DeviceTable::CreateCuModuleNVX(VkDevice device, const VkCuModuleCreateInfoNVX *pCreateInfo,
                                        const VkAllocationCallbacks *pAllocator, VkCuModuleNVX *pModule) const
{
    TKIT_ASSERT(this->vkCreateCuModuleNVX,
                "[VULKIT][LOADER] The function 'vkCreateCuModuleNVX' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateCuModuleNVX(device, pCreateInfo, pAllocator, pModule);
}
#endif
#if defined(VK_NVX_binary_import)
VkResult DeviceTable::CreateCuFunctionNVX(VkDevice device, const VkCuFunctionCreateInfoNVX *pCreateInfo,
                                          const VkAllocationCallbacks *pAllocator, VkCuFunctionNVX *pFunction) const
{
    TKIT_ASSERT(this->vkCreateCuFunctionNVX,
                "[VULKIT][LOADER] The function 'vkCreateCuFunctionNVX' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateCuFunctionNVX(device, pCreateInfo, pAllocator, pFunction);
}
#endif
#if defined(VK_NVX_binary_import)
void DeviceTable::DestroyCuModuleNVX(VkDevice device, VkCuModuleNVX module,
                                     const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyCuModuleNVX,
                "[VULKIT][LOADER] The function 'vkDestroyCuModuleNVX' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyCuModuleNVX(device, module, pAllocator);
}
#endif
#if defined(VK_NVX_binary_import)
void DeviceTable::DestroyCuFunctionNVX(VkDevice device, VkCuFunctionNVX function,
                                       const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyCuFunctionNVX,
                "[VULKIT][LOADER] The function 'vkDestroyCuFunctionNVX' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyCuFunctionNVX(device, function, pAllocator);
}
#endif
#if defined(VK_NVX_binary_import)
void DeviceTable::CmdCuLaunchKernelNVX(VkCommandBuffer commandBuffer, const VkCuLaunchInfoNVX *pLaunchInfo) const
{
    TKIT_ASSERT(this->vkCmdCuLaunchKernelNVX,
                "[VULKIT][LOADER] The function 'vkCmdCuLaunchKernelNVX' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCuLaunchKernelNVX(commandBuffer, pLaunchInfo);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
void DeviceTable::GetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout,
                                                VkDeviceSize *pLayoutSizeInBytes) const
{
    TKIT_ASSERT(this->vkGetDescriptorSetLayoutSizeEXT,
                "[VULKIT][LOADER] The function 'vkGetDescriptorSetLayoutSizeEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetDescriptorSetLayoutSizeEXT(device, layout, pLayoutSizeInBytes);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
void DeviceTable::GetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout,
                                                         uint32_t binding, VkDeviceSize *pOffset) const
{
    TKIT_ASSERT(this->vkGetDescriptorSetLayoutBindingOffsetEXT,
                "[VULKIT][LOADER] The function 'vkGetDescriptorSetLayoutBindingOffsetEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetDescriptorSetLayoutBindingOffsetEXT(device, layout, binding, pOffset);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
void DeviceTable::GetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize,
                                   void *pDescriptor) const
{
    TKIT_ASSERT(this->vkGetDescriptorEXT,
                "[VULKIT][LOADER] The function 'vkGetDescriptorEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkGetDescriptorEXT(device, pDescriptorInfo, dataSize, pDescriptor);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
void DeviceTable::CmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount,
                                              const VkDescriptorBufferBindingInfoEXT *pBindingInfos) const
{
    TKIT_ASSERT(this->vkCmdBindDescriptorBuffersEXT,
                "[VULKIT][LOADER] The function 'vkCmdBindDescriptorBuffersEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindDescriptorBuffersEXT(commandBuffer, bufferCount, pBindingInfos);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
void DeviceTable::CmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                                   VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount,
                                                   const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets) const
{
    TKIT_ASSERT(this->vkCmdSetDescriptorBufferOffsetsEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDescriptorBufferOffsetsEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdSetDescriptorBufferOffsetsEXT(commandBuffer, pipelineBindPoint, layout, firstSet, setCount,
                                             pBufferIndices, pOffsets);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
void DeviceTable::CmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer,
                                                             VkPipelineBindPoint pipelineBindPoint,
                                                             VkPipelineLayout layout, uint32_t set) const
{
    TKIT_ASSERT(this->vkCmdBindDescriptorBufferEmbeddedSamplersEXT,
                "[VULKIT][LOADER] The function 'vkCmdBindDescriptorBufferEmbeddedSamplersEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdBindDescriptorBufferEmbeddedSamplersEXT(commandBuffer, pipelineBindPoint, layout, set);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
VkResult DeviceTable::GetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                              const VkBufferCaptureDescriptorDataInfoEXT *pInfo,
                                                              void *pData) const
{
    TKIT_ASSERT(this->vkGetBufferOpaqueCaptureDescriptorDataEXT,
                "[VULKIT][LOADER] The function 'vkGetBufferOpaqueCaptureDescriptorDataEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetBufferOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
VkResult DeviceTable::GetImageOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                             const VkImageCaptureDescriptorDataInfoEXT *pInfo,
                                                             void *pData) const
{
    TKIT_ASSERT(this->vkGetImageOpaqueCaptureDescriptorDataEXT,
                "[VULKIT][LOADER] The function 'vkGetImageOpaqueCaptureDescriptorDataEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetImageOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
VkResult DeviceTable::GetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                                 const VkImageViewCaptureDescriptorDataInfoEXT *pInfo,
                                                                 void *pData) const
{
    TKIT_ASSERT(this->vkGetImageViewOpaqueCaptureDescriptorDataEXT,
                "[VULKIT][LOADER] The function 'vkGetImageViewOpaqueCaptureDescriptorDataEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetImageViewOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
#endif
#if defined(VK_EXT_descriptor_buffer)
VkResult DeviceTable::GetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device,
                                                               const VkSamplerCaptureDescriptorDataInfoEXT *pInfo,
                                                               void *pData) const
{
    TKIT_ASSERT(this->vkGetSamplerOpaqueCaptureDescriptorDataEXT,
                "[VULKIT][LOADER] The function 'vkGetSamplerOpaqueCaptureDescriptorDataEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetSamplerOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
#endif
#if (defined(VK_EXT_descriptor_buffer) && (defined(VK_KHR_acceleration_structure) || defined(VK_NV_ray_tracing)))
VkResult DeviceTable::GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(
    VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData) const
{
    TKIT_ASSERT(this->vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT,
                "[VULKIT][LOADER] The function 'vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT' is not "
                "available for the instance or device being used, either because VKit::Initialize() was not "
                "called or because the feature or extension bound to the function has not been enabled");
    return this->vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(device, pInfo, pData);
}
#endif
#if defined(VK_EXT_pageable_device_local_memory)
void DeviceTable::SetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority) const
{
    TKIT_ASSERT(this->vkSetDeviceMemoryPriorityEXT,
                "[VULKIT][LOADER] The function 'vkSetDeviceMemoryPriorityEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkSetDeviceMemoryPriorityEXT(device, memory, priority);
}
#endif
#if defined(VK_KHR_present_wait2)
VkResult DeviceTable::WaitForPresent2KHR(VkDevice device, VkSwapchainKHR swapchain,
                                         const VkPresentWait2InfoKHR *pPresentWait2Info) const
{
    TKIT_ASSERT(this->vkWaitForPresent2KHR,
                "[VULKIT][LOADER] The function 'vkWaitForPresent2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkWaitForPresent2KHR(device, swapchain, pPresentWait2Info);
}
#endif
#if defined(VK_KHR_present_wait)
VkResult DeviceTable::WaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId,
                                        uint64_t timeout) const
{
    TKIT_ASSERT(this->vkWaitForPresentKHR,
                "[VULKIT][LOADER] The function 'vkWaitForPresentKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkWaitForPresentKHR(device, swapchain, presentId, timeout);
}
#endif
#if defined(VK_FUCHSIA_buffer_collection)
VkResult DeviceTable::CreateBufferCollectionFUCHSIA(VkDevice device,
                                                    const VkBufferCollectionCreateInfoFUCHSIA *pCreateInfo,
                                                    const VkAllocationCallbacks *pAllocator,
                                                    VkBufferCollectionFUCHSIA *pCollection) const
{
    TKIT_ASSERT(this->vkCreateBufferCollectionFUCHSIA,
                "[VULKIT][LOADER] The function 'vkCreateBufferCollectionFUCHSIA' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateBufferCollectionFUCHSIA(device, pCreateInfo, pAllocator, pCollection);
}
#endif
#if defined(VK_FUCHSIA_buffer_collection)
VkResult DeviceTable::SetBufferCollectionBufferConstraintsFUCHSIA(
    VkDevice device, VkBufferCollectionFUCHSIA collection,
    const VkBufferConstraintsInfoFUCHSIA *pBufferConstraintsInfo) const
{
    TKIT_ASSERT(this->vkSetBufferCollectionBufferConstraintsFUCHSIA,
                "[VULKIT][LOADER] The function 'vkSetBufferCollectionBufferConstraintsFUCHSIA' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkSetBufferCollectionBufferConstraintsFUCHSIA(device, collection, pBufferConstraintsInfo);
}
#endif
#if defined(VK_FUCHSIA_buffer_collection)
VkResult DeviceTable::SetBufferCollectionImageConstraintsFUCHSIA(
    VkDevice device, VkBufferCollectionFUCHSIA collection,
    const VkImageConstraintsInfoFUCHSIA *pImageConstraintsInfo) const
{
    TKIT_ASSERT(this->vkSetBufferCollectionImageConstraintsFUCHSIA,
                "[VULKIT][LOADER] The function 'vkSetBufferCollectionImageConstraintsFUCHSIA' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkSetBufferCollectionImageConstraintsFUCHSIA(device, collection, pImageConstraintsInfo);
}
#endif
#if defined(VK_FUCHSIA_buffer_collection)
void DeviceTable::DestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection,
                                                 const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyBufferCollectionFUCHSIA,
                "[VULKIT][LOADER] The function 'vkDestroyBufferCollectionFUCHSIA' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyBufferCollectionFUCHSIA(device, collection, pAllocator);
}
#endif
#if defined(VK_FUCHSIA_buffer_collection)
VkResult DeviceTable::GetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection,
                                                           VkBufferCollectionPropertiesFUCHSIA *pProperties) const
{
    TKIT_ASSERT(this->vkGetBufferCollectionPropertiesFUCHSIA,
                "[VULKIT][LOADER] The function 'vkGetBufferCollectionPropertiesFUCHSIA' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetBufferCollectionPropertiesFUCHSIA(device, collection, pProperties);
}
#endif
#if defined(VK_NV_cuda_kernel_launch)
VkResult DeviceTable::CreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo,
                                         const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule) const
{
    TKIT_ASSERT(this->vkCreateCudaModuleNV,
                "[VULKIT][LOADER] The function 'vkCreateCudaModuleNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateCudaModuleNV(device, pCreateInfo, pAllocator, pModule);
}
#endif
#if defined(VK_NV_cuda_kernel_launch)
VkResult DeviceTable::GetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize,
                                           void *pCacheData) const
{
    TKIT_ASSERT(this->vkGetCudaModuleCacheNV,
                "[VULKIT][LOADER] The function 'vkGetCudaModuleCacheNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetCudaModuleCacheNV(device, module, pCacheSize, pCacheData);
}
#endif
#if defined(VK_NV_cuda_kernel_launch)
VkResult DeviceTable::CreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo,
                                           const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction) const
{
    TKIT_ASSERT(this->vkCreateCudaFunctionNV,
                "[VULKIT][LOADER] The function 'vkCreateCudaFunctionNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateCudaFunctionNV(device, pCreateInfo, pAllocator, pFunction);
}
#endif
#if defined(VK_NV_cuda_kernel_launch)
void DeviceTable::DestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module,
                                      const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyCudaModuleNV,
                "[VULKIT][LOADER] The function 'vkDestroyCudaModuleNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyCudaModuleNV(device, module, pAllocator);
}
#endif
#if defined(VK_NV_cuda_kernel_launch)
void DeviceTable::DestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function,
                                        const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyCudaFunctionNV,
                "[VULKIT][LOADER] The function 'vkDestroyCudaFunctionNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyCudaFunctionNV(device, function, pAllocator);
}
#endif
#if defined(VK_NV_cuda_kernel_launch)
void DeviceTable::CmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo) const
{
    TKIT_ASSERT(this->vkCmdCudaLaunchKernelNV,
                "[VULKIT][LOADER] The function 'vkCmdCudaLaunchKernelNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCudaLaunchKernelNV(commandBuffer, pLaunchInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) const
{
    TKIT_ASSERT(this->vkCmdBeginRendering,
                "[VULKIT][LOADER] The function 'vkCmdBeginRendering' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdBeginRendering(commandBuffer, pRenderingInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_3)
void DeviceTable::CmdEndRendering(VkCommandBuffer commandBuffer) const
{
    TKIT_ASSERT(this->vkCmdEndRendering,
                "[VULKIT][LOADER] The function 'vkCmdEndRendering' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdEndRendering(commandBuffer);
}
#endif
#if defined(VK_EXT_fragment_density_map_offset)
void DeviceTable::CmdEndRendering2EXT(VkCommandBuffer commandBuffer,
                                      const VkRenderingEndInfoEXT *pRenderingEndInfo) const
{
    TKIT_ASSERT(this->vkCmdEndRendering2EXT,
                "[VULKIT][LOADER] The function 'vkCmdEndRendering2EXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdEndRendering2EXT(commandBuffer, pRenderingEndInfo);
}
#endif
#if defined(VK_VALVE_descriptor_set_host_mapping)
void DeviceTable::GetDescriptorSetLayoutHostMappingInfoVALVE(
    VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference,
    VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping) const
{
    TKIT_ASSERT(this->vkGetDescriptorSetLayoutHostMappingInfoVALVE,
                "[VULKIT][LOADER] The function 'vkGetDescriptorSetLayoutHostMappingInfoVALVE' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetDescriptorSetLayoutHostMappingInfoVALVE(device, pBindingReference, pHostMapping);
}
#endif
#if defined(VK_VALVE_descriptor_set_host_mapping)
void DeviceTable::GetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData) const
{
    TKIT_ASSERT(this->vkGetDescriptorSetHostMappingVALVE,
                "[VULKIT][LOADER] The function 'vkGetDescriptorSetHostMappingVALVE' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetDescriptorSetHostMappingVALVE(device, descriptorSet, ppData);
}
#endif
#if defined(VK_EXT_opacity_micromap)
VkResult DeviceTable::CreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo,
                                        const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap) const
{
    TKIT_ASSERT(this->vkCreateMicromapEXT,
                "[VULKIT][LOADER] The function 'vkCreateMicromapEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateMicromapEXT(device, pCreateInfo, pAllocator, pMicromap);
}
#endif
#if defined(VK_EXT_opacity_micromap)
void DeviceTable::CmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount,
                                       const VkMicromapBuildInfoEXT *pInfos) const
{
    TKIT_ASSERT(this->vkCmdBuildMicromapsEXT,
                "[VULKIT][LOADER] The function 'vkCmdBuildMicromapsEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBuildMicromapsEXT(commandBuffer, infoCount, pInfos);
}
#endif
#if defined(VK_EXT_opacity_micromap)
VkResult DeviceTable::BuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount,
                                        const VkMicromapBuildInfoEXT *pInfos) const
{
    TKIT_ASSERT(this->vkBuildMicromapsEXT,
                "[VULKIT][LOADER] The function 'vkBuildMicromapsEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkBuildMicromapsEXT(device, deferredOperation, infoCount, pInfos);
}
#endif
#if defined(VK_EXT_opacity_micromap)
void DeviceTable::DestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap,
                                     const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyMicromapEXT,
                "[VULKIT][LOADER] The function 'vkDestroyMicromapEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyMicromapEXT(device, micromap, pAllocator);
}
#endif
#if defined(VK_EXT_opacity_micromap)
void DeviceTable::CmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyMicromapEXT,
                "[VULKIT][LOADER] The function 'vkCmdCopyMicromapEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyMicromapEXT(commandBuffer, pInfo);
}
#endif
#if defined(VK_EXT_opacity_micromap)
VkResult DeviceTable::CopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                      const VkCopyMicromapInfoEXT *pInfo) const
{
    TKIT_ASSERT(this->vkCopyMicromapEXT,
                "[VULKIT][LOADER] The function 'vkCopyMicromapEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCopyMicromapEXT(device, deferredOperation, pInfo);
}
#endif
#if defined(VK_EXT_opacity_micromap)
void DeviceTable::CmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer,
                                             const VkCopyMicromapToMemoryInfoEXT *pInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyMicromapToMemoryEXT,
                "[VULKIT][LOADER] The function 'vkCmdCopyMicromapToMemoryEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyMicromapToMemoryEXT(commandBuffer, pInfo);
}
#endif
#if defined(VK_EXT_opacity_micromap)
VkResult DeviceTable::CopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                              const VkCopyMicromapToMemoryInfoEXT *pInfo) const
{
    TKIT_ASSERT(this->vkCopyMicromapToMemoryEXT,
                "[VULKIT][LOADER] The function 'vkCopyMicromapToMemoryEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCopyMicromapToMemoryEXT(device, deferredOperation, pInfo);
}
#endif
#if defined(VK_EXT_opacity_micromap)
void DeviceTable::CmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer,
                                             const VkCopyMemoryToMicromapInfoEXT *pInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyMemoryToMicromapEXT,
                "[VULKIT][LOADER] The function 'vkCmdCopyMemoryToMicromapEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyMemoryToMicromapEXT(commandBuffer, pInfo);
}
#endif
#if defined(VK_EXT_opacity_micromap)
VkResult DeviceTable::CopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                              const VkCopyMemoryToMicromapInfoEXT *pInfo) const
{
    TKIT_ASSERT(this->vkCopyMemoryToMicromapEXT,
                "[VULKIT][LOADER] The function 'vkCopyMemoryToMicromapEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCopyMemoryToMicromapEXT(device, deferredOperation, pInfo);
}
#endif
#if defined(VK_EXT_opacity_micromap)
void DeviceTable::CmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount,
                                                 const VkMicromapEXT *pMicromaps, VkQueryType queryType,
                                                 VkQueryPool queryPool, uint32_t firstQuery) const
{
    TKIT_ASSERT(this->vkCmdWriteMicromapsPropertiesEXT,
                "[VULKIT][LOADER] The function 'vkCmdWriteMicromapsPropertiesEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdWriteMicromapsPropertiesEXT(commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
}
#endif
#if defined(VK_EXT_opacity_micromap)
VkResult DeviceTable::WriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount,
                                                  const VkMicromapEXT *pMicromaps, VkQueryType queryType,
                                                  size_t dataSize, void *pData, size_t stride) const
{
    TKIT_ASSERT(this->vkWriteMicromapsPropertiesEXT,
                "[VULKIT][LOADER] The function 'vkWriteMicromapsPropertiesEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkWriteMicromapsPropertiesEXT(device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
}
#endif
#if defined(VK_EXT_opacity_micromap)
void DeviceTable::GetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo,
                                                    VkAccelerationStructureCompatibilityKHR *pCompatibility) const
{
    TKIT_ASSERT(this->vkGetDeviceMicromapCompatibilityEXT,
                "[VULKIT][LOADER] The function 'vkGetDeviceMicromapCompatibilityEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetDeviceMicromapCompatibilityEXT(device, pVersionInfo, pCompatibility);
}
#endif
#if defined(VK_EXT_opacity_micromap)
void DeviceTable::GetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType,
                                           const VkMicromapBuildInfoEXT *pBuildInfo,
                                           VkMicromapBuildSizesInfoEXT *pSizeInfo) const
{
    TKIT_ASSERT(this->vkGetMicromapBuildSizesEXT,
                "[VULKIT][LOADER] The function 'vkGetMicromapBuildSizesEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetMicromapBuildSizesEXT(device, buildType, pBuildInfo, pSizeInfo);
}
#endif
#if defined(VK_EXT_shader_module_identifier)
void DeviceTable::GetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule,
                                               VkShaderModuleIdentifierEXT *pIdentifier) const
{
    TKIT_ASSERT(this->vkGetShaderModuleIdentifierEXT,
                "[VULKIT][LOADER] The function 'vkGetShaderModuleIdentifierEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetShaderModuleIdentifierEXT(device, shaderModule, pIdentifier);
}
#endif
#if defined(VK_EXT_shader_module_identifier)
void DeviceTable::GetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo,
                                                         VkShaderModuleIdentifierEXT *pIdentifier) const
{
    TKIT_ASSERT(this->vkGetShaderModuleCreateInfoIdentifierEXT,
                "[VULKIT][LOADER] The function 'vkGetShaderModuleCreateInfoIdentifierEXT' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetShaderModuleCreateInfoIdentifierEXT(device, pCreateInfo, pIdentifier);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::GetImageSubresourceLayout2(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource,
                                             VkSubresourceLayout2 *pLayout) const
{
    TKIT_ASSERT(this->vkGetImageSubresourceLayout2,
                "[VULKIT][LOADER] The function 'vkGetImageSubresourceLayout2' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetImageSubresourceLayout2(device, image, pSubresource, pLayout);
}
#endif
#if defined(VK_EXT_pipeline_properties)
VkResult DeviceTable::GetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo,
                                               VkBaseOutStructure *pPipelineProperties) const
{
    TKIT_ASSERT(this->vkGetPipelinePropertiesEXT,
                "[VULKIT][LOADER] The function 'vkGetPipelinePropertiesEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetPipelinePropertiesEXT(device, pPipelineInfo, pPipelineProperties);
}
#endif
#if defined(VK_EXT_metal_objects)
void DeviceTable::ExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo) const
{
    TKIT_ASSERT(this->vkExportMetalObjectsEXT,
                "[VULKIT][LOADER] The function 'vkExportMetalObjectsEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkExportMetalObjectsEXT(device, pMetalObjectsInfo);
}
#endif
#if defined(VK_QCOM_tile_memory_heap)
void DeviceTable::CmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer,
                                        const VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo) const
{
    TKIT_ASSERT(this->vkCmdBindTileMemoryQCOM,
                "[VULKIT][LOADER] The function 'vkCmdBindTileMemoryQCOM' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindTileMemoryQCOM(commandBuffer, pTileMemoryBindInfo);
}
#endif
#if defined(VK_QCOM_tile_properties)
VkResult DeviceTable::GetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer,
                                                       uint32_t *pPropertiesCount,
                                                       VkTilePropertiesQCOM *pProperties) const
{
    TKIT_ASSERT(this->vkGetFramebufferTilePropertiesQCOM,
                "[VULKIT][LOADER] The function 'vkGetFramebufferTilePropertiesQCOM' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetFramebufferTilePropertiesQCOM(device, framebuffer, pPropertiesCount, pProperties);
}
#endif
#if defined(VK_QCOM_tile_properties)
VkResult DeviceTable::GetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo,
                                                            VkTilePropertiesQCOM *pProperties) const
{
    TKIT_ASSERT(this->vkGetDynamicRenderingTilePropertiesQCOM,
                "[VULKIT][LOADER] The function 'vkGetDynamicRenderingTilePropertiesQCOM' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetDynamicRenderingTilePropertiesQCOM(device, pRenderingInfo, pProperties);
}
#endif
#if defined(VK_NV_optical_flow)
VkResult DeviceTable::CreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo,
                                                 const VkAllocationCallbacks *pAllocator,
                                                 VkOpticalFlowSessionNV *pSession) const
{
    TKIT_ASSERT(this->vkCreateOpticalFlowSessionNV,
                "[VULKIT][LOADER] The function 'vkCreateOpticalFlowSessionNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateOpticalFlowSessionNV(device, pCreateInfo, pAllocator, pSession);
}
#endif
#if defined(VK_NV_optical_flow)
void DeviceTable::DestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session,
                                              const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyOpticalFlowSessionNV,
                "[VULKIT][LOADER] The function 'vkDestroyOpticalFlowSessionNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyOpticalFlowSessionNV(device, session, pAllocator);
}
#endif
#if defined(VK_NV_optical_flow)
VkResult DeviceTable::BindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session,
                                                    VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view,
                                                    VkImageLayout layout) const
{
    TKIT_ASSERT(this->vkBindOpticalFlowSessionImageNV,
                "[VULKIT][LOADER] The function 'vkBindOpticalFlowSessionImageNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkBindOpticalFlowSessionImageNV(device, session, bindingPoint, view, layout);
}
#endif
#if defined(VK_NV_optical_flow)
void DeviceTable::CmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session,
                                          const VkOpticalFlowExecuteInfoNV *pExecuteInfo) const
{
    TKIT_ASSERT(this->vkCmdOpticalFlowExecuteNV,
                "[VULKIT][LOADER] The function 'vkCmdOpticalFlowExecuteNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdOpticalFlowExecuteNV(commandBuffer, session, pExecuteInfo);
}
#endif
#if defined(VK_EXT_device_fault)
VkResult DeviceTable::GetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts,
                                            VkDeviceFaultInfoEXT *pFaultInfo) const
{
    TKIT_ASSERT(this->vkGetDeviceFaultInfoEXT,
                "[VULKIT][LOADER] The function 'vkGetDeviceFaultInfoEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetDeviceFaultInfoEXT(device, pFaultCounts, pFaultInfo);
}
#endif
#if defined(VK_EXT_depth_bias_control)
void DeviceTable::CmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo) const
{
    TKIT_ASSERT(this->vkCmdSetDepthBias2EXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthBias2EXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthBias2EXT(commandBuffer, pDepthBiasInfo);
}
#endif
#if defined(VK_KHR_swapchain_maintenance1)
VkResult DeviceTable::ReleaseSwapchainImagesKHR(VkDevice device,
                                                const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) const
{
    TKIT_ASSERT(this->vkReleaseSwapchainImagesKHR,
                "[VULKIT][LOADER] The function 'vkReleaseSwapchainImagesKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkReleaseSwapchainImagesKHR(device, pReleaseInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::GetDeviceImageSubresourceLayout(VkDevice device, const VkDeviceImageSubresourceInfo *pInfo,
                                                  VkSubresourceLayout2 *pLayout) const
{
    TKIT_ASSERT(this->vkGetDeviceImageSubresourceLayout,
                "[VULKIT][LOADER] The function 'vkGetDeviceImageSubresourceLayout' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetDeviceImageSubresourceLayout(device, pInfo, pLayout);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
VkResult DeviceTable::MapMemory2(VkDevice device, const VkMemoryMapInfo *pMemoryMapInfo, void **ppData) const
{
    TKIT_ASSERT(this->vkMapMemory2, "[VULKIT][LOADER] The function 'vkMapMemory2' is not available for the instance or "
                                    "device being used, either because VKit::Initialize() was not called or "
                                    "because the feature or extension bound to the function has not been enabled");
    return this->vkMapMemory2(device, pMemoryMapInfo, ppData);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
VkResult DeviceTable::UnmapMemory2(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo) const
{
    TKIT_ASSERT(this->vkUnmapMemory2,
                "[VULKIT][LOADER] The function 'vkUnmapMemory2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkUnmapMemory2(device, pMemoryUnmapInfo);
}
#endif
#if defined(VK_EXT_shader_object)
VkResult DeviceTable::CreateShadersEXT(VkDevice device, uint32_t createInfoCount,
                                       const VkShaderCreateInfoEXT *pCreateInfos,
                                       const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders) const
{
    TKIT_ASSERT(this->vkCreateShadersEXT,
                "[VULKIT][LOADER] The function 'vkCreateShadersEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateShadersEXT(device, createInfoCount, pCreateInfos, pAllocator, pShaders);
}
#endif
#if defined(VK_EXT_shader_object)
void DeviceTable::DestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyShaderEXT,
                "[VULKIT][LOADER] The function 'vkDestroyShaderEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyShaderEXT(device, shader, pAllocator);
}
#endif
#if defined(VK_EXT_shader_object)
VkResult DeviceTable::GetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData) const
{
    TKIT_ASSERT(this->vkGetShaderBinaryDataEXT,
                "[VULKIT][LOADER] The function 'vkGetShaderBinaryDataEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetShaderBinaryDataEXT(device, shader, pDataSize, pData);
}
#endif
#if defined(VK_EXT_shader_object)
void DeviceTable::CmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount,
                                    const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders) const
{
    TKIT_ASSERT(this->vkCmdBindShadersEXT,
                "[VULKIT][LOADER] The function 'vkCmdBindShadersEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdBindShadersEXT(commandBuffer, stageCount, pStages, pShaders);
}
#endif
#if defined(VK_QNX_external_memory_screen_buffer)
VkResult DeviceTable::GetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer *buffer,
                                                   VkScreenBufferPropertiesQNX *pProperties) const
{
    TKIT_ASSERT(this->vkGetScreenBufferPropertiesQNX,
                "[VULKIT][LOADER] The function 'vkGetScreenBufferPropertiesQNX' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetScreenBufferPropertiesQNX(device, buffer, pProperties);
}
#endif
#if defined(VK_AMDX_shader_enqueue)
VkResult DeviceTable::GetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph,
                                                               VkExecutionGraphPipelineScratchSizeAMDX *pSizeInfo) const
{
    TKIT_ASSERT(this->vkGetExecutionGraphPipelineScratchSizeAMDX,
                "[VULKIT][LOADER] The function 'vkGetExecutionGraphPipelineScratchSizeAMDX' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetExecutionGraphPipelineScratchSizeAMDX(device, executionGraph, pSizeInfo);
}
#endif
#if defined(VK_AMDX_shader_enqueue)
VkResult DeviceTable::GetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph,
                                                             const VkPipelineShaderStageNodeCreateInfoAMDX *pNodeInfo,
                                                             uint32_t *pNodeIndex) const
{
    TKIT_ASSERT(this->vkGetExecutionGraphPipelineNodeIndexAMDX,
                "[VULKIT][LOADER] The function 'vkGetExecutionGraphPipelineNodeIndexAMDX' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetExecutionGraphPipelineNodeIndexAMDX(device, executionGraph, pNodeInfo, pNodeIndex);
}
#endif
#if defined(VK_AMDX_shader_enqueue)
VkResult DeviceTable::CreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache,
                                                        uint32_t createInfoCount,
                                                        const VkExecutionGraphPipelineCreateInfoAMDX *pCreateInfos,
                                                        const VkAllocationCallbacks *pAllocator,
                                                        VkPipeline *pPipelines) const
{
    TKIT_ASSERT(this->vkCreateExecutionGraphPipelinesAMDX,
                "[VULKIT][LOADER] The function 'vkCreateExecutionGraphPipelinesAMDX' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkCreateExecutionGraphPipelinesAMDX(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator,
                                                     pPipelines);
}
#endif
#if VK_HEADER_VERSION >= 298 && (defined(VK_AMDX_shader_enqueue))
void DeviceTable::CmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph,
                                                      VkDeviceAddress scratch, VkDeviceSize scratchSize) const
{
    TKIT_ASSERT(this->vkCmdInitializeGraphScratchMemoryAMDX,
                "[VULKIT][LOADER] The function 'vkCmdInitializeGraphScratchMemoryAMDX' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdInitializeGraphScratchMemoryAMDX(commandBuffer, executionGraph, scratch, scratchSize);
}
#endif
#if VK_HEADER_VERSION >= 298 && (defined(VK_AMDX_shader_enqueue))
void DeviceTable::CmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize,
                                       const VkDispatchGraphCountInfoAMDX *pCountInfo) const
{
    TKIT_ASSERT(this->vkCmdDispatchGraphAMDX,
                "[VULKIT][LOADER] The function 'vkCmdDispatchGraphAMDX' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDispatchGraphAMDX(commandBuffer, scratch, scratchSize, pCountInfo);
}
#endif
#if VK_HEADER_VERSION >= 298 && (defined(VK_AMDX_shader_enqueue))
void DeviceTable::CmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch,
                                               VkDeviceSize scratchSize,
                                               const VkDispatchGraphCountInfoAMDX *pCountInfo) const
{
    TKIT_ASSERT(this->vkCmdDispatchGraphIndirectAMDX,
                "[VULKIT][LOADER] The function 'vkCmdDispatchGraphIndirectAMDX' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDispatchGraphIndirectAMDX(commandBuffer, scratch, scratchSize, pCountInfo);
}
#endif
#if VK_HEADER_VERSION >= 298 && (defined(VK_AMDX_shader_enqueue))
void DeviceTable::CmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch,
                                                    VkDeviceSize scratchSize, VkDeviceAddress countInfo) const
{
    TKIT_ASSERT(this->vkCmdDispatchGraphIndirectCountAMDX,
                "[VULKIT][LOADER] The function 'vkCmdDispatchGraphIndirectCountAMDX' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdDispatchGraphIndirectCountAMDX(commandBuffer, scratch, scratchSize, countInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdBindDescriptorSets2(VkCommandBuffer commandBuffer,
                                         const VkBindDescriptorSetsInfo *pBindDescriptorSetsInfo) const
{
    TKIT_ASSERT(this->vkCmdBindDescriptorSets2,
                "[VULKIT][LOADER] The function 'vkCmdBindDescriptorSets2' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindDescriptorSets2(commandBuffer, pBindDescriptorSetsInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdPushConstants2(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo) const
{
    TKIT_ASSERT(this->vkCmdPushConstants2,
                "[VULKIT][LOADER] The function 'vkCmdPushConstants2' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdPushConstants2(commandBuffer, pPushConstantsInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdPushDescriptorSet2(VkCommandBuffer commandBuffer,
                                        const VkPushDescriptorSetInfo *pPushDescriptorSetInfo) const
{
    TKIT_ASSERT(this->vkCmdPushDescriptorSet2,
                "[VULKIT][LOADER] The function 'vkCmdPushDescriptorSet2' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdPushDescriptorSet2(commandBuffer, pPushDescriptorSetInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdPushDescriptorSetWithTemplate2(
    VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo *pPushDescriptorSetWithTemplateInfo) const
{
    TKIT_ASSERT(this->vkCmdPushDescriptorSetWithTemplate2,
                "[VULKIT][LOADER] The function 'vkCmdPushDescriptorSetWithTemplate2' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdPushDescriptorSetWithTemplate2(commandBuffer, pPushDescriptorSetWithTemplateInfo);
}
#endif
#if (defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer))
void DeviceTable::CmdSetDescriptorBufferOffsets2EXT(
    VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT *pSetDescriptorBufferOffsetsInfo) const
{
    TKIT_ASSERT(this->vkCmdSetDescriptorBufferOffsets2EXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDescriptorBufferOffsets2EXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdSetDescriptorBufferOffsets2EXT(commandBuffer, pSetDescriptorBufferOffsetsInfo);
}
#endif
#if (defined(VK_KHR_maintenance6) && defined(VK_EXT_descriptor_buffer))
void DeviceTable::CmdBindDescriptorBufferEmbeddedSamplers2EXT(
    VkCommandBuffer commandBuffer,
    const VkBindDescriptorBufferEmbeddedSamplersInfoEXT *pBindDescriptorBufferEmbeddedSamplersInfo) const
{
    TKIT_ASSERT(this->vkCmdBindDescriptorBufferEmbeddedSamplers2EXT,
                "[VULKIT][LOADER] The function 'vkCmdBindDescriptorBufferEmbeddedSamplers2EXT' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    this->vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
}
#endif
#if defined(VK_NV_low_latency2)
VkResult DeviceTable::SetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain,
                                            const VkLatencySleepModeInfoNV *pSleepModeInfo) const
{
    TKIT_ASSERT(this->vkSetLatencySleepModeNV,
                "[VULKIT][LOADER] The function 'vkSetLatencySleepModeNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkSetLatencySleepModeNV(device, swapchain, pSleepModeInfo);
}
#endif
#if defined(VK_NV_low_latency2)
VkResult DeviceTable::LatencySleepNV(VkDevice device, VkSwapchainKHR swapchain,
                                     const VkLatencySleepInfoNV *pSleepInfo) const
{
    TKIT_ASSERT(this->vkLatencySleepNV,
                "[VULKIT][LOADER] The function 'vkLatencySleepNV' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkLatencySleepNV(device, swapchain, pSleepInfo);
}
#endif
#if defined(VK_NV_low_latency2)
void DeviceTable::SetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain,
                                     const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo) const
{
    TKIT_ASSERT(this->vkSetLatencyMarkerNV,
                "[VULKIT][LOADER] The function 'vkSetLatencyMarkerNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkSetLatencyMarkerNV(device, swapchain, pLatencyMarkerInfo);
}
#endif
#if VK_HEADER_VERSION >= 271 && (defined(VK_NV_low_latency2))
void DeviceTable::GetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain,
                                      VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo) const
{
    TKIT_ASSERT(this->vkGetLatencyTimingsNV,
                "[VULKIT][LOADER] The function 'vkGetLatencyTimingsNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetLatencyTimingsNV(device, swapchain, pLatencyMarkerInfo);
}
#endif
#if defined(VK_NV_low_latency2)
void DeviceTable::QueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo) const
{
    TKIT_ASSERT(this->vkQueueNotifyOutOfBandNV,
                "[VULKIT][LOADER] The function 'vkQueueNotifyOutOfBandNV' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkQueueNotifyOutOfBandNV(queue, pQueueTypeInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdSetRenderingAttachmentLocations(VkCommandBuffer commandBuffer,
                                                     const VkRenderingAttachmentLocationInfo *pLocationInfo) const
{
    TKIT_ASSERT(this->vkCmdSetRenderingAttachmentLocations,
                "[VULKIT][LOADER] The function 'vkCmdSetRenderingAttachmentLocations' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetRenderingAttachmentLocations(commandBuffer, pLocationInfo);
}
#endif
#if defined(VKIT_API_VERSION_1_4)
void DeviceTable::CmdSetRenderingInputAttachmentIndices(
    VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo *pInputAttachmentIndexInfo) const
{
    TKIT_ASSERT(this->vkCmdSetRenderingInputAttachmentIndices,
                "[VULKIT][LOADER] The function 'vkCmdSetRenderingInputAttachmentIndices' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetRenderingInputAttachmentIndices(commandBuffer, pInputAttachmentIndexInfo);
}
#endif
#if (defined(VK_EXT_shader_object) && defined(VK_EXT_depth_clamp_control)) || defined(VK_EXT_depth_clamp_control)
void DeviceTable::CmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode,
                                           const VkDepthClampRangeEXT *pDepthClampRange) const
{
    TKIT_ASSERT(this->vkCmdSetDepthClampRangeEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthClampRangeEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthClampRangeEXT(commandBuffer, depthClampMode, pDepthClampRange);
}
#endif
#if defined(VK_EXT_external_memory_metal)
VkResult DeviceTable::GetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT *pGetMetalHandleInfo,
                                              void **pHandle) const
{
    TKIT_ASSERT(this->vkGetMemoryMetalHandleEXT,
                "[VULKIT][LOADER] The function 'vkGetMemoryMetalHandleEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetMemoryMetalHandleEXT(device, pGetMetalHandleInfo, pHandle);
}
#endif
#if defined(VK_EXT_external_memory_metal)
VkResult DeviceTable::GetMemoryMetalHandlePropertiesEXT(
    VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHandle,
    VkMemoryMetalHandlePropertiesEXT *pMemoryMetalHandleProperties) const
{
    TKIT_ASSERT(this->vkGetMemoryMetalHandlePropertiesEXT,
                "[VULKIT][LOADER] The function 'vkGetMemoryMetalHandlePropertiesEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetMemoryMetalHandlePropertiesEXT(device, handleType, pHandle, pMemoryMetalHandleProperties);
}
#endif
#if defined(VK_NV_cooperative_vector)
VkResult DeviceTable::ConvertCooperativeVectorMatrixNV(VkDevice device,
                                                       const VkConvertCooperativeVectorMatrixInfoNV *pInfo) const
{
    TKIT_ASSERT(this->vkConvertCooperativeVectorMatrixNV,
                "[VULKIT][LOADER] The function 'vkConvertCooperativeVectorMatrixNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkConvertCooperativeVectorMatrixNV(device, pInfo);
}
#endif
#if defined(VK_NV_cooperative_vector)
void DeviceTable::CmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32_t infoCount,
                                                      const VkConvertCooperativeVectorMatrixInfoNV *pInfos) const
{
    TKIT_ASSERT(this->vkCmdConvertCooperativeVectorMatrixNV,
                "[VULKIT][LOADER] The function 'vkCmdConvertCooperativeVectorMatrixNV' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdConvertCooperativeVectorMatrixNV(commandBuffer, infoCount, pInfos);
}
#endif
#if defined(VK_QCOM_tile_shading)
void DeviceTable::CmdDispatchTileQCOM(VkCommandBuffer commandBuffer,
                                      const VkDispatchTileInfoQCOM *pDispatchTileInfo) const
{
    TKIT_ASSERT(this->vkCmdDispatchTileQCOM,
                "[VULKIT][LOADER] The function 'vkCmdDispatchTileQCOM' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDispatchTileQCOM(commandBuffer, pDispatchTileInfo);
}
#endif
#if defined(VK_QCOM_tile_shading)
void DeviceTable::CmdBeginPerTileExecutionQCOM(VkCommandBuffer commandBuffer,
                                               const VkPerTileBeginInfoQCOM *pPerTileBeginInfo) const
{
    TKIT_ASSERT(this->vkCmdBeginPerTileExecutionQCOM,
                "[VULKIT][LOADER] The function 'vkCmdBeginPerTileExecutionQCOM' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBeginPerTileExecutionQCOM(commandBuffer, pPerTileBeginInfo);
}
#endif
#if defined(VK_QCOM_tile_shading)
void DeviceTable::CmdEndPerTileExecutionQCOM(VkCommandBuffer commandBuffer,
                                             const VkPerTileEndInfoQCOM *pPerTileEndInfo) const
{
    TKIT_ASSERT(this->vkCmdEndPerTileExecutionQCOM,
                "[VULKIT][LOADER] The function 'vkCmdEndPerTileExecutionQCOM' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdEndPerTileExecutionQCOM(commandBuffer, pPerTileEndInfo);
}
#endif
#if defined(VK_NV_external_compute_queue)
VkResult DeviceTable::CreateExternalComputeQueueNV(VkDevice device,
                                                   const VkExternalComputeQueueCreateInfoNV *pCreateInfo,
                                                   const VkAllocationCallbacks *pAllocator,
                                                   VkExternalComputeQueueNV *pExternalQueue) const
{
    TKIT_ASSERT(this->vkCreateExternalComputeQueueNV,
                "[VULKIT][LOADER] The function 'vkCreateExternalComputeQueueNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateExternalComputeQueueNV(device, pCreateInfo, pAllocator, pExternalQueue);
}
#endif
#if defined(VK_NV_external_compute_queue)
void DeviceTable::DestroyExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueNV externalQueue,
                                                const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyExternalComputeQueueNV,
                "[VULKIT][LOADER] The function 'vkDestroyExternalComputeQueueNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyExternalComputeQueueNV(device, externalQueue, pAllocator);
}
#endif
#if defined(VK_NV_external_compute_queue)
void DeviceTable::GetExternalComputeQueueDataNV(VkExternalComputeQueueNV externalQueue,
                                                VkExternalComputeQueueDataParamsNV *params, void *pData) const
{
    TKIT_ASSERT(this->vkGetExternalComputeQueueDataNV,
                "[VULKIT][LOADER] The function 'vkGetExternalComputeQueueDataNV' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetExternalComputeQueueDataNV(externalQueue, params, pData);
}
#endif
#if defined(VK_ARM_tensors)
VkResult DeviceTable::CreateTensorARM(VkDevice device, const VkTensorCreateInfoARM *pCreateInfo,
                                      const VkAllocationCallbacks *pAllocator, VkTensorARM *pTensor) const
{
    TKIT_ASSERT(this->vkCreateTensorARM,
                "[VULKIT][LOADER] The function 'vkCreateTensorARM' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkCreateTensorARM(device, pCreateInfo, pAllocator, pTensor);
}
#endif
#if defined(VK_ARM_tensors)
void DeviceTable::DestroyTensorARM(VkDevice device, VkTensorARM tensor, const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyTensorARM,
                "[VULKIT][LOADER] The function 'vkDestroyTensorARM' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkDestroyTensorARM(device, tensor, pAllocator);
}
#endif
#if defined(VK_ARM_tensors)
VkResult DeviceTable::CreateTensorViewARM(VkDevice device, const VkTensorViewCreateInfoARM *pCreateInfo,
                                          const VkAllocationCallbacks *pAllocator, VkTensorViewARM *pView) const
{
    TKIT_ASSERT(this->vkCreateTensorViewARM,
                "[VULKIT][LOADER] The function 'vkCreateTensorViewARM' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateTensorViewARM(device, pCreateInfo, pAllocator, pView);
}
#endif
#if defined(VK_ARM_tensors)
void DeviceTable::DestroyTensorViewARM(VkDevice device, VkTensorViewARM tensorView,
                                       const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyTensorViewARM,
                "[VULKIT][LOADER] The function 'vkDestroyTensorViewARM' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyTensorViewARM(device, tensorView, pAllocator);
}
#endif
#if defined(VK_ARM_tensors)
void DeviceTable::GetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemoryRequirementsInfoARM *pInfo,
                                                 VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetTensorMemoryRequirementsARM,
                "[VULKIT][LOADER] The function 'vkGetTensorMemoryRequirementsARM' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_ARM_tensors)
VkResult DeviceTable::BindTensorMemoryARM(VkDevice device, uint32_t bindInfoCount,
                                          const VkBindTensorMemoryInfoARM *pBindInfos) const
{
    TKIT_ASSERT(this->vkBindTensorMemoryARM,
                "[VULKIT][LOADER] The function 'vkBindTensorMemoryARM' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkBindTensorMemoryARM(device, bindInfoCount, pBindInfos);
}
#endif
#if defined(VK_ARM_tensors)
void DeviceTable::GetDeviceTensorMemoryRequirementsARM(VkDevice device,
                                                       const VkDeviceTensorMemoryRequirementsARM *pInfo,
                                                       VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetDeviceTensorMemoryRequirementsARM,
                "[VULKIT][LOADER] The function 'vkGetDeviceTensorMemoryRequirementsARM' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetDeviceTensorMemoryRequirementsARM(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_ARM_tensors)
void DeviceTable::CmdCopyTensorARM(VkCommandBuffer commandBuffer, const VkCopyTensorInfoARM *pCopyTensorInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyTensorARM,
                "[VULKIT][LOADER] The function 'vkCmdCopyTensorARM' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdCopyTensorARM(commandBuffer, pCopyTensorInfo);
}
#endif
#if (defined(VK_ARM_tensors) && defined(VK_EXT_descriptor_buffer))
VkResult DeviceTable::GetTensorOpaqueCaptureDescriptorDataARM(VkDevice device,
                                                              const VkTensorCaptureDescriptorDataInfoARM *pInfo,
                                                              void *pData) const
{
    TKIT_ASSERT(this->vkGetTensorOpaqueCaptureDescriptorDataARM,
                "[VULKIT][LOADER] The function 'vkGetTensorOpaqueCaptureDescriptorDataARM' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetTensorOpaqueCaptureDescriptorDataARM(device, pInfo, pData);
}
#endif
#if (defined(VK_ARM_tensors) && defined(VK_EXT_descriptor_buffer))
VkResult DeviceTable::GetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device,
                                                                  const VkTensorViewCaptureDescriptorDataInfoARM *pInfo,
                                                                  void *pData) const
{
    TKIT_ASSERT(this->vkGetTensorViewOpaqueCaptureDescriptorDataARM,
                "[VULKIT][LOADER] The function 'vkGetTensorViewOpaqueCaptureDescriptorDataARM' is not available for "
                "the instance or device being used, either because VKit::Initialize() was not called or because "
                "the feature or extension bound to the function has not been enabled");
    return this->vkGetTensorViewOpaqueCaptureDescriptorDataARM(device, pInfo, pData);
}
#endif
#if defined(VK_ARM_data_graph)
VkResult DeviceTable::CreateDataGraphPipelinesARM(VkDevice device, VkDeferredOperationKHR deferredOperation,
                                                  VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                                  const VkDataGraphPipelineCreateInfoARM *pCreateInfos,
                                                  const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) const
{
    TKIT_ASSERT(this->vkCreateDataGraphPipelinesARM,
                "[VULKIT][LOADER] The function 'vkCreateDataGraphPipelinesARM' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateDataGraphPipelinesARM(device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos,
                                               pAllocator, pPipelines);
}
#endif
#if defined(VK_ARM_data_graph)
VkResult DeviceTable::CreateDataGraphPipelineSessionARM(VkDevice device,
                                                        const VkDataGraphPipelineSessionCreateInfoARM *pCreateInfo,
                                                        const VkAllocationCallbacks *pAllocator,
                                                        VkDataGraphPipelineSessionARM *pSession) const
{
    TKIT_ASSERT(this->vkCreateDataGraphPipelineSessionARM,
                "[VULKIT][LOADER] The function 'vkCreateDataGraphPipelineSessionARM' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkCreateDataGraphPipelineSessionARM(device, pCreateInfo, pAllocator, pSession);
}
#endif
#if defined(VK_ARM_data_graph)
VkResult DeviceTable::GetDataGraphPipelineSessionBindPointRequirementsARM(
    VkDevice device, const VkDataGraphPipelineSessionBindPointRequirementsInfoARM *pInfo,
    uint32_t *pBindPointRequirementCount,
    VkDataGraphPipelineSessionBindPointRequirementARM *pBindPointRequirements) const
{
    TKIT_ASSERT(this->vkGetDataGraphPipelineSessionBindPointRequirementsARM,
                "[VULKIT][LOADER] The function 'vkGetDataGraphPipelineSessionBindPointRequirementsARM' is not "
                "available for the instance or device being used, either because VKit::Initialize() was not "
                "called or because the feature or extension bound to the function has not been enabled");
    return this->vkGetDataGraphPipelineSessionBindPointRequirementsARM(device, pInfo, pBindPointRequirementCount,
                                                                       pBindPointRequirements);
}
#endif
#if defined(VK_ARM_data_graph)
void DeviceTable::GetDataGraphPipelineSessionMemoryRequirementsARM(
    VkDevice device, const VkDataGraphPipelineSessionMemoryRequirementsInfoARM *pInfo,
    VkMemoryRequirements2 *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetDataGraphPipelineSessionMemoryRequirementsARM,
                "[VULKIT][LOADER] The function 'vkGetDataGraphPipelineSessionMemoryRequirementsARM' is not available "
                "for the instance or device being used, either because VKit::Initialize() was not called or "
                "because the feature or extension bound to the function has not been enabled");
    this->vkGetDataGraphPipelineSessionMemoryRequirementsARM(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_ARM_data_graph)
VkResult DeviceTable::BindDataGraphPipelineSessionMemoryARM(
    VkDevice device, uint32_t bindInfoCount, const VkBindDataGraphPipelineSessionMemoryInfoARM *pBindInfos) const
{
    TKIT_ASSERT(this->vkBindDataGraphPipelineSessionMemoryARM,
                "[VULKIT][LOADER] The function 'vkBindDataGraphPipelineSessionMemoryARM' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkBindDataGraphPipelineSessionMemoryARM(device, bindInfoCount, pBindInfos);
}
#endif
#if defined(VK_ARM_data_graph)
void DeviceTable::DestroyDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionARM session,
                                                     const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyDataGraphPipelineSessionARM,
                "[VULKIT][LOADER] The function 'vkDestroyDataGraphPipelineSessionARM' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkDestroyDataGraphPipelineSessionARM(device, session, pAllocator);
}
#endif
#if defined(VK_ARM_data_graph)
void DeviceTable::CmdDispatchDataGraphARM(VkCommandBuffer commandBuffer, VkDataGraphPipelineSessionARM session,
                                          const VkDataGraphPipelineDispatchInfoARM *pInfo) const
{
    TKIT_ASSERT(this->vkCmdDispatchDataGraphARM,
                "[VULKIT][LOADER] The function 'vkCmdDispatchDataGraphARM' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDispatchDataGraphARM(commandBuffer, session, pInfo);
}
#endif
#if defined(VK_ARM_data_graph)
VkResult DeviceTable::GetDataGraphPipelineAvailablePropertiesARM(VkDevice device,
                                                                 const VkDataGraphPipelineInfoARM *pPipelineInfo,
                                                                 uint32_t *pPropertiesCount,
                                                                 VkDataGraphPipelinePropertyARM *pProperties) const
{
    TKIT_ASSERT(this->vkGetDataGraphPipelineAvailablePropertiesARM,
                "[VULKIT][LOADER] The function 'vkGetDataGraphPipelineAvailablePropertiesARM' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetDataGraphPipelineAvailablePropertiesARM(device, pPipelineInfo, pPropertiesCount, pProperties);
}
#endif
#if defined(VK_ARM_data_graph)
VkResult DeviceTable::GetDataGraphPipelinePropertiesARM(VkDevice device,
                                                        const VkDataGraphPipelineInfoARM *pPipelineInfo,
                                                        uint32_t propertiesCount,
                                                        VkDataGraphPipelinePropertyQueryResultARM *pProperties) const
{
    TKIT_ASSERT(this->vkGetDataGraphPipelinePropertiesARM,
                "[VULKIT][LOADER] The function 'vkGetDataGraphPipelinePropertiesARM' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetDataGraphPipelinePropertiesARM(device, pPipelineInfo, propertiesCount, pProperties);
}
#endif
#if defined(VK_EXT_host_query_reset)
void DeviceTable::ResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery,
                                    uint32_t queryCount) const
{
    TKIT_ASSERT(this->vkResetQueryPoolEXT,
                "[VULKIT][LOADER] The function 'vkResetQueryPoolEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount);
}
#endif
#if defined(VK_KHR_maintenance5)
void DeviceTable::GetRenderingAreaGranularityKHR(VkDevice device, const VkRenderingAreaInfoKHR *pRenderingAreaInfo,
                                                 VkExtent2D *pGranularity) const
{
    TKIT_ASSERT(this->vkGetRenderingAreaGranularityKHR,
                "[VULKIT][LOADER] The function 'vkGetRenderingAreaGranularityKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetRenderingAreaGranularityKHR(device, pRenderingAreaInfo, pGranularity);
}
#endif
#if defined(VK_KHR_push_descriptor)
void DeviceTable::CmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                                          VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount,
                                          const VkWriteDescriptorSet *pDescriptorWrites) const
{
    TKIT_ASSERT(this->vkCmdPushDescriptorSetKHR,
                "[VULKIT][LOADER] The function 'vkCmdPushDescriptorSetKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount,
                                    pDescriptorWrites);
}
#endif
#if defined(VK_KHR_maintenance1)
void DeviceTable::TrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlagsKHR flags) const
{
    TKIT_ASSERT(this->vkTrimCommandPoolKHR,
                "[VULKIT][LOADER] The function 'vkTrimCommandPoolKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkTrimCommandPoolKHR(device, commandPool, flags);
}
#endif
#if defined(VK_KHR_device_group)
void DeviceTable::GetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex,
                                                      uint32_t remoteDeviceIndex,
                                                      VkPeerMemoryFeatureFlagsKHR *pPeerMemoryFeatures) const
{
    TKIT_ASSERT(this->vkGetDeviceGroupPeerMemoryFeaturesKHR,
                "[VULKIT][LOADER] The function 'vkGetDeviceGroupPeerMemoryFeaturesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex,
                                                pPeerMemoryFeatures);
}
#endif
#if defined(VK_KHR_bind_memory2)
VkResult DeviceTable::BindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                           const VkBindBufferMemoryInfoKHR *pBindInfos) const
{
    TKIT_ASSERT(this->vkBindBufferMemory2KHR,
                "[VULKIT][LOADER] The function 'vkBindBufferMemory2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos);
}
#endif
#if defined(VK_KHR_bind_memory2)
VkResult DeviceTable::BindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount,
                                          const VkBindImageMemoryInfoKHR *pBindInfos) const
{
    TKIT_ASSERT(this->vkBindImageMemory2KHR,
                "[VULKIT][LOADER] The function 'vkBindImageMemory2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkBindImageMemory2KHR(device, bindInfoCount, pBindInfos);
}
#endif
#if defined(VK_KHR_device_group)
void DeviceTable::CmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) const
{
    TKIT_ASSERT(this->vkCmdSetDeviceMaskKHR,
                "[VULKIT][LOADER] The function 'vkCmdSetDeviceMaskKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDeviceMaskKHR(commandBuffer, deviceMask);
}
#endif
#if defined(VK_KHR_device_group)
void DeviceTable::CmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY,
                                     uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY,
                                     uint32_t groupCountZ) const
{
    TKIT_ASSERT(this->vkCmdDispatchBaseKHR,
                "[VULKIT][LOADER] The function 'vkCmdDispatchBaseKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY,
                               groupCountZ);
}
#endif
#if defined(VK_KHR_descriptor_update_template)
VkResult DeviceTable::CreateDescriptorUpdateTemplateKHR(VkDevice device,
                                                        const VkDescriptorUpdateTemplateCreateInfoKHR *pCreateInfo,
                                                        const VkAllocationCallbacks *pAllocator,
                                                        VkDescriptorUpdateTemplateKHR *pDescriptorUpdateTemplate) const
{
    TKIT_ASSERT(this->vkCreateDescriptorUpdateTemplateKHR,
                "[VULKIT][LOADER] The function 'vkCreateDescriptorUpdateTemplateKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
}
#endif
#if defined(VK_KHR_descriptor_update_template)
void DeviceTable::DestroyDescriptorUpdateTemplateKHR(VkDevice device,
                                                     VkDescriptorUpdateTemplateKHR descriptorUpdateTemplate,
                                                     const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyDescriptorUpdateTemplateKHR,
                "[VULKIT][LOADER] The function 'vkDestroyDescriptorUpdateTemplateKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator);
}
#endif
#if defined(VK_KHR_descriptor_update_template)
void DeviceTable::UpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet,
                                                     VkDescriptorUpdateTemplateKHR descriptorUpdateTemplate,
                                                     const void *pData) const
{
    TKIT_ASSERT(this->vkUpdateDescriptorSetWithTemplateKHR,
                "[VULKIT][LOADER] The function 'vkUpdateDescriptorSetWithTemplateKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData);
}
#endif
#if (defined(VK_KHR_push_descriptor) &&                                                                                \
     (defined(VKIT_API_VERSION_1_1) || defined(VK_KHR_descriptor_update_template))) ||                                 \
    (defined(VK_KHR_descriptor_update_template) && defined(VK_KHR_push_descriptor))
void DeviceTable::CmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer,
                                                      VkDescriptorUpdateTemplateKHR descriptorUpdateTemplate,
                                                      VkPipelineLayout layout, uint32_t set, const void *pData) const
{
    TKIT_ASSERT(this->vkCmdPushDescriptorSetWithTemplateKHR,
                "[VULKIT][LOADER] The function 'vkCmdPushDescriptorSetWithTemplateKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
}
#endif
#if defined(VK_KHR_get_memory_requirements2)
void DeviceTable::GetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2KHR *pInfo,
                                                  VkMemoryRequirements2KHR *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetBufferMemoryRequirements2KHR,
                "[VULKIT][LOADER] The function 'vkGetBufferMemoryRequirements2KHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_KHR_get_memory_requirements2)
void DeviceTable::GetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2KHR *pInfo,
                                                 VkMemoryRequirements2KHR *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetImageMemoryRequirements2KHR,
                "[VULKIT][LOADER] The function 'vkGetImageMemoryRequirements2KHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_KHR_get_memory_requirements2)
void DeviceTable::GetImageSparseMemoryRequirements2KHR(
    VkDevice device, const VkImageSparseMemoryRequirementsInfo2KHR *pInfo, uint32_t *pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2KHR *pSparseMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetImageSparseMemoryRequirements2KHR,
                "[VULKIT][LOADER] The function 'vkGetImageSparseMemoryRequirements2KHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount,
                                                 pSparseMemoryRequirements);
}
#endif
#if defined(VK_KHR_maintenance4)
void DeviceTable::GetDeviceBufferMemoryRequirementsKHR(VkDevice device,
                                                       const VkDeviceBufferMemoryRequirementsKHR *pInfo,
                                                       VkMemoryRequirements2KHR *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetDeviceBufferMemoryRequirementsKHR,
                "[VULKIT][LOADER] The function 'vkGetDeviceBufferMemoryRequirementsKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetDeviceBufferMemoryRequirementsKHR(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_KHR_maintenance4)
void DeviceTable::GetDeviceImageMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirementsKHR *pInfo,
                                                      VkMemoryRequirements2KHR *pMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetDeviceImageMemoryRequirementsKHR,
                "[VULKIT][LOADER] The function 'vkGetDeviceImageMemoryRequirementsKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetDeviceImageMemoryRequirementsKHR(device, pInfo, pMemoryRequirements);
}
#endif
#if defined(VK_KHR_maintenance4)
void DeviceTable::GetDeviceImageSparseMemoryRequirementsKHR(
    VkDevice device, const VkDeviceImageMemoryRequirementsKHR *pInfo, uint32_t *pSparseMemoryRequirementCount,
    VkSparseImageMemoryRequirements2KHR *pSparseMemoryRequirements) const
{
    TKIT_ASSERT(this->vkGetDeviceImageSparseMemoryRequirementsKHR,
                "[VULKIT][LOADER] The function 'vkGetDeviceImageSparseMemoryRequirementsKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetDeviceImageSparseMemoryRequirementsKHR(device, pInfo, pSparseMemoryRequirementCount,
                                                      pSparseMemoryRequirements);
}
#endif
#if defined(VK_KHR_sampler_ycbcr_conversion)
VkResult DeviceTable::CreateSamplerYcbcrConversionKHR(VkDevice device,
                                                      const VkSamplerYcbcrConversionCreateInfoKHR *pCreateInfo,
                                                      const VkAllocationCallbacks *pAllocator,
                                                      VkSamplerYcbcrConversionKHR *pYcbcrConversion) const
{
    TKIT_ASSERT(this->vkCreateSamplerYcbcrConversionKHR,
                "[VULKIT][LOADER] The function 'vkCreateSamplerYcbcrConversionKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion);
}
#endif
#if defined(VK_KHR_sampler_ycbcr_conversion)
void DeviceTable::DestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversionKHR ycbcrConversion,
                                                   const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroySamplerYcbcrConversionKHR,
                "[VULKIT][LOADER] The function 'vkDestroySamplerYcbcrConversionKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator);
}
#endif
#if defined(VK_KHR_maintenance3)
void DeviceTable::GetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo,
                                                   VkDescriptorSetLayoutSupportKHR *pSupport) const
{
    TKIT_ASSERT(this->vkGetDescriptorSetLayoutSupportKHR,
                "[VULKIT][LOADER] The function 'vkGetDescriptorSetLayoutSupportKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport);
}
#endif
#if defined(VK_EXT_calibrated_timestamps)
VkResult DeviceTable::GetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount,
                                                 const VkCalibratedTimestampInfoEXT *pTimestampInfos,
                                                 uint64_t *pTimestamps, uint64_t *pMaxDeviation) const
{
    TKIT_ASSERT(this->vkGetCalibratedTimestampsEXT,
                "[VULKIT][LOADER] The function 'vkGetCalibratedTimestampsEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
}
#endif
#if defined(VK_KHR_create_renderpass2)
VkResult DeviceTable::CreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2KHR *pCreateInfo,
                                           const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) const
{
    TKIT_ASSERT(this->vkCreateRenderPass2KHR,
                "[VULKIT][LOADER] The function 'vkCreateRenderPass2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass);
}
#endif
#if defined(VK_KHR_create_renderpass2)
void DeviceTable::CmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin,
                                         const VkSubpassBeginInfoKHR *pSubpassBeginInfo) const
{
    TKIT_ASSERT(this->vkCmdBeginRenderPass2KHR,
                "[VULKIT][LOADER] The function 'vkCmdBeginRenderPass2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
}
#endif
#if defined(VK_KHR_create_renderpass2)
void DeviceTable::CmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfoKHR *pSubpassBeginInfo,
                                     const VkSubpassEndInfoKHR *pSubpassEndInfo) const
{
    TKIT_ASSERT(this->vkCmdNextSubpass2KHR,
                "[VULKIT][LOADER] The function 'vkCmdNextSubpass2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
}
#endif
#if defined(VK_KHR_create_renderpass2)
void DeviceTable::CmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfoKHR *pSubpassEndInfo) const
{
    TKIT_ASSERT(this->vkCmdEndRenderPass2KHR,
                "[VULKIT][LOADER] The function 'vkCmdEndRenderPass2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo);
}
#endif
#if defined(VK_KHR_timeline_semaphore)
VkResult DeviceTable::GetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) const
{
    TKIT_ASSERT(this->vkGetSemaphoreCounterValueKHR,
                "[VULKIT][LOADER] The function 'vkGetSemaphoreCounterValueKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetSemaphoreCounterValueKHR(device, semaphore, pValue);
}
#endif
#if defined(VK_KHR_timeline_semaphore)
VkResult DeviceTable::WaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfoKHR *pWaitInfo,
                                        uint64_t timeout) const
{
    TKIT_ASSERT(this->vkWaitSemaphoresKHR,
                "[VULKIT][LOADER] The function 'vkWaitSemaphoresKHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkWaitSemaphoresKHR(device, pWaitInfo, timeout);
}
#endif
#if defined(VK_KHR_timeline_semaphore)
VkResult DeviceTable::SignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfoKHR *pSignalInfo) const
{
    TKIT_ASSERT(this->vkSignalSemaphoreKHR,
                "[VULKIT][LOADER] The function 'vkSignalSemaphoreKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkSignalSemaphoreKHR(device, pSignalInfo);
}
#endif
#if defined(VK_KHR_draw_indirect_count)
void DeviceTable::CmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                          VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                          uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawIndirectCountKHR,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndirectCountKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                    stride);
}
#endif
#if defined(VK_AMD_draw_indirect_count)
void DeviceTable::CmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                          VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount,
                                          uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawIndirectCountAMD,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndirectCountAMD' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                    stride);
}
#endif
#if defined(VK_KHR_draw_indirect_count)
void DeviceTable::CmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                 VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                                 uint32_t maxDrawCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawIndexedIndirectCountKHR,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndexedIndirectCountKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                           stride);
}
#endif
#if defined(VK_AMD_draw_indirect_count)
void DeviceTable::CmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                                 VkBuffer countBuffer, VkDeviceSize countBufferOffset,
                                                 uint32_t maxDrawCount, uint32_t stride) const
{
    TKIT_ASSERT(this->vkCmdDrawIndexedIndirectCountAMD,
                "[VULKIT][LOADER] The function 'vkCmdDrawIndexedIndirectCountAMD' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount,
                                           stride);
}
#endif
#if defined(VK_NV_ray_tracing)
VkResult DeviceTable::GetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup,
                                                        uint32_t groupCount, size_t dataSize, void *pData) const
{
    TKIT_ASSERT(this->vkGetRayTracingShaderGroupHandlesNV,
                "[VULKIT][LOADER] The function 'vkGetRayTracingShaderGroupHandlesNV' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData);
}
#endif
#if defined(VK_KHR_buffer_device_address)
uint64_t DeviceTable::GetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkGetBufferOpaqueCaptureAddressKHR,
                "[VULKIT][LOADER] The function 'vkGetBufferOpaqueCaptureAddressKHR' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    return this->vkGetBufferOpaqueCaptureAddressKHR(device, pInfo);
}
#endif
#if defined(VK_KHR_buffer_device_address)
VkDeviceAddress DeviceTable::GetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkGetBufferDeviceAddressKHR,
                "[VULKIT][LOADER] The function 'vkGetBufferDeviceAddressKHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetBufferDeviceAddressKHR(device, pInfo);
}
#endif
#if defined(VK_EXT_buffer_device_address)
VkDeviceAddress DeviceTable::GetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfoEXT *pInfo) const
{
    TKIT_ASSERT(this->vkGetBufferDeviceAddressEXT,
                "[VULKIT][LOADER] The function 'vkGetBufferDeviceAddressEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkGetBufferDeviceAddressEXT(device, pInfo);
}
#endif
#if defined(VK_KHR_buffer_device_address)
uint64_t DeviceTable::GetDeviceMemoryOpaqueCaptureAddressKHR(
    VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfoKHR *pInfo) const
{
    TKIT_ASSERT(this->vkGetDeviceMemoryOpaqueCaptureAddressKHR,
                "[VULKIT][LOADER] The function 'vkGetDeviceMemoryOpaqueCaptureAddressKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    return this->vkGetDeviceMemoryOpaqueCaptureAddressKHR(device, pInfo);
}
#endif
#if defined(VK_KHR_line_rasterization)
void DeviceTable::CmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                       uint16_t lineStipplePattern) const
{
    TKIT_ASSERT(this->vkCmdSetLineStippleKHR,
                "[VULKIT][LOADER] The function 'vkCmdSetLineStippleKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetLineStippleKHR(commandBuffer, lineStippleFactor, lineStipplePattern);
}
#endif
#if defined(VK_EXT_line_rasterization)
void DeviceTable::CmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor,
                                       uint16_t lineStipplePattern) const
{
    TKIT_ASSERT(this->vkCmdSetLineStippleEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetLineStippleEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) const
{
    TKIT_ASSERT(this->vkCmdSetCullModeEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetCullModeEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetCullModeEXT(commandBuffer, cullMode);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) const
{
    TKIT_ASSERT(this->vkCmdSetFrontFaceEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetFrontFaceEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetFrontFaceEXT(commandBuffer, frontFace);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) const
{
    TKIT_ASSERT(this->vkCmdSetPrimitiveTopologyEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetPrimitiveTopologyEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetPrimitiveTopologyEXT(commandBuffer, primitiveTopology);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount,
                                             const VkViewport *pViewports) const
{
    TKIT_ASSERT(this->vkCmdSetViewportWithCountEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetViewportWithCountEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetViewportWithCountEXT(commandBuffer, viewportCount, pViewports);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount,
                                            const VkRect2D *pScissors) const
{
    TKIT_ASSERT(this->vkCmdSetScissorWithCountEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetScissorWithCountEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetScissorWithCountEXT(commandBuffer, scissorCount, pScissors);
}
#endif
#if defined(VK_KHR_maintenance5)
void DeviceTable::CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset,
                                         VkDeviceSize size, VkIndexType indexType) const
{
    TKIT_ASSERT(this->vkCmdBindIndexBuffer2KHR,
                "[VULKIT][LOADER] The function 'vkCmdBindIndexBuffer2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindIndexBuffer2KHR(commandBuffer, buffer, offset, size, indexType);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount,
                                           const VkBuffer *pBuffers, const VkDeviceSize *pOffsets,
                                           const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) const
{
    TKIT_ASSERT(this->vkCmdBindVertexBuffers2EXT,
                "[VULKIT][LOADER] The function 'vkCmdBindVertexBuffers2EXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindVertexBuffers2EXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthTestEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthTestEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthTestEnableEXT(commandBuffer, depthTestEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthWriteEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthWriteEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthWriteEnableEXT(commandBuffer, depthWriteEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) const
{
    TKIT_ASSERT(this->vkCmdSetDepthCompareOpEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthCompareOpEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthCompareOpEXT(commandBuffer, depthCompareOp);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthBoundsTestEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthBoundsTestEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthBoundsTestEnableEXT(commandBuffer, depthBoundsTestEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) const
{
    TKIT_ASSERT(this->vkCmdSetStencilTestEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetStencilTestEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetStencilTestEnableEXT(commandBuffer, stencilTestEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp,
                                     VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) const
{
    TKIT_ASSERT(this->vkCmdSetStencilOpEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetStencilOpEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetStencilOpEXT(commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
}
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer,
                                                   VkBool32 rasterizerDiscardEnable) const
{
    TKIT_ASSERT(this->vkCmdSetRasterizerDiscardEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetRasterizerDiscardEnableEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdSetRasterizerDiscardEnableEXT(commandBuffer, rasterizerDiscardEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) const
{
    TKIT_ASSERT(this->vkCmdSetDepthBiasEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetDepthBiasEnableEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdSetDepthBiasEnableEXT(commandBuffer, depthBiasEnable);
}
#endif
#if defined(VK_EXT_extended_dynamic_state2) || defined(VK_EXT_shader_object)
void DeviceTable::CmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) const
{
    TKIT_ASSERT(this->vkCmdSetPrimitiveRestartEnableEXT,
                "[VULKIT][LOADER] The function 'vkCmdSetPrimitiveRestartEnableEXT' is not available for the instance "
                "or device being used, either because VKit::Initialize() was not called or because the feature "
                "or extension bound to the function has not been enabled");
    this->vkCmdSetPrimitiveRestartEnableEXT(commandBuffer, primitiveRestartEnable);
}
#endif
#if defined(VK_EXT_private_data)
VkResult DeviceTable::CreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfoEXT *pCreateInfo,
                                               const VkAllocationCallbacks *pAllocator,
                                               VkPrivateDataSlotEXT *pPrivateDataSlot) const
{
    TKIT_ASSERT(this->vkCreatePrivateDataSlotEXT,
                "[VULKIT][LOADER] The function 'vkCreatePrivateDataSlotEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCreatePrivateDataSlotEXT(device, pCreateInfo, pAllocator, pPrivateDataSlot);
}
#endif
#if defined(VK_EXT_private_data)
void DeviceTable::DestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlotEXT privateDataSlot,
                                            const VkAllocationCallbacks *pAllocator) const
{
    TKIT_ASSERT(this->vkDestroyPrivateDataSlotEXT,
                "[VULKIT][LOADER] The function 'vkDestroyPrivateDataSlotEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkDestroyPrivateDataSlotEXT(device, privateDataSlot, pAllocator);
}
#endif
#if defined(VK_EXT_private_data)
VkResult DeviceTable::SetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                        VkPrivateDataSlotEXT privateDataSlot, uint64_t data) const
{
    TKIT_ASSERT(this->vkSetPrivateDataEXT,
                "[VULKIT][LOADER] The function 'vkSetPrivateDataEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkSetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, data);
}
#endif
#if defined(VK_EXT_private_data)
void DeviceTable::GetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle,
                                    VkPrivateDataSlotEXT privateDataSlot, uint64_t *pData) const
{
    TKIT_ASSERT(this->vkGetPrivateDataEXT,
                "[VULKIT][LOADER] The function 'vkGetPrivateDataEXT' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkGetPrivateDataEXT(device, objectType, objectHandle, privateDataSlot, pData);
}
#endif
#if defined(VK_KHR_copy_commands2)
void DeviceTable::CmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2KHR *pCopyBufferInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyBuffer2KHR,
                "[VULKIT][LOADER] The function 'vkCmdCopyBuffer2KHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdCopyBuffer2KHR(commandBuffer, pCopyBufferInfo);
}
#endif
#if defined(VK_KHR_copy_commands2)
void DeviceTable::CmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2KHR *pCopyImageInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyImage2KHR,
                "[VULKIT][LOADER] The function 'vkCmdCopyImage2KHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdCopyImage2KHR(commandBuffer, pCopyImageInfo);
}
#endif
#if defined(VK_KHR_copy_commands2)
void DeviceTable::CmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2KHR *pBlitImageInfo) const
{
    TKIT_ASSERT(this->vkCmdBlitImage2KHR,
                "[VULKIT][LOADER] The function 'vkCmdBlitImage2KHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdBlitImage2KHR(commandBuffer, pBlitImageInfo);
}
#endif
#if defined(VK_KHR_copy_commands2)
void DeviceTable::CmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer,
                                           const VkCopyBufferToImageInfo2KHR *pCopyBufferToImageInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyBufferToImage2KHR,
                "[VULKIT][LOADER] The function 'vkCmdCopyBufferToImage2KHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyBufferToImage2KHR(commandBuffer, pCopyBufferToImageInfo);
}
#endif
#if defined(VK_KHR_copy_commands2)
void DeviceTable::CmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer,
                                           const VkCopyImageToBufferInfo2KHR *pCopyImageToBufferInfo) const
{
    TKIT_ASSERT(this->vkCmdCopyImageToBuffer2KHR,
                "[VULKIT][LOADER] The function 'vkCmdCopyImageToBuffer2KHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdCopyImageToBuffer2KHR(commandBuffer, pCopyImageToBufferInfo);
}
#endif
#if defined(VK_KHR_copy_commands2)
void DeviceTable::CmdResolveImage2KHR(VkCommandBuffer commandBuffer,
                                      const VkResolveImageInfo2KHR *pResolveImageInfo) const
{
    TKIT_ASSERT(this->vkCmdResolveImage2KHR,
                "[VULKIT][LOADER] The function 'vkCmdResolveImage2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdResolveImage2KHR(commandBuffer, pResolveImageInfo);
}
#endif
#if defined(VK_KHR_synchronization2)
void DeviceTable::CmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event,
                                  const VkDependencyInfoKHR *pDependencyInfo) const
{
    TKIT_ASSERT(this->vkCmdSetEvent2KHR,
                "[VULKIT][LOADER] The function 'vkCmdSetEvent2KHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdSetEvent2KHR(commandBuffer, event, pDependencyInfo);
}
#endif
#if defined(VK_KHR_synchronization2)
void DeviceTable::CmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event,
                                    VkPipelineStageFlags2KHR stageMask) const
{
    TKIT_ASSERT(this->vkCmdResetEvent2KHR,
                "[VULKIT][LOADER] The function 'vkCmdResetEvent2KHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdResetEvent2KHR(commandBuffer, event, stageMask);
}
#endif
#if defined(VK_KHR_synchronization2)
void DeviceTable::CmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents,
                                    const VkDependencyInfoKHR *pDependencyInfos) const
{
    TKIT_ASSERT(this->vkCmdWaitEvents2KHR,
                "[VULKIT][LOADER] The function 'vkCmdWaitEvents2KHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    this->vkCmdWaitEvents2KHR(commandBuffer, eventCount, pEvents, pDependencyInfos);
}
#endif
#if defined(VK_KHR_synchronization2)
void DeviceTable::CmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer,
                                         const VkDependencyInfoKHR *pDependencyInfo) const
{
    TKIT_ASSERT(this->vkCmdPipelineBarrier2KHR,
                "[VULKIT][LOADER] The function 'vkCmdPipelineBarrier2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdPipelineBarrier2KHR(commandBuffer, pDependencyInfo);
}
#endif
#if defined(VK_KHR_synchronization2)
VkResult DeviceTable::QueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2KHR *pSubmits,
                                      VkFence fence) const
{
    TKIT_ASSERT(this->vkQueueSubmit2KHR,
                "[VULKIT][LOADER] The function 'vkQueueSubmit2KHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkQueueSubmit2KHR(queue, submitCount, pSubmits, fence);
}
#endif
#if defined(VK_KHR_synchronization2)
void DeviceTable::CmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2KHR stage,
                                        VkQueryPool queryPool, uint32_t query) const
{
    TKIT_ASSERT(this->vkCmdWriteTimestamp2KHR,
                "[VULKIT][LOADER] The function 'vkCmdWriteTimestamp2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdWriteTimestamp2KHR(commandBuffer, stage, queryPool, query);
}
#endif
#if defined(VK_EXT_host_image_copy)
VkResult DeviceTable::CopyMemoryToImageEXT(VkDevice device,
                                           const VkCopyMemoryToImageInfoEXT *pCopyMemoryToImageInfo) const
{
    TKIT_ASSERT(this->vkCopyMemoryToImageEXT,
                "[VULKIT][LOADER] The function 'vkCopyMemoryToImageEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCopyMemoryToImageEXT(device, pCopyMemoryToImageInfo);
}
#endif
#if defined(VK_EXT_host_image_copy)
VkResult DeviceTable::CopyImageToMemoryEXT(VkDevice device,
                                           const VkCopyImageToMemoryInfoEXT *pCopyImageToMemoryInfo) const
{
    TKIT_ASSERT(this->vkCopyImageToMemoryEXT,
                "[VULKIT][LOADER] The function 'vkCopyImageToMemoryEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCopyImageToMemoryEXT(device, pCopyImageToMemoryInfo);
}
#endif
#if defined(VK_EXT_host_image_copy)
VkResult DeviceTable::CopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfoEXT *pCopyImageToImageInfo) const
{
    TKIT_ASSERT(this->vkCopyImageToImageEXT,
                "[VULKIT][LOADER] The function 'vkCopyImageToImageEXT' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkCopyImageToImageEXT(device, pCopyImageToImageInfo);
}
#endif
#if defined(VK_EXT_host_image_copy)
VkResult DeviceTable::TransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount,
                                               const VkHostImageLayoutTransitionInfoEXT *pTransitions) const
{
    TKIT_ASSERT(this->vkTransitionImageLayoutEXT,
                "[VULKIT][LOADER] The function 'vkTransitionImageLayoutEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkTransitionImageLayoutEXT(device, transitionCount, pTransitions);
}
#endif
#if defined(VK_KHR_dynamic_rendering)
void DeviceTable::CmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfoKHR *pRenderingInfo) const
{
    TKIT_ASSERT(this->vkCmdBeginRenderingKHR,
                "[VULKIT][LOADER] The function 'vkCmdBeginRenderingKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBeginRenderingKHR(commandBuffer, pRenderingInfo);
}
#endif
#if defined(VK_KHR_dynamic_rendering)
void DeviceTable::CmdEndRenderingKHR(VkCommandBuffer commandBuffer) const
{
    TKIT_ASSERT(this->vkCmdEndRenderingKHR,
                "[VULKIT][LOADER] The function 'vkCmdEndRenderingKHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdEndRenderingKHR(commandBuffer);
}
#endif
#if defined(VK_KHR_maintenance5)
void DeviceTable::GetImageSubresourceLayout2KHR(VkDevice device, VkImage image,
                                                const VkImageSubresource2KHR *pSubresource,
                                                VkSubresourceLayout2KHR *pLayout) const
{
    TKIT_ASSERT(this->vkGetImageSubresourceLayout2KHR,
                "[VULKIT][LOADER] The function 'vkGetImageSubresourceLayout2KHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetImageSubresourceLayout2KHR(device, image, pSubresource, pLayout);
}
#endif
#if defined(VK_EXT_host_image_copy) || defined(VK_EXT_image_compression_control)
void DeviceTable::GetImageSubresourceLayout2EXT(VkDevice device, VkImage image,
                                                const VkImageSubresource2EXT *pSubresource,
                                                VkSubresourceLayout2EXT *pLayout) const
{
    TKIT_ASSERT(this->vkGetImageSubresourceLayout2EXT,
                "[VULKIT][LOADER] The function 'vkGetImageSubresourceLayout2EXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkGetImageSubresourceLayout2EXT(device, image, pSubresource, pLayout);
}
#endif
#if defined(VK_EXT_swapchain_maintenance1)
VkResult DeviceTable::ReleaseSwapchainImagesEXT(VkDevice device,
                                                const VkReleaseSwapchainImagesInfoEXT *pReleaseInfo) const
{
    TKIT_ASSERT(this->vkReleaseSwapchainImagesEXT,
                "[VULKIT][LOADER] The function 'vkReleaseSwapchainImagesEXT' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    return this->vkReleaseSwapchainImagesEXT(device, pReleaseInfo);
}
#endif
#if defined(VK_KHR_maintenance5)
void DeviceTable::GetDeviceImageSubresourceLayoutKHR(VkDevice device, const VkDeviceImageSubresourceInfoKHR *pInfo,
                                                     VkSubresourceLayout2KHR *pLayout) const
{
    TKIT_ASSERT(this->vkGetDeviceImageSubresourceLayoutKHR,
                "[VULKIT][LOADER] The function 'vkGetDeviceImageSubresourceLayoutKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkGetDeviceImageSubresourceLayoutKHR(device, pInfo, pLayout);
}
#endif
#if defined(VK_KHR_map_memory2)
VkResult DeviceTable::MapMemory2KHR(VkDevice device, const VkMemoryMapInfoKHR *pMemoryMapInfo, void **ppData) const
{
    TKIT_ASSERT(this->vkMapMemory2KHR,
                "[VULKIT][LOADER] The function 'vkMapMemory2KHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkMapMemory2KHR(device, pMemoryMapInfo, ppData);
}
#endif
#if defined(VK_KHR_map_memory2)
VkResult DeviceTable::UnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfoKHR *pMemoryUnmapInfo) const
{
    TKIT_ASSERT(this->vkUnmapMemory2KHR,
                "[VULKIT][LOADER] The function 'vkUnmapMemory2KHR' is not available for the instance or device being "
                "used, either because VKit::Initialize() was not called or because the feature or extension "
                "bound to the function has not been enabled");
    return this->vkUnmapMemory2KHR(device, pMemoryUnmapInfo);
}
#endif
#if defined(VK_KHR_maintenance6)
void DeviceTable::CmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer,
                                            const VkBindDescriptorSetsInfoKHR *pBindDescriptorSetsInfo) const
{
    TKIT_ASSERT(this->vkCmdBindDescriptorSets2KHR,
                "[VULKIT][LOADER] The function 'vkCmdBindDescriptorSets2KHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdBindDescriptorSets2KHR(commandBuffer, pBindDescriptorSetsInfo);
}
#endif
#if defined(VK_KHR_maintenance6)
void DeviceTable::CmdPushConstants2KHR(VkCommandBuffer commandBuffer,
                                       const VkPushConstantsInfoKHR *pPushConstantsInfo) const
{
    TKIT_ASSERT(this->vkCmdPushConstants2KHR,
                "[VULKIT][LOADER] The function 'vkCmdPushConstants2KHR' is not available for the instance or device "
                "being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdPushConstants2KHR(commandBuffer, pPushConstantsInfo);
}
#endif
#if (defined(VK_KHR_maintenance6) && defined(VK_KHR_push_descriptor))
void DeviceTable::CmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer,
                                           const VkPushDescriptorSetInfoKHR *pPushDescriptorSetInfo) const
{
    TKIT_ASSERT(this->vkCmdPushDescriptorSet2KHR,
                "[VULKIT][LOADER] The function 'vkCmdPushDescriptorSet2KHR' is not available for the instance or "
                "device being used, either because VKit::Initialize() was not called or because the feature or "
                "extension bound to the function has not been enabled");
    this->vkCmdPushDescriptorSet2KHR(commandBuffer, pPushDescriptorSetInfo);
}
#endif
#if (defined(VK_KHR_maintenance6) && defined(VK_KHR_push_descriptor))
void DeviceTable::CmdPushDescriptorSetWithTemplate2KHR(
    VkCommandBuffer commandBuffer,
    const VkPushDescriptorSetWithTemplateInfoKHR *pPushDescriptorSetWithTemplateInfo) const
{
    TKIT_ASSERT(this->vkCmdPushDescriptorSetWithTemplate2KHR,
                "[VULKIT][LOADER] The function 'vkCmdPushDescriptorSetWithTemplate2KHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdPushDescriptorSetWithTemplate2KHR(commandBuffer, pPushDescriptorSetWithTemplateInfo);
}
#endif
#if defined(VK_KHR_dynamic_rendering_local_read)
void DeviceTable::CmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer,
                                                        const VkRenderingAttachmentLocationInfoKHR *pLocationInfo) const
{
    TKIT_ASSERT(this->vkCmdSetRenderingAttachmentLocationsKHR,
                "[VULKIT][LOADER] The function 'vkCmdSetRenderingAttachmentLocationsKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetRenderingAttachmentLocationsKHR(commandBuffer, pLocationInfo);
}
#endif
#if defined(VK_KHR_dynamic_rendering_local_read)
void DeviceTable::CmdSetRenderingInputAttachmentIndicesKHR(
    VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfoKHR *pInputAttachmentIndexInfo) const
{
    TKIT_ASSERT(this->vkCmdSetRenderingInputAttachmentIndicesKHR,
                "[VULKIT][LOADER] The function 'vkCmdSetRenderingInputAttachmentIndicesKHR' is not available for the "
                "instance or device being used, either because VKit::Initialize() was not called or because the "
                "feature or extension bound to the function has not been enabled");
    this->vkCmdSetRenderingInputAttachmentIndicesKHR(commandBuffer, pInputAttachmentIndexInfo);
}
#endif
} // namespace VKit::Vulkan
#if defined(TKIT_OS_APPLE) || defined(TKIT_OS_LINUX)
#    include <dlfcn.h>
#elif defined(TKIT_OS_WINDOWS)
#    include "tkit/core/windows.hpp"
#else
#    error "[VULKIT] Unsupported platform to load Vulkan library"
#endif
namespace VKit::Vulkan
{

void Load(void *library)
{
#if defined(TKIT_OS_APPLE) || defined(TKIT_OS_LINUX)
    Vulkan::vkGetInstanceProcAddr =
        reinterpret_cast<PFN_vkGetInstanceProcAddr>(dlsym(library, "vkGetInstanceProcAddr"));
#else
    Vulkan::vkGetInstanceProcAddr = reinterpret_cast<PFN_vkGetInstanceProcAddr>(
        GetProcAddress(reinterpret_cast<HMODULE>(library), "vkGetInstanceProcAddr"));
#endif

#if defined(VKIT_API_VERSION_1_0)
    Vulkan::vkCreateInstance =
        reinterpret_cast<PFN_vkCreateInstance>(GetInstanceProcAddr(VK_NULL_HANDLE, "vkCreateInstance"));
#endif
#if defined(VKIT_API_VERSION_1_1)
    Vulkan::vkEnumerateInstanceVersion = reinterpret_cast<PFN_vkEnumerateInstanceVersion>(
        GetInstanceProcAddr(VK_NULL_HANDLE, "vkEnumerateInstanceVersion"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    Vulkan::vkEnumerateInstanceLayerProperties = reinterpret_cast<PFN_vkEnumerateInstanceLayerProperties>(
        GetInstanceProcAddr(VK_NULL_HANDLE, "vkEnumerateInstanceLayerProperties"));
#endif
#if defined(VKIT_API_VERSION_1_0)
    Vulkan::vkEnumerateInstanceExtensionProperties = reinterpret_cast<PFN_vkEnumerateInstanceExtensionProperties>(
        GetInstanceProcAddr(VK_NULL_HANDLE, "vkEnumerateInstanceExtensionProperties"));
#endif
}
} // namespace VKit::Vulkan
